{"remainingRequest":"E:\\WebRoot\\tablex\\node_modules\\thread-loader\\dist\\cjs.js??ref--5-1!E:\\WebRoot\\tablex\\node_modules\\babel-loader\\lib\\index.js??ref--5-2!E:\\WebRoot\\tablex\\node_modules\\source-map-loader\\index.js!E:\\WebRoot\\tablex\\src\\helper.js","dependencies":[{"path":"E:\\WebRoot\\tablex\\src\\helper.js","mtime":1559204542871},{"path":"E:\\WebRoot\\tablex\\node_modules\\umi-library\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1559204841349},{"path":"E:\\WebRoot\\tablex\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1554780430526},{"path":"E:\\WebRoot\\tablex\\node_modules\\babel-loader\\lib\\index.js","mtime":1551944504366},{"path":"E:\\WebRoot\\tablex\\node_modules\\source-map-loader\\index.js","mtime":1551944506105}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSJFOlxcV2ViUm9vdFxcdGFibGV4XFxub2RlX21vZHVsZXNcXHVtaS1saWJyYXJ5XFxub2RlX21vZHVsZXNcXGRvY3pcXG5vZGVfbW9kdWxlc1xcYmFiZWwtcHJlc2V0LXJlYWN0LWFwcFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkIjtpbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20iRTpcXFdlYlJvb3RcXHRhYmxleFxcbm9kZV9tb2R1bGVzXFx1bWktbGlicmFyeVxcbm9kZV9tb2R1bGVzXFxkb2N6XFxub2RlX21vZHVsZXNcXGJhYmVsLXByZXNldC1yZWFjdC1hcHBcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsvKioNCiAqIFBlcmZvcm1zIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG92ZXIgYWxsIG9mIHRoZSBub2RlIGRlc2NlbmRhbnRzLA0KICogaW5jcmVtZW50aW5nIGN1cnJlbnRJbmRleCBieSAxIGZvciBlYWNoDQogKi9mdW5jdGlvbiBnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoX3JlZil7dmFyIHRhcmdldEluZGV4PV9yZWYudGFyZ2V0SW5kZXgsbm9kZT1fcmVmLm5vZGUsY3VycmVudEluZGV4PV9yZWYuY3VycmVudEluZGV4LGdldE5vZGVLZXk9X3JlZi5nZXROb2RlS2V5LF9yZWYkcGF0aD1fcmVmLnBhdGgscGF0aD1fcmVmJHBhdGg9PT12b2lkIDA/W106X3JlZiRwYXRoLF9yZWYkbG93ZXJTaWJsaW5nQ291bj1fcmVmLmxvd2VyU2libGluZ0NvdW50cyxsb3dlclNpYmxpbmdDb3VudHM9X3JlZiRsb3dlclNpYmxpbmdDb3VuPT09dm9pZCAwP1tdOl9yZWYkbG93ZXJTaWJsaW5nQ291bixfcmVmJGlnbm9yZUNvbGxhcHNlZD1fcmVmLmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZiRpZ25vcmVDb2xsYXBzZWQ9PT12b2lkIDA/dHJ1ZTpfcmVmJGlnbm9yZUNvbGxhcHNlZCxfcmVmJGlzUHNldWRvUm9vdD1fcmVmLmlzUHNldWRvUm9vdCxpc1BzZXVkb1Jvb3Q9X3JlZiRpc1BzZXVkb1Jvb3Q9PT12b2lkIDA/ZmFsc2U6X3JlZiRpc1BzZXVkb1Jvb3Q7Ly8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCnZhciBzZWxmUGF0aD0haXNQc2V1ZG9Sb290P1tdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksW2dldE5vZGVLZXkoe25vZGU6bm9kZSx0cmVlSW5kZXg6Y3VycmVudEluZGV4fSldKTpbXTsvLyBSZXR1cm4gdGFyZ2V0IG5vZGUgd2hlbiBmb3VuZAppZihjdXJyZW50SW5kZXg9PT10YXJnZXRJbmRleCl7cmV0dXJue25vZGU6bm9kZSxsb3dlclNpYmxpbmdDb3VudHM6bG93ZXJTaWJsaW5nQ291bnRzLHBhdGg6c2VsZlBhdGh9O30vLyBBZGQgb25lIGFuZCBjb250aW51ZSBmb3Igbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KaWYoIW5vZGUuY2hpbGRyZW58fGlnbm9yZUNvbGxhcHNlZCYmbm9kZS5leHBhbmRlZCE9PXRydWUpe3JldHVybntuZXh0SW5kZXg6Y3VycmVudEluZGV4KzF9O30vLyBJdGVyYXRlIG92ZXIgZWFjaCBjaGlsZCBhbmQgdGhlaXIgZGVzY2VuZGFudHMgYW5kIHJldHVybiB0aGUKLy8gdGFyZ2V0IG5vZGUgaWYgY2hpbGRJbmRleCByZWFjaGVzIHRoZSB0YXJnZXRJbmRleAp2YXIgY2hpbGRJbmRleD1jdXJyZW50SW5kZXgrMTt2YXIgY2hpbGRDb3VudD1ub2RlLmNoaWxkcmVuLmxlbmd0aDtmb3IodmFyIGk9MDtpPGNoaWxkQ291bnQ7aSs9MSl7dmFyIHJlc3VsdD1nZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoe2lnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsZ2V0Tm9kZUtleTpnZXROb2RlS2V5LHRhcmdldEluZGV4OnRhcmdldEluZGV4LG5vZGU6bm9kZS5jaGlsZHJlbltpXSxjdXJyZW50SW5kZXg6Y2hpbGRJbmRleCxsb3dlclNpYmxpbmdDb3VudHM6W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb3dlclNpYmxpbmdDb3VudHMpLFtjaGlsZENvdW50LWktMV0pLHBhdGg6c2VsZlBhdGh9KTtpZihyZXN1bHQubm9kZSl7cmV0dXJuIHJlc3VsdDt9Y2hpbGRJbmRleD1yZXN1bHQubmV4dEluZGV4O30vLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgbm90IGZvdW5kLCByZXR1cm4gdGhlIGZhcnRoZXN0IHRyYXZlcnNlZCBpbmRleApyZXR1cm57bmV4dEluZGV4OmNoaWxkSW5kZXh9O31leHBvcnQgZnVuY3Rpb24gZ2V0RGVzY2VuZGFudENvdW50KF9yZWYyKXt2YXIgbm9kZT1fcmVmMi5ub2RlLF9yZWYyJGlnbm9yZUNvbGxhcHNlZD1fcmVmMi5pZ25vcmVDb2xsYXBzZWQsaWdub3JlQ29sbGFwc2VkPV9yZWYyJGlnbm9yZUNvbGxhcHNlZD09PXZvaWQgMD90cnVlOl9yZWYyJGlnbm9yZUNvbGxhcHNlZDtyZXR1cm4gZ2V0Tm9kZURhdGFBdFRyZWVJbmRleE9yTmV4dEluZGV4KHtnZXROb2RlS2V5OmZ1bmN0aW9uIGdldE5vZGVLZXkoKXt9LGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsbm9kZTpub2RlLGN1cnJlbnRJbmRleDowLHRhcmdldEluZGV4Oi0xfSkubmV4dEluZGV4LTE7fS8qKg0KICogV2FsayBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIGdpdmVuIG5vZGUsIGRlcHRoLWZpcnN0DQogKg0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBGdW5jdGlvbiBwYXJhbWV0ZXJzDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIG5vZGUNCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFyZ3MuZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhcmdzLmlzUHNldWRvUm9vdCAtIElmIHRydWUsIHRoaXMgbm9kZSBoYXMgbm8gcmVhbCBkYXRhLCBhbmQgb25seSBzZXJ2ZXMNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBwYXJlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgdHJlZQ0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3Mubm9kZSAtIEEgdHJlZSBub2RlDQogKiBAcGFyYW0ge09iamVjdD19IGFyZ3MucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiBgbm9kZWANCiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmN1cnJlbnRJbmRleCAtIFRoZSB0cmVlSW5kZXggb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBhcmdzLnBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBjaGFuZ2VkDQogKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLmxvd2VyU2libGluZ0NvdW50cyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvdW50IG9mIHNpYmxpbmdzIGJlbmVhdGggdGhlDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzIG5vZGVzIGluIHRoaXMgcGF0aA0KICoNCiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gbmV4dEluZGV4IC0gSW5kZXggb2YgdGhlIG5leHQgc2libGluZyBvZiBgbm9kZWAsDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGZhbHNlIGlmIHRoZSB3YWxrIHNob3VsZCBiZSB0ZXJtaW5hdGVkDQogKi9pZih0eXBlb2YgZ2V0RGVzY2VuZGFudENvdW50IT09J3VuZGVmaW5lZCcmJmdldERlc2NlbmRhbnRDb3VudCYmZ2V0RGVzY2VuZGFudENvdW50PT09T2JqZWN0KGdldERlc2NlbmRhbnRDb3VudCkmJk9iamVjdC5pc0V4dGVuc2libGUoZ2V0RGVzY2VuZGFudENvdW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGdldERlc2NlbmRhbnRDb3VudCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiZ2V0RGVzY2VuZGFudENvdW50IixmaWxlbmFtZToic3JjXFxoZWxwZXIuanMifX0pO31mdW5jdGlvbiB3YWxrRGVzY2VuZGFudHMoX3JlZjMpe3ZhciBjYWxsYmFjaz1fcmVmMy5jYWxsYmFjayxnZXROb2RlS2V5PV9yZWYzLmdldE5vZGVLZXksaWdub3JlQ29sbGFwc2VkPV9yZWYzLmlnbm9yZUNvbGxhcHNlZCxfcmVmMyRpc1BzZXVkb1Jvb3Q9X3JlZjMuaXNQc2V1ZG9Sb290LGlzUHNldWRvUm9vdD1fcmVmMyRpc1BzZXVkb1Jvb3Q9PT12b2lkIDA/ZmFsc2U6X3JlZjMkaXNQc2V1ZG9Sb290LG5vZGU9X3JlZjMubm9kZSxfcmVmMyRwYXJlbnROb2RlPV9yZWYzLnBhcmVudE5vZGUscGFyZW50Tm9kZT1fcmVmMyRwYXJlbnROb2RlPT09dm9pZCAwP251bGw6X3JlZjMkcGFyZW50Tm9kZSxjdXJyZW50SW5kZXg9X3JlZjMuY3VycmVudEluZGV4LF9yZWYzJHBhdGg9X3JlZjMucGF0aCxwYXRoPV9yZWYzJHBhdGg9PT12b2lkIDA/W106X3JlZjMkcGF0aCxfcmVmMyRsb3dlclNpYmxpbmdDb3U9X3JlZjMubG93ZXJTaWJsaW5nQ291bnRzLGxvd2VyU2libGluZ0NvdW50cz1fcmVmMyRsb3dlclNpYmxpbmdDb3U9PT12b2lkIDA/W106X3JlZjMkbG93ZXJTaWJsaW5nQ291Oy8vIFRoZSBwc2V1ZG8tcm9vdCBpcyBub3QgY29uc2lkZXJlZCBpbiB0aGUgcGF0aAp2YXIgc2VsZlBhdGg9aXNQc2V1ZG9Sb290P1tdOltdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksW2dldE5vZGVLZXkoe25vZGU6bm9kZSx0cmVlSW5kZXg6Y3VycmVudEluZGV4fSldKTt2YXIgc2VsZkluZm89aXNQc2V1ZG9Sb290P251bGw6e25vZGU6bm9kZSxwYXJlbnROb2RlOnBhcmVudE5vZGUscGF0aDpzZWxmUGF0aCxsb3dlclNpYmxpbmdDb3VudHM6bG93ZXJTaWJsaW5nQ291bnRzLHRyZWVJbmRleDpjdXJyZW50SW5kZXh9O2lmKCFpc1BzZXVkb1Jvb3Qpe3ZhciBjYWxsYmFja1Jlc3VsdD1jYWxsYmFjayhzZWxmSW5mbyk7Ly8gQ3V0IHdhbGsgc2hvcnQgaWYgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlCmlmKGNhbGxiYWNrUmVzdWx0PT09ZmFsc2Upe3JldHVybiBmYWxzZTt9fS8vIFJldHVybiBzZWxmIG9uIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gb3IgaGlkZGVuIGNoaWxkcmVuCmlmKCFub2RlLmNoaWxkcmVufHxub2RlLmV4cGFuZGVkIT09dHJ1ZSYmaWdub3JlQ29sbGFwc2VkJiYhaXNQc2V1ZG9Sb290KXtyZXR1cm4gY3VycmVudEluZGV4O30vLyBHZXQgYWxsIGRlc2NlbmRhbnRzCnZhciBjaGlsZEluZGV4PWN1cnJlbnRJbmRleDt2YXIgY2hpbGRDb3VudD1ub2RlLmNoaWxkcmVuLmxlbmd0aDtpZih0eXBlb2Ygbm9kZS5jaGlsZHJlbiE9PSJmdW5jdGlvbiIpe2Zvcih2YXIgaT0wO2k8Y2hpbGRDb3VudDtpKz0xKXtjaGlsZEluZGV4PXdhbGtEZXNjZW5kYW50cyh7Y2FsbGJhY2s6Y2FsbGJhY2ssZ2V0Tm9kZUtleTpnZXROb2RlS2V5LGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsbm9kZTpub2RlLmNoaWxkcmVuW2ldLHBhcmVudE5vZGU6aXNQc2V1ZG9Sb290P251bGw6bm9kZSxjdXJyZW50SW5kZXg6Y2hpbGRJbmRleCsxLGxvd2VyU2libGluZ0NvdW50czpbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvd2VyU2libGluZ0NvdW50cyksW2NoaWxkQ291bnQtaS0xXSkscGF0aDpzZWxmUGF0aH0pOy8vIEN1dCB3YWxrIHNob3J0IGlmIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmYWxzZQppZihjaGlsZEluZGV4PT09ZmFsc2Upe3JldHVybiBmYWxzZTt9fX1yZXR1cm4gY2hpbGRJbmRleDt9LyoqDQogKiBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBnaXZlbiBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCB0cmF2ZXJzaW5nIHRoZSB0cmVlIGRlcHRoLWZpcnN0DQogKg0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBGdW5jdGlvbiBwYXJhbWV0ZXJzDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIG5vZGUNCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFyZ3MuZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhcmdzLmlzUHNldWRvUm9vdCAtIElmIHRydWUsIHRoaXMgbm9kZSBoYXMgbm8gcmVhbCBkYXRhLCBhbmQgb25seSBzZXJ2ZXMNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBwYXJlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgdHJlZQ0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3Mubm9kZSAtIEEgdHJlZSBub2RlDQogKiBAcGFyYW0ge09iamVjdD19IGFyZ3MucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiBgbm9kZWANCiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmN1cnJlbnRJbmRleCAtIFRoZSB0cmVlSW5kZXggb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBhcmdzLnBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBjaGFuZ2VkDQogKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLmxvd2VyU2libGluZ0NvdW50cyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvdW50IG9mIHNpYmxpbmdzIGJlbmVhdGggdGhlDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzIG5vZGVzIGluIHRoaXMgcGF0aA0KICoNCiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gbmV4dEluZGV4IC0gSW5kZXggb2YgdGhlIG5leHQgc2libGluZyBvZiBgbm9kZWAsDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGZhbHNlIGlmIHRoZSB3YWxrIHNob3VsZCBiZSB0ZXJtaW5hdGVkDQogKi9mdW5jdGlvbiBtYXBEZXNjZW5kYW50cyhfcmVmNCl7dmFyIGNhbGxiYWNrPV9yZWY0LmNhbGxiYWNrLGdldE5vZGVLZXk9X3JlZjQuZ2V0Tm9kZUtleSxpZ25vcmVDb2xsYXBzZWQ9X3JlZjQuaWdub3JlQ29sbGFwc2VkLF9yZWY0JGlzUHNldWRvUm9vdD1fcmVmNC5pc1BzZXVkb1Jvb3QsaXNQc2V1ZG9Sb290PV9yZWY0JGlzUHNldWRvUm9vdD09PXZvaWQgMD9mYWxzZTpfcmVmNCRpc1BzZXVkb1Jvb3Qsbm9kZT1fcmVmNC5ub2RlLF9yZWY0JHBhcmVudE5vZGU9X3JlZjQucGFyZW50Tm9kZSxwYXJlbnROb2RlPV9yZWY0JHBhcmVudE5vZGU9PT12b2lkIDA/bnVsbDpfcmVmNCRwYXJlbnROb2RlLGN1cnJlbnRJbmRleD1fcmVmNC5jdXJyZW50SW5kZXgsX3JlZjQkcGF0aD1fcmVmNC5wYXRoLHBhdGg9X3JlZjQkcGF0aD09PXZvaWQgMD9bXTpfcmVmNCRwYXRoLF9yZWY0JGxvd2VyU2libGluZ0NvdT1fcmVmNC5sb3dlclNpYmxpbmdDb3VudHMsbG93ZXJTaWJsaW5nQ291bnRzPV9yZWY0JGxvd2VyU2libGluZ0NvdT09PXZvaWQgMD9bXTpfcmVmNCRsb3dlclNpYmxpbmdDb3U7dmFyIG5leHROb2RlPV9vYmplY3RTcHJlYWQoe30sbm9kZSk7Ly8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCnZhciBzZWxmUGF0aD1pc1BzZXVkb1Jvb3Q/W106W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXRoKSxbZ2V0Tm9kZUtleSh7bm9kZTpuZXh0Tm9kZSx0cmVlSW5kZXg6Y3VycmVudEluZGV4fSldKTt2YXIgc2VsZkluZm89e25vZGU6bmV4dE5vZGUscGFyZW50Tm9kZTpwYXJlbnROb2RlLHBhdGg6c2VsZlBhdGgsbG93ZXJTaWJsaW5nQ291bnRzOmxvd2VyU2libGluZ0NvdW50cyx0cmVlSW5kZXg6Y3VycmVudEluZGV4fTsvLyBSZXR1cm4gc2VsZiBvbiBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIG9yIGhpZGRlbiBjaGlsZHJlbgppZighbmV4dE5vZGUuY2hpbGRyZW58fG5leHROb2RlLmV4cGFuZGVkIT09dHJ1ZSYmaWdub3JlQ29sbGFwc2VkJiYhaXNQc2V1ZG9Sb290KXtyZXR1cm57dHJlZUluZGV4OmN1cnJlbnRJbmRleCxub2RlOmNhbGxiYWNrKHNlbGZJbmZvKX07fS8vIEdldCBhbGwgZGVzY2VuZGFudHMKdmFyIGNoaWxkSW5kZXg9Y3VycmVudEluZGV4O3ZhciBjaGlsZENvdW50PW5leHROb2RlLmNoaWxkcmVuLmxlbmd0aDtpZih0eXBlb2YgbmV4dE5vZGUuY2hpbGRyZW4hPT0iZnVuY3Rpb24iKXtuZXh0Tm9kZS5jaGlsZHJlbj1uZXh0Tm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQsaSl7dmFyIG1hcFJlc3VsdD1tYXBEZXNjZW5kYW50cyh7Y2FsbGJhY2s6Y2FsbGJhY2ssZ2V0Tm9kZUtleTpnZXROb2RlS2V5LGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsbm9kZTpjaGlsZCxwYXJlbnROb2RlOmlzUHNldWRvUm9vdD9udWxsOm5leHROb2RlLGN1cnJlbnRJbmRleDpjaGlsZEluZGV4KzEsbG93ZXJTaWJsaW5nQ291bnRzOltdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG93ZXJTaWJsaW5nQ291bnRzKSxbY2hpbGRDb3VudC1pLTFdKSxwYXRoOnNlbGZQYXRofSk7Y2hpbGRJbmRleD1tYXBSZXN1bHQudHJlZUluZGV4O3JldHVybiBtYXBSZXN1bHQubm9kZTt9KTt9cmV0dXJue25vZGU6Y2FsbGJhY2soc2VsZkluZm8pLHRyZWVJbmRleDpjaGlsZEluZGV4fTt9LyoqDQogKiBDb3VudCBhbGwgdGhlIHZpc2libGUgKGV4cGFuZGVkKSBkZXNjZW5kYW50cyBpbiB0aGUgdHJlZSBkYXRhLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICoNCiAqIEByZXR1cm4ge251bWJlcn0gY291bnQNCiAqL2V4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlTm9kZUNvdW50KF9yZWY1KXt2YXIgdHJlZURhdGE9X3JlZjUudHJlZURhdGE7dmFyIHRyYXZlcnNlPWZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUpe2lmKCFub2RlLmNoaWxkcmVufHxub2RlLmV4cGFuZGVkIT09dHJ1ZXx8dHlwZW9mIG5vZGUuY2hpbGRyZW49PT0iZnVuY3Rpb24iKXtyZXR1cm4gMTt9cmV0dXJuIDErbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24odG90YWwsY3VycmVudE5vZGUpe3JldHVybiB0b3RhbCt0cmF2ZXJzZShjdXJyZW50Tm9kZSk7fSwwKTt9O3JldHVybiB0cmVlRGF0YS5yZWR1Y2UoZnVuY3Rpb24odG90YWwsY3VycmVudE5vZGUpe3JldHVybiB0b3RhbCt0cmF2ZXJzZShjdXJyZW50Tm9kZSk7fSwwKTt9LyoqDQogKiBHZXQgdGhlIDx0YXJnZXRJbmRleD50aCB2aXNpYmxlIG5vZGUgaW4gdGhlIHRyZWUgZGF0YS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGEgLSBUcmVlIGRhdGENCiAqIEBwYXJhbSB7IW51bWJlcn0gdGFyZ2V0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUgdG8gc2VhcmNoIGZvcg0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICoNCiAqIEByZXR1cm4ge3sNCiAqICAgICAgbm9kZTogT2JqZWN0LA0KICogICAgICBwYXRoOiBbXXN0cmluZ3xbXW51bWJlciwNCiAqICAgICAgbG93ZXJTaWJsaW5nQ291bnRzOiBbXW51bWJlcg0KICogIH18bnVsbH0gbm9kZSAtIFRoZSBub2RlIGF0IHRhcmdldEluZGV4LCBvciBudWxsIGlmIG5vdCBmb3VuZA0KICovaWYodHlwZW9mIGdldFZpc2libGVOb2RlQ291bnQhPT0ndW5kZWZpbmVkJyYmZ2V0VmlzaWJsZU5vZGVDb3VudCYmZ2V0VmlzaWJsZU5vZGVDb3VudD09PU9iamVjdChnZXRWaXNpYmxlTm9kZUNvdW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXRWaXNpYmxlTm9kZUNvdW50KSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGdldFZpc2libGVOb2RlQ291bnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6ImdldFZpc2libGVOb2RlQ291bnQiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4KF9yZWY2KXt2YXIgdHJlZURhdGE9X3JlZjYudHJlZURhdGEsdGFyZ2V0SW5kZXg9X3JlZjYuaW5kZXgsZ2V0Tm9kZUtleT1fcmVmNi5nZXROb2RlS2V5O2lmKCF0cmVlRGF0YXx8dHJlZURhdGEubGVuZ3RoPDEpe3JldHVybiBudWxsO30vLyBDYWxsIHRoZSB0cmVlIHRyYXZlcnNhbCB3aXRoIGEgcHNldWRvLXJvb3Qgbm9kZQp2YXIgcmVzdWx0PWdldE5vZGVEYXRhQXRUcmVlSW5kZXhPck5leHRJbmRleCh7dGFyZ2V0SW5kZXg6dGFyZ2V0SW5kZXgsZ2V0Tm9kZUtleTpnZXROb2RlS2V5LG5vZGU6e2NoaWxkcmVuOnRyZWVEYXRhLGV4cGFuZGVkOnRydWV9LGN1cnJlbnRJbmRleDotMSxwYXRoOltdLGxvd2VyU2libGluZ0NvdW50czpbXSxpc1BzZXVkb1Jvb3Q6dHJ1ZX0pO2lmKHJlc3VsdC5ub2RlKXtyZXR1cm4gcmVzdWx0O31yZXR1cm4gbnVsbDt9LyoqDQogKiBXYWxrIGRlc2NlbmRhbnRzIGRlcHRoLWZpcnN0IGFuZCBjYWxsIGEgY2FsbGJhY2sgb24gZWFjaA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggbm9kZQ0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB2b2lkDQogKi9pZih0eXBlb2YgZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCE9PSd1bmRlZmluZWQnJiZnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4JiZnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4PT09T2JqZWN0KGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIHdhbGsoX3JlZjcpe3ZhciB0cmVlRGF0YT1fcmVmNy50cmVlRGF0YSxnZXROb2RlS2V5PV9yZWY3LmdldE5vZGVLZXksY2FsbGJhY2s9X3JlZjcuY2FsbGJhY2ssX3JlZjckaWdub3JlQ29sbGFwc2VkPV9yZWY3Lmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZjckaWdub3JlQ29sbGFwc2VkPT09dm9pZCAwP3RydWU6X3JlZjckaWdub3JlQ29sbGFwc2VkO2lmKCF0cmVlRGF0YXx8dHJlZURhdGEubGVuZ3RoPDEpe3JldHVybjt9d2Fsa0Rlc2NlbmRhbnRzKHtjYWxsYmFjazpjYWxsYmFjayxnZXROb2RlS2V5OmdldE5vZGVLZXksaWdub3JlQ29sbGFwc2VkOmlnbm9yZUNvbGxhcHNlZCxpc1BzZXVkb1Jvb3Q6dHJ1ZSxub2RlOntjaGlsZHJlbjp0cmVlRGF0YX0sY3VycmVudEluZGV4Oi0xLHBhdGg6W10sbG93ZXJTaWJsaW5nQ291bnRzOltdfSk7fS8qKg0KICogUGVyZm9ybSBhIGRlcHRoLWZpcnN0IHRyYW5zdmVyc2FsIG9mIHRoZSBkZXNjZW5kYW50cyBhbmQNCiAqICBtYWtlIGEgY2hhbmdlIHRvIGV2ZXJ5IG5vZGUgaW4gdGhlIHRyZWUNCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGEgLSBUcmVlIGRhdGENCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIG5vZGUNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge09iamVjdFtdfSBjaGFuZ2VkVHJlZURhdGEgLSBUaGUgY2hhbmdlZCB0cmVlIGRhdGENCiAqL2lmKHR5cGVvZiB3YWxrIT09J3VuZGVmaW5lZCcmJndhbGsmJndhbGs9PT1PYmplY3Qod2FsaykmJk9iamVjdC5pc0V4dGVuc2libGUod2Fsaykpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3YWxrLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJ3YWxrIixmaWxlbmFtZToic3JjXFxoZWxwZXIuanMifX0pO31leHBvcnQgZnVuY3Rpb24gbWFwKF9yZWY4KXt2YXIgdHJlZURhdGE9X3JlZjgudHJlZURhdGEsZ2V0Tm9kZUtleT1fcmVmOC5nZXROb2RlS2V5LGNhbGxiYWNrPV9yZWY4LmNhbGxiYWNrLF9yZWY4JGlnbm9yZUNvbGxhcHNlZD1fcmVmOC5pZ25vcmVDb2xsYXBzZWQsaWdub3JlQ29sbGFwc2VkPV9yZWY4JGlnbm9yZUNvbGxhcHNlZD09PXZvaWQgMD90cnVlOl9yZWY4JGlnbm9yZUNvbGxhcHNlZDtpZighdHJlZURhdGF8fHRyZWVEYXRhLmxlbmd0aDwxKXtyZXR1cm5bXTt9cmV0dXJuIG1hcERlc2NlbmRhbnRzKHtjYWxsYmFjazpjYWxsYmFjayxnZXROb2RlS2V5OmdldE5vZGVLZXksaWdub3JlQ29sbGFwc2VkOmlnbm9yZUNvbGxhcHNlZCxpc1BzZXVkb1Jvb3Q6dHJ1ZSxub2RlOntjaGlsZHJlbjp0cmVlRGF0YX0sY3VycmVudEluZGV4Oi0xLHBhdGg6W10sbG93ZXJTaWJsaW5nQ291bnRzOltdfSkubm9kZS5jaGlsZHJlbjt9LyoqDQogKiBFeHBhbmQgb3IgY2xvc2UgZXZlcnkgbm9kZSBpbiB0aGUgdHJlZQ0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHs/Ym9vbGVhbn0gZXhwYW5kZWQgLSBXaGV0aGVyIHRoZSBub2RlIGlzIGV4cGFuZGVkIG9yIG5vdA0KICoNCiAqIEByZXR1cm4ge09iamVjdFtdfSBjaGFuZ2VkVHJlZURhdGEgLSBUaGUgY2hhbmdlZCB0cmVlIGRhdGENCiAqL2lmKHR5cGVvZiBtYXAhPT0ndW5kZWZpbmVkJyYmbWFwJiZtYXA9PT1PYmplY3QobWFwKSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShtYXApKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJtYXAiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiB0b2dnbGVFeHBhbmRlZEZvckFsbChfcmVmOSl7dmFyIHRyZWVEYXRhPV9yZWY5LnRyZWVEYXRhLF9yZWY5JGV4cGFuZGVkPV9yZWY5LmV4cGFuZGVkLGV4cGFuZGVkPV9yZWY5JGV4cGFuZGVkPT09dm9pZCAwP3RydWU6X3JlZjkkZXhwYW5kZWQ7cmV0dXJuIG1hcCh7dHJlZURhdGE6dHJlZURhdGEsY2FsbGJhY2s6ZnVuY3Rpb24gY2FsbGJhY2soX3JlZjEwKXt2YXIgbm9kZT1fcmVmMTAubm9kZTtyZXR1cm4gX29iamVjdFNwcmVhZCh7fSxub2RlLHtleHBhbmRlZDpleHBhbmRlZH0pO30sZ2V0Tm9kZUtleTpmdW5jdGlvbiBnZXROb2RlS2V5KF9yZWYxMSl7dmFyIHRyZWVJbmRleD1fcmVmMTEudHJlZUluZGV4O3JldHVybiB0cmVlSW5kZXg7fSxpZ25vcmVDb2xsYXBzZWQ6ZmFsc2V9KTt9LyoqDQogKiBSZXBsYWNlcyBub2RlIGF0IHBhdGggd2l0aCBvYmplY3QsIG9yIGNhbGxiYWNrLWRlZmluZWQgb2JqZWN0DQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgY2hhbmdlZA0KICogQHBhcmFtIHtmdW5jdGlvbnxhbnl9IG5ld05vZGUgLSBOb2RlIHRvIHJlcGxhY2UgdGhlIG5vZGUgYXQgdGhlIHBhdGggd2l0aCwgb3IgYSBmdW5jdGlvbiBwcm9kdWNpbmcgdGhlIG5ldyBub2RlDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gY2hhbmdlZFRyZWVEYXRhIC0gVGhlIGNoYW5nZWQgdHJlZSBkYXRhDQogKi9pZih0eXBlb2YgdG9nZ2xlRXhwYW5kZWRGb3JBbGwhPT0ndW5kZWZpbmVkJyYmdG9nZ2xlRXhwYW5kZWRGb3JBbGwmJnRvZ2dsZUV4cGFuZGVkRm9yQWxsPT09T2JqZWN0KHRvZ2dsZUV4cGFuZGVkRm9yQWxsKSYmT2JqZWN0LmlzRXh0ZW5zaWJsZSh0b2dnbGVFeHBhbmRlZEZvckFsbCkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0b2dnbGVFeHBhbmRlZEZvckFsbCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToidG9nZ2xlRXhwYW5kZWRGb3JBbGwiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VOb2RlQXRQYXRoKF9yZWYxMil7dmFyIHRyZWVEYXRhPV9yZWYxMi50cmVlRGF0YSxwYXRoPV9yZWYxMi5wYXRoLG5ld05vZGU9X3JlZjEyLm5ld05vZGUsZ2V0Tm9kZUtleT1fcmVmMTIuZ2V0Tm9kZUtleSxfcmVmMTIkaWdub3JlQ29sbGFwc2U9X3JlZjEyLmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZjEyJGlnbm9yZUNvbGxhcHNlPT09dm9pZCAwP3RydWU6X3JlZjEyJGlnbm9yZUNvbGxhcHNlO3ZhciBSRVNVTFRfTUlTUz0iUkVTVUxUX01JU1MiO3ZhciB0cmF2ZXJzZT1mdW5jdGlvbiB0cmF2ZXJzZShfcmVmMTMpe3ZhciBfcmVmMTMkaXNQc2V1ZG9Sb290PV9yZWYxMy5pc1BzZXVkb1Jvb3QsaXNQc2V1ZG9Sb290PV9yZWYxMyRpc1BzZXVkb1Jvb3Q9PT12b2lkIDA/ZmFsc2U6X3JlZjEzJGlzUHNldWRvUm9vdCxub2RlPV9yZWYxMy5ub2RlLGN1cnJlbnRUcmVlSW5kZXg9X3JlZjEzLmN1cnJlbnRUcmVlSW5kZXgscGF0aEluZGV4PV9yZWYxMy5wYXRoSW5kZXg7aWYoIWlzUHNldWRvUm9vdCYmZ2V0Tm9kZUtleSh7bm9kZTpub2RlLHRyZWVJbmRleDpjdXJyZW50VHJlZUluZGV4fSkhPT1wYXRoW3BhdGhJbmRleF0pe3JldHVybiBSRVNVTFRfTUlTUzt9aWYocGF0aEluZGV4Pj1wYXRoLmxlbmd0aC0xKXsvLyBJZiB0aGlzIGlzIHRoZSBmaW5hbCBsb2NhdGlvbiBpbiB0aGUgcGF0aCwgcmV0dXJuIGl0cyBjaGFuZ2VkIGZvcm0KcmV0dXJuIHR5cGVvZiBuZXdOb2RlPT09ImZ1bmN0aW9uIj9uZXdOb2RlKHtub2RlOm5vZGUsdHJlZUluZGV4OmN1cnJlbnRUcmVlSW5kZXh9KTpuZXdOb2RlO31pZighbm9kZS5jaGlsZHJlbil7Ly8gSWYgdGhpcyBub2RlIGlzIHBhcnQgb2YgdGhlIHBhdGgsIGJ1dCBoYXMgbm8gY2hpbGRyZW4sIHJldHVybiB0aGUgdW5jaGFuZ2VkIG5vZGUKdGhyb3cgbmV3IEVycm9yKCJQYXRoIHJlZmVyZW5jZWQgY2hpbGRyZW4gb2Ygbm9kZSB3aXRoIG5vIGNoaWxkcmVuLiIpO312YXIgbmV4dFRyZWVJbmRleD1jdXJyZW50VHJlZUluZGV4KzE7Zm9yKHZhciBpPTA7aTxub2RlLmNoaWxkcmVuLmxlbmd0aDtpKz0xKXt2YXIgX3Jlc3VsdD10cmF2ZXJzZSh7bm9kZTpub2RlLmNoaWxkcmVuW2ldLGN1cnJlbnRUcmVlSW5kZXg6bmV4dFRyZWVJbmRleCxwYXRoSW5kZXg6cGF0aEluZGV4KzF9KTsvLyBJZiB0aGUgcmVzdWx0IHdlbnQgZG93biB0aGUgY29ycmVjdCBwYXRoCmlmKF9yZXN1bHQhPT1SRVNVTFRfTUlTUyl7aWYoX3Jlc3VsdCl7Ly8gSWYgdGhlIHJlc3VsdCB3YXMgdHJ1dGh5IChpbiB0aGlzIGNhc2UsIGFuIG9iamVjdCksCi8vICBwYXNzIGl0IHRvIHRoZSBuZXh0IGxldmVsIG9mIHJlY3Vyc2lvbiB1cApyZXR1cm4gX29iamVjdFNwcmVhZCh7fSxub2RlLHtjaGlsZHJlbjpbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoMCxpKSksW19yZXN1bHRdLF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKGkrMSkpKX0pO30vLyBJZiB0aGUgcmVzdWx0IHdhcyBmYWxzeSAocmV0dXJuZWQgZnJvbSB0aGUgbmV3Tm9kZSBmdW5jdGlvbiksIHRoZW4KLy8gIGRlbGV0ZSB0aGUgbm9kZSBmcm9tIHRoZSBhcnJheS4KcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sbm9kZSx7Y2hpbGRyZW46W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKDAsaSkpLF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKGkrMSkpKX0pO31uZXh0VHJlZUluZGV4Kz0xK2dldERlc2NlbmRhbnRDb3VudCh7bm9kZTpub2RlLmNoaWxkcmVuW2ldLGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWR9KTt9cmV0dXJuIFJFU1VMVF9NSVNTO307Ly8gVXNlIGEgcHNldWRvLXJvb3Qgbm9kZSBpbiB0aGUgYmVnaW5uaW5nIHRyYXZlcnNhbAp2YXIgcmVzdWx0PXRyYXZlcnNlKHtub2RlOntjaGlsZHJlbjp0cmVlRGF0YX0sY3VycmVudFRyZWVJbmRleDotMSxwYXRoSW5kZXg6LTEsaXNQc2V1ZG9Sb290OnRydWV9KTtpZihyZXN1bHQ9PT1SRVNVTFRfTUlTUyl7dGhyb3cgbmV3IEVycm9yKCJObyBub2RlIGZvdW5kIGF0IHRoZSBnaXZlbiBwYXRoLiIpO31yZXR1cm4gcmVzdWx0LmNoaWxkcmVuO30vKioNCiAqIFJlbW92ZXMgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJlZURhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgZGVsZXRlZA0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IGNoYW5nZWRUcmVlRGF0YSAtIFRoZSB0cmVlIGRhdGEgd2l0aCB0aGUgbm9kZSByZW1vdmVkDQogKi9pZih0eXBlb2YgY2hhbmdlTm9kZUF0UGF0aCE9PSd1bmRlZmluZWQnJiZjaGFuZ2VOb2RlQXRQYXRoJiZjaGFuZ2VOb2RlQXRQYXRoPT09T2JqZWN0KGNoYW5nZU5vZGVBdFBhdGgpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGNoYW5nZU5vZGVBdFBhdGgpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbmdlTm9kZUF0UGF0aCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiY2hhbmdlTm9kZUF0UGF0aCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGVBdFBhdGgoX3JlZjE0KXt2YXIgdHJlZURhdGE9X3JlZjE0LnRyZWVEYXRhLHBhdGg9X3JlZjE0LnBhdGgsZ2V0Tm9kZUtleT1fcmVmMTQuZ2V0Tm9kZUtleSxfcmVmMTQkaWdub3JlQ29sbGFwc2U9X3JlZjE0Lmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZjE0JGlnbm9yZUNvbGxhcHNlPT09dm9pZCAwP3RydWU6X3JlZjE0JGlnbm9yZUNvbGxhcHNlO3JldHVybiBjaGFuZ2VOb2RlQXRQYXRoKHt0cmVlRGF0YTp0cmVlRGF0YSxwYXRoOnBhdGgsZ2V0Tm9kZUtleTpnZXROb2RlS2V5LGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsbmV3Tm9kZTpudWxsLy8gRGVsZXRlIHRoZSBub2RlCn0pO30vKioNCiAqIFJlbW92ZXMgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJlZURhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgZGVsZXRlZA0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQNCiAqIEByZXR1cm4ge09iamVjdFtdfSByZXN1bHQudHJlZURhdGEgLSBUaGUgdHJlZSBkYXRhIHdpdGggdGhlIG5vZGUgcmVtb3ZlZA0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQubm9kZSAtIFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQNCiAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LnRyZWVJbmRleCAtIFRoZSBwcmV2aW91cyB0cmVlSW5kZXggb2YgdGhlIHJlbW92ZWQgbm9kZQ0KICovaWYodHlwZW9mIHJlbW92ZU5vZGVBdFBhdGghPT0ndW5kZWZpbmVkJyYmcmVtb3ZlTm9kZUF0UGF0aCYmcmVtb3ZlTm9kZUF0UGF0aD09PU9iamVjdChyZW1vdmVOb2RlQXRQYXRoKSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShyZW1vdmVOb2RlQXRQYXRoKSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbW92ZU5vZGVBdFBhdGgsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6InJlbW92ZU5vZGVBdFBhdGgiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKF9yZWYxNSl7dmFyIHRyZWVEYXRhPV9yZWYxNS50cmVlRGF0YSxwYXRoPV9yZWYxNS5wYXRoLGdldE5vZGVLZXk9X3JlZjE1LmdldE5vZGVLZXksX3JlZjE1JGlnbm9yZUNvbGxhcHNlPV9yZWYxNS5pZ25vcmVDb2xsYXBzZWQsaWdub3JlQ29sbGFwc2VkPV9yZWYxNSRpZ25vcmVDb2xsYXBzZT09PXZvaWQgMD90cnVlOl9yZWYxNSRpZ25vcmVDb2xsYXBzZTt2YXIgcmVtb3ZlZE5vZGU9bnVsbDt2YXIgcmVtb3ZlZFRyZWVJbmRleD1udWxsO3ZhciBuZXh0VHJlZURhdGE9Y2hhbmdlTm9kZUF0UGF0aCh7dHJlZURhdGE6dHJlZURhdGEscGF0aDpwYXRoLGdldE5vZGVLZXk6Z2V0Tm9kZUtleSxpZ25vcmVDb2xsYXBzZWQ6aWdub3JlQ29sbGFwc2VkLG5ld05vZGU6ZnVuY3Rpb24gbmV3Tm9kZShfcmVmMTYpe3ZhciBub2RlPV9yZWYxNi5ub2RlLHRyZWVJbmRleD1fcmVmMTYudHJlZUluZGV4Oy8vIFN0b3JlIHRoZSB0YXJnZXQgbm9kZSBhbmQgZGVsZXRlIGl0IGZyb20gdGhlIHRyZWUKcmVtb3ZlZE5vZGU9bm9kZTtyZW1vdmVkVHJlZUluZGV4PXRyZWVJbmRleDtyZXR1cm4gbnVsbDt9fSk7cmV0dXJue3RyZWVEYXRhOm5leHRUcmVlRGF0YSxub2RlOnJlbW92ZWROb2RlLHRyZWVJbmRleDpyZW1vdmVkVHJlZUluZGV4fTt9LyoqDQogKiBHZXRzIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YQ0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gcGF0aCAtIEFycmF5IG9mIGtleXMgbGVhZGluZyB1cCB0byBub2RlIHRvIGJlIGRlbGV0ZWQNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge09iamVjdHxudWxsfSBub2RlSW5mbyAtIFRoZSBub2RlIGluZm8gYXQgdGhlIGdpdmVuIHBhdGgsIG9yIG51bGwgaWYgbm90IGZvdW5kDQogKi9pZih0eXBlb2YgcmVtb3ZlTm9kZSE9PSd1bmRlZmluZWQnJiZyZW1vdmVOb2RlJiZyZW1vdmVOb2RlPT09T2JqZWN0KHJlbW92ZU5vZGUpJiZPYmplY3QuaXNFeHRlbnNpYmxlKHJlbW92ZU5vZGUpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocmVtb3ZlTm9kZSwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToicmVtb3ZlTm9kZSIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVBdFBhdGgoX3JlZjE3KXt2YXIgdHJlZURhdGE9X3JlZjE3LnRyZWVEYXRhLHBhdGg9X3JlZjE3LnBhdGgsZ2V0Tm9kZUtleT1fcmVmMTcuZ2V0Tm9kZUtleSxfcmVmMTckaWdub3JlQ29sbGFwc2U9X3JlZjE3Lmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZjE3JGlnbm9yZUNvbGxhcHNlPT09dm9pZCAwP3RydWU6X3JlZjE3JGlnbm9yZUNvbGxhcHNlO3ZhciBmb3VuZE5vZGVJbmZvPW51bGw7dHJ5e2NoYW5nZU5vZGVBdFBhdGgoe3RyZWVEYXRhOnRyZWVEYXRhLHBhdGg6cGF0aCxnZXROb2RlS2V5OmdldE5vZGVLZXksaWdub3JlQ29sbGFwc2VkOmlnbm9yZUNvbGxhcHNlZCxuZXdOb2RlOmZ1bmN0aW9uIG5ld05vZGUoX3JlZjE4KXt2YXIgbm9kZT1fcmVmMTgubm9kZSx0cmVlSW5kZXg9X3JlZjE4LnRyZWVJbmRleDtmb3VuZE5vZGVJbmZvPXtub2RlOm5vZGUsdHJlZUluZGV4OnRyZWVJbmRleH07cmV0dXJuIG5vZGU7fX0pO31jYXRjaChlcnIpey8vIElnbm9yZSB0aGUgZXJyb3IgLS0gdGhlIG51bGwgcmV0dXJuIHdpbGwgYmUgZXhwbGFuYXRpb24gZW5vdWdoCn1yZXR1cm4gZm91bmROb2RlSW5mbzt9LyoqDQogKiBBZGRzIHRoZSBub2RlIHRvIHRoZSBzcGVjaWZpZWQgcGFyZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJlZURhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0geyFPYmplY3R9IG5ld05vZGUgLSBUaGUgbm9kZSB0byBpbnNlcnQNCiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcGFyZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgdG8tYmUgcGFyZW50Tm9kZSBvZiB0aGUgbm9kZQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRQYXJlbnQgLSBJZiB0cnVlLCBleHBhbmRzIHRoZSBwYXJlbnROb2RlIHNwZWNpZmllZCBieSBwYXJlbnRQYXRoDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhZGRBc0ZpcnN0Q2hpbGQgLSBJZiB0cnVlLCBhZGRzIG5ldyBub2RlIGFzIGZpcnN0IGNoaWxkIG9mIHRyZWUNCiAqDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdA0KICogQHJldHVybiB7T2JqZWN0W119IHJlc3VsdC50cmVlRGF0YSAtIFRoZSB1cGRhdGVkIHRyZWUgZGF0YQ0KICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQudHJlZUluZGV4IC0gVGhlIHRyZWUgaW5kZXggYXQgd2hpY2ggdGhlIG5vZGUgd2FzIGluc2VydGVkDQogKi9pZih0eXBlb2YgZ2V0Tm9kZUF0UGF0aCE9PSd1bmRlZmluZWQnJiZnZXROb2RlQXRQYXRoJiZnZXROb2RlQXRQYXRoPT09T2JqZWN0KGdldE5vZGVBdFBhdGgpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGdldE5vZGVBdFBhdGgpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0Tm9kZUF0UGF0aCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiZ2V0Tm9kZUF0UGF0aCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIGFkZE5vZGVVbmRlclBhcmVudChfcmVmMTkpe3ZhciB0cmVlRGF0YT1fcmVmMTkudHJlZURhdGEsbmV3Tm9kZT1fcmVmMTkubmV3Tm9kZSxfcmVmMTkkcGFyZW50S2V5PV9yZWYxOS5wYXJlbnRLZXkscGFyZW50S2V5PV9yZWYxOSRwYXJlbnRLZXk9PT12b2lkIDA/bnVsbDpfcmVmMTkkcGFyZW50S2V5LGdldE5vZGVLZXk9X3JlZjE5LmdldE5vZGVLZXksX3JlZjE5JGlnbm9yZUNvbGxhcHNlPV9yZWYxOS5pZ25vcmVDb2xsYXBzZWQsaWdub3JlQ29sbGFwc2VkPV9yZWYxOSRpZ25vcmVDb2xsYXBzZT09PXZvaWQgMD90cnVlOl9yZWYxOSRpZ25vcmVDb2xsYXBzZSxfcmVmMTkkZXhwYW5kUGFyZW50PV9yZWYxOS5leHBhbmRQYXJlbnQsZXhwYW5kUGFyZW50PV9yZWYxOSRleHBhbmRQYXJlbnQ9PT12b2lkIDA/ZmFsc2U6X3JlZjE5JGV4cGFuZFBhcmVudCxfcmVmMTkkYWRkQXNGaXJzdENoaWw9X3JlZjE5LmFkZEFzRmlyc3RDaGlsZCxhZGRBc0ZpcnN0Q2hpbGQ9X3JlZjE5JGFkZEFzRmlyc3RDaGlsPT09dm9pZCAwP2ZhbHNlOl9yZWYxOSRhZGRBc0ZpcnN0Q2hpbDtpZihwYXJlbnRLZXk9PT1udWxsKXtyZXR1cm57dHJlZURhdGE6W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0cmVlRGF0YXx8W10pLFtuZXdOb2RlXSksdHJlZUluZGV4Oih0cmVlRGF0YXx8W10pLmxlbmd0aH07fXZhciBpbnNlcnRlZFRyZWVJbmRleD1udWxsO3ZhciBoYXNCZWVuQWRkZWQ9ZmFsc2U7dmFyIGNoYW5nZWRUcmVlRGF0YT1tYXAoe3RyZWVEYXRhOnRyZWVEYXRhLGdldE5vZGVLZXk6Z2V0Tm9kZUtleSxpZ25vcmVDb2xsYXBzZWQ6aWdub3JlQ29sbGFwc2VkLGNhbGxiYWNrOmZ1bmN0aW9uIGNhbGxiYWNrKF9yZWYyMCl7dmFyIG5vZGU9X3JlZjIwLm5vZGUsdHJlZUluZGV4PV9yZWYyMC50cmVlSW5kZXgscGF0aD1fcmVmMjAucGF0aDt2YXIga2V5PXBhdGg/cGF0aFtwYXRoLmxlbmd0aC0xXTpudWxsOy8vIFJldHVybiBub2RlcyB0aGF0IGFyZSBub3QgdGhlIHBhcmVudCBhcy1pcwppZihoYXNCZWVuQWRkZWR8fGtleSE9PXBhcmVudEtleSl7cmV0dXJuIG5vZGU7fWhhc0JlZW5BZGRlZD10cnVlO3ZhciBwYXJlbnROb2RlPV9vYmplY3RTcHJlYWQoe30sbm9kZSk7aWYoZXhwYW5kUGFyZW50KXtwYXJlbnROb2RlLmV4cGFuZGVkPXRydWU7fS8vIElmIG5vIGNoaWxkcmVuIGV4aXN0IHlldCwganVzdCBhZGQgdGhlIHNpbmdsZSBuZXdOb2RlCmlmKCFwYXJlbnROb2RlLmNoaWxkcmVuKXtpbnNlcnRlZFRyZWVJbmRleD10cmVlSW5kZXgrMTtyZXR1cm4gX29iamVjdFNwcmVhZCh7fSxwYXJlbnROb2RlLHtjaGlsZHJlbjpbbmV3Tm9kZV19KTt9aWYodHlwZW9mIHBhcmVudE5vZGUuY2hpbGRyZW49PT0iZnVuY3Rpb24iKXt0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBhZGQgdG8gY2hpbGRyZW4gZGVmaW5lZCBieSBhIGZ1bmN0aW9uIik7fXZhciBuZXh0VHJlZUluZGV4PXRyZWVJbmRleCsxO2Zvcih2YXIgaT0wO2k8cGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7aSs9MSl7bmV4dFRyZWVJbmRleCs9MStnZXREZXNjZW5kYW50Q291bnQoe25vZGU6cGFyZW50Tm9kZS5jaGlsZHJlbltpXSxpZ25vcmVDb2xsYXBzZWQ6aWdub3JlQ29sbGFwc2VkfSk7fWluc2VydGVkVHJlZUluZGV4PW5leHRUcmVlSW5kZXg7dmFyIGNoaWxkcmVuPWFkZEFzRmlyc3RDaGlsZD9bbmV3Tm9kZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJlbnROb2RlLmNoaWxkcmVuKSk6W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJlbnROb2RlLmNoaWxkcmVuKSxbbmV3Tm9kZV0pO3JldHVybiBfb2JqZWN0U3ByZWFkKHt9LHBhcmVudE5vZGUse2NoaWxkcmVuOmNoaWxkcmVufSk7fX0pO2lmKCFoYXNCZWVuQWRkZWQpe3Rocm93IG5ldyBFcnJvcigiTm8gbm9kZSBmb3VuZCB3aXRoIHRoZSBnaXZlbiBrZXkuIik7fXJldHVybnt0cmVlRGF0YTpjaGFuZ2VkVHJlZURhdGEsdHJlZUluZGV4Omluc2VydGVkVHJlZUluZGV4fTt9aWYodHlwZW9mIGFkZE5vZGVVbmRlclBhcmVudCE9PSd1bmRlZmluZWQnJiZhZGROb2RlVW5kZXJQYXJlbnQmJmFkZE5vZGVVbmRlclBhcmVudD09PU9iamVjdChhZGROb2RlVW5kZXJQYXJlbnQpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGFkZE5vZGVVbmRlclBhcmVudCkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhZGROb2RlVW5kZXJQYXJlbnQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6ImFkZE5vZGVVbmRlclBhcmVudCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZnVuY3Rpb24gYWRkTm9kZUF0RGVwdGhBbmRJbmRleChfcmVmMjEpe3ZhciB0YXJnZXREZXB0aD1fcmVmMjEudGFyZ2V0RGVwdGgsbWluaW11bVRyZWVJbmRleD1fcmVmMjEubWluaW11bVRyZWVJbmRleCxuZXdOb2RlPV9yZWYyMS5uZXdOb2RlLGlnbm9yZUNvbGxhcHNlZD1fcmVmMjEuaWdub3JlQ29sbGFwc2VkLGV4cGFuZFBhcmVudD1fcmVmMjEuZXhwYW5kUGFyZW50LF9yZWYyMSRpc1BzZXVkb1Jvb3Q9X3JlZjIxLmlzUHNldWRvUm9vdCxpc1BzZXVkb1Jvb3Q9X3JlZjIxJGlzUHNldWRvUm9vdD09PXZvaWQgMD9mYWxzZTpfcmVmMjEkaXNQc2V1ZG9Sb290LGlzTGFzdENoaWxkPV9yZWYyMS5pc0xhc3RDaGlsZCxub2RlPV9yZWYyMS5ub2RlLGN1cnJlbnRJbmRleD1fcmVmMjEuY3VycmVudEluZGV4LGN1cnJlbnREZXB0aD1fcmVmMjEuY3VycmVudERlcHRoLGdldE5vZGVLZXk9X3JlZjIxLmdldE5vZGVLZXksX3JlZjIxJHBhdGg9X3JlZjIxLnBhdGgscGF0aD1fcmVmMjEkcGF0aD09PXZvaWQgMD9bXTpfcmVmMjEkcGF0aDt2YXIgc2VsZlBhdGg9ZnVuY3Rpb24gc2VsZlBhdGgobil7cmV0dXJuIGlzUHNldWRvUm9vdD9bXTpbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpLFtnZXROb2RlS2V5KHtub2RlOm4sdHJlZUluZGV4OmN1cnJlbnRJbmRleH0pXSk7fTsvLyBJZiB0aGUgY3VycmVudCBwb3NpdGlvbiBpcyB0aGUgb25seSBwb3NzaWJsZSBwbGFjZSB0byBhZGQsIGFkZCBpdAppZihjdXJyZW50SW5kZXg+PW1pbmltdW1UcmVlSW5kZXgtMXx8aXNMYXN0Q2hpbGQmJiEobm9kZS5jaGlsZHJlbiYmbm9kZS5jaGlsZHJlbi5sZW5ndGgpKXtpZih0eXBlb2Ygbm9kZS5jaGlsZHJlbj09PSJmdW5jdGlvbiIpe3Rocm93IG5ldyBFcnJvcigiQ2Fubm90IGFkZCB0byBjaGlsZHJlbiBkZWZpbmVkIGJ5IGEgZnVuY3Rpb24iKTt9ZWxzZXt2YXIgZXh0cmFOb2RlUHJvcHM9ZXhwYW5kUGFyZW50P3tleHBhbmRlZDp0cnVlfTp7fTt2YXIgX25leHROb2RlPV9vYmplY3RTcHJlYWQoe30sbm9kZSxleHRyYU5vZGVQcm9wcyx7Y2hpbGRyZW46bm9kZS5jaGlsZHJlbj9bbmV3Tm9kZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuKSk6W25ld05vZGVdfSk7cmV0dXJue25vZGU6X25leHROb2RlLG5leHRJbmRleDpjdXJyZW50SW5kZXgrMixpbnNlcnRlZFRyZWVJbmRleDpjdXJyZW50SW5kZXgrMSxwYXJlbnRQYXRoOnNlbGZQYXRoKF9uZXh0Tm9kZSkscGFyZW50Tm9kZTppc1BzZXVkb1Jvb3Q/bnVsbDpfbmV4dE5vZGV9O319Ly8gSWYgdGhpcyBpcyB0aGUgdGFyZ2V0IGRlcHRoIGZvciB0aGUgaW5zZXJ0aW9uLAovLyBpLmUuLCB3aGVyZSB0aGUgbmV3Tm9kZSBjYW4gYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgbm9kZSdzIGNoaWxkcmVuCmlmKGN1cnJlbnREZXB0aD49dGFyZ2V0RGVwdGgtMSl7Ly8gU2tpcCBvdmVyIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gb3IgaGlkZGVuIGNoaWxkcmVuCmlmKCFub2RlLmNoaWxkcmVufHx0eXBlb2Ygbm9kZS5jaGlsZHJlbj09PSJmdW5jdGlvbiJ8fG5vZGUuZXhwYW5kZWQhPT10cnVlJiZpZ25vcmVDb2xsYXBzZWQmJiFpc1BzZXVkb1Jvb3Qpe3JldHVybntub2RlOm5vZGUsbmV4dEluZGV4OmN1cnJlbnRJbmRleCsxfTt9Ly8gU2NhbiBvdmVyIHRoZSBjaGlsZHJlbiB0byBzZWUgaWYgdGhlcmUncyBhIHBsYWNlIGFtb25nIHRoZW0gdGhhdCBmdWxmaWxscwovLyB0aGUgbWluaW11bVRyZWVJbmRleCByZXF1aXJlbWVudAp2YXIgX2NoaWxkSW5kZXg9Y3VycmVudEluZGV4KzE7dmFyIF9pbnNlcnRlZFRyZWVJbmRleD1udWxsO3ZhciBpbnNlcnRJbmRleD1udWxsO2Zvcih2YXIgaT0wO2k8bm9kZS5jaGlsZHJlbi5sZW5ndGg7aSs9MSl7Ly8gSWYgYSB2YWxpZCBsb2NhdGlvbiBpcyBmb3VuZCwgbWFyayBpdCBhcyB0aGUgaW5zZXJ0aW9uIGxvY2F0aW9uIGFuZAovLyBicmVhayBvdXQgb2YgdGhlIGxvb3AKaWYoX2NoaWxkSW5kZXg+PW1pbmltdW1UcmVlSW5kZXgpe19pbnNlcnRlZFRyZWVJbmRleD1fY2hpbGRJbmRleDtpbnNlcnRJbmRleD1pO2JyZWFrO30vLyBJbmNyZW1lbnQgdGhlIGluZGV4IGJ5IHRoZSBjaGlsZCBpdHNlbGYgcGx1cyB0aGUgbnVtYmVyIG9mIGRlc2NlbmRhbnRzIGl0IGhhcwpfY2hpbGRJbmRleCs9MStnZXREZXNjZW5kYW50Q291bnQoe25vZGU6bm9kZS5jaGlsZHJlbltpXSxpZ25vcmVDb2xsYXBzZWQ6aWdub3JlQ29sbGFwc2VkfSk7fS8vIElmIG5vIHZhbGlkIGluZGljZXMgdG8gYWRkIHRoZSBub2RlIHdlcmUgZm91bmQKaWYoaW5zZXJ0SW5kZXg9PT1udWxsKXsvLyBJZiB0aGUgbGFzdCBwb3NpdGlvbiBpbiB0aGlzIG5vZGUncyBjaGlsZHJlbiBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gaW5kZXgKLy8gYW5kIHRoZXJlIGFyZSBtb3JlIGNoaWxkcmVuIG9uIHRoZSBsZXZlbCBvZiB0aGlzIG5vZGUsIHJldHVybiB3aXRob3V0IGluc2VydGlvbgppZihfY2hpbGRJbmRleDxtaW5pbXVtVHJlZUluZGV4JiYhaXNMYXN0Q2hpbGQpe3JldHVybntub2RlOm5vZGUsbmV4dEluZGV4Ol9jaGlsZEluZGV4fTt9Ly8gVXNlIHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBjaGlsZHJlbiBhcnJheSB0byBpbnNlcnQgdGhlIG5ld05vZGUKX2luc2VydGVkVHJlZUluZGV4PV9jaGlsZEluZGV4O2luc2VydEluZGV4PW5vZGUuY2hpbGRyZW4ubGVuZ3RoO30vLyBJbnNlcnQgdGhlIG5ld05vZGUgYXQgdGhlIGluc2VydEluZGV4CnZhciBfbmV4dE5vZGUyPV9vYmplY3RTcHJlYWQoe30sbm9kZSx7Y2hpbGRyZW46W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKDAsaW5zZXJ0SW5kZXgpKSxbbmV3Tm9kZV0sX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoaW5zZXJ0SW5kZXgpKSl9KTsvLyBSZXR1cm4gbm9kZSB3aXRoIHN1Y2Nlc3NmdWwgaW5zZXJ0IHJlc3VsdApyZXR1cm57bm9kZTpfbmV4dE5vZGUyLG5leHRJbmRleDpfY2hpbGRJbmRleCxpbnNlcnRlZFRyZWVJbmRleDpfaW5zZXJ0ZWRUcmVlSW5kZXgscGFyZW50UGF0aDpzZWxmUGF0aChfbmV4dE5vZGUyKSxwYXJlbnROb2RlOmlzUHNldWRvUm9vdD9udWxsOl9uZXh0Tm9kZTJ9O30vLyBTa2lwIG92ZXIgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KaWYoIW5vZGUuY2hpbGRyZW58fHR5cGVvZiBub2RlLmNoaWxkcmVuPT09ImZ1bmN0aW9uInx8bm9kZS5leHBhbmRlZCE9PXRydWUmJmlnbm9yZUNvbGxhcHNlZCYmIWlzUHNldWRvUm9vdCl7cmV0dXJue25vZGU6bm9kZSxuZXh0SW5kZXg6Y3VycmVudEluZGV4KzF9O30vLyBHZXQgYWxsIGRlc2NlbmRhbnRzCnZhciBpbnNlcnRlZFRyZWVJbmRleD1udWxsO3ZhciBwYXRoRnJhZ21lbnQ9bnVsbDt2YXIgcGFyZW50Tm9kZT1udWxsO3ZhciBjaGlsZEluZGV4PWN1cnJlbnRJbmRleCsxO3ZhciBuZXdDaGlsZHJlbj1ub2RlLmNoaWxkcmVuO2lmKHR5cGVvZiBuZXdDaGlsZHJlbiE9PSJmdW5jdGlvbiIpe25ld0NoaWxkcmVuPW5ld0NoaWxkcmVuLm1hcChmdW5jdGlvbihjaGlsZCxpKXtpZihpbnNlcnRlZFRyZWVJbmRleCE9PW51bGwpe3JldHVybiBjaGlsZDt9dmFyIG1hcFJlc3VsdD1hZGROb2RlQXREZXB0aEFuZEluZGV4KHt0YXJnZXREZXB0aDp0YXJnZXREZXB0aCxtaW5pbXVtVHJlZUluZGV4Om1pbmltdW1UcmVlSW5kZXgsbmV3Tm9kZTpuZXdOb2RlLGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsZXhwYW5kUGFyZW50OmV4cGFuZFBhcmVudCxpc0xhc3RDaGlsZDppc0xhc3RDaGlsZCYmaT09PW5ld0NoaWxkcmVuLmxlbmd0aC0xLG5vZGU6Y2hpbGQsY3VycmVudEluZGV4OmNoaWxkSW5kZXgsY3VycmVudERlcHRoOmN1cnJlbnREZXB0aCsxLGdldE5vZGVLZXk6Z2V0Tm9kZUtleSxwYXRoOltdLy8gQ2Fubm90IGRldGVybWluZSB0aGUgcGFyZW50IHBhdGggdW50aWwgdGhlIGNoaWxkcmVuIGhhdmUgYmVlbiBwcm9jZXNzZWQKfSk7aWYoImluc2VydGVkVHJlZUluZGV4ImluIG1hcFJlc3VsdCl7aW5zZXJ0ZWRUcmVlSW5kZXg9bWFwUmVzdWx0Lmluc2VydGVkVHJlZUluZGV4O3BhcmVudE5vZGU9bWFwUmVzdWx0LnBhcmVudE5vZGU7cGF0aEZyYWdtZW50PW1hcFJlc3VsdC5wYXJlbnRQYXRoO31jaGlsZEluZGV4PW1hcFJlc3VsdC5uZXh0SW5kZXg7cmV0dXJuIG1hcFJlc3VsdC5ub2RlO30pO312YXIgbmV4dE5vZGU9X29iamVjdFNwcmVhZCh7fSxub2RlLHtjaGlsZHJlbjpuZXdDaGlsZHJlbn0pO3ZhciByZXN1bHQ9e25vZGU6bmV4dE5vZGUsbmV4dEluZGV4OmNoaWxkSW5kZXh9O2lmKGluc2VydGVkVHJlZUluZGV4IT09bnVsbCl7cmVzdWx0Lmluc2VydGVkVHJlZUluZGV4PWluc2VydGVkVHJlZUluZGV4O3Jlc3VsdC5wYXJlbnRQYXRoPVtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc2VsZlBhdGgobmV4dE5vZGUpKSxfdG9Db25zdW1hYmxlQXJyYXkocGF0aEZyYWdtZW50KSk7cmVzdWx0LnBhcmVudE5vZGU9cGFyZW50Tm9kZTt9cmV0dXJuIHJlc3VsdDt9LyoqDQogKiBJbnNlcnQgYSBub2RlIGludG8gdGhlIHRyZWUgYXQgdGhlIGdpdmVuIGRlcHRoLCBhZnRlciB0aGUgbWluaW11bSBpbmRleA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshbnVtYmVyfSBkZXB0aCAtIFRoZSBkZXB0aCB0byBpbnNlcnQgdGhlIG5vZGUgYXQgKHRoZSBmaXJzdCBsZXZlbCBvZiB0aGUgYXJyYXkgYmVpbmcgZGVwdGggMCkNCiAqIEBwYXJhbSB7IW51bWJlcn0gbWluaW11bVRyZWVJbmRleCAtIFRoZSBsb3dlc3QgcG9zc2libGUgdHJlZUluZGV4IHRvIGluc2VydCB0aGUgbm9kZSBhdA0KICogQHBhcmFtIHshT2JqZWN0fSBuZXdOb2RlIC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGludG8gdGhlIHRyZWUNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICogQHBhcmFtIHtib29sZWFuPX0gZXhwYW5kUGFyZW50IC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGFyZW50IG9mIHRoZSBpbnNlcnRlZCBub2RlDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQNCiAqIEByZXR1cm4ge09iamVjdFtdfSByZXN1bHQudHJlZURhdGEgLSBUaGUgdHJlZSBkYXRhIHdpdGggdGhlIG5vZGUgYWRkZWQNCiAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LnRyZWVJbmRleCAtIFRoZSB0cmVlIGluZGV4IGF0IHdoaWNoIHRoZSBub2RlIHdhcyBpbnNlcnRlZA0KICogQHJldHVybiB7bnVtYmVyW118c3RyaW5nW119IHJlc3VsdC5wYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHRvIHRoZSBub2RlIGxvY2F0aW9uIGFmdGVyIGluc2VydGlvbg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgaW5zZXJ0ZWQgbm9kZQ0KICovZXhwb3J0IGZ1bmN0aW9uIGluc2VydE5vZGUoX3JlZjIyKXt2YXIgdHJlZURhdGE9X3JlZjIyLnRyZWVEYXRhLHRhcmdldERlcHRoPV9yZWYyMi5kZXB0aCxtaW5pbXVtVHJlZUluZGV4PV9yZWYyMi5taW5pbXVtVHJlZUluZGV4LG5ld05vZGU9X3JlZjIyLm5ld05vZGUsX3JlZjIyJGdldE5vZGVLZXk9X3JlZjIyLmdldE5vZGVLZXksZ2V0Tm9kZUtleT1fcmVmMjIkZ2V0Tm9kZUtleT09PXZvaWQgMD9mdW5jdGlvbigpe306X3JlZjIyJGdldE5vZGVLZXksX3JlZjIyJGlnbm9yZUNvbGxhcHNlPV9yZWYyMi5pZ25vcmVDb2xsYXBzZWQsaWdub3JlQ29sbGFwc2VkPV9yZWYyMiRpZ25vcmVDb2xsYXBzZT09PXZvaWQgMD90cnVlOl9yZWYyMiRpZ25vcmVDb2xsYXBzZSxfcmVmMjIkZXhwYW5kUGFyZW50PV9yZWYyMi5leHBhbmRQYXJlbnQsZXhwYW5kUGFyZW50PV9yZWYyMiRleHBhbmRQYXJlbnQ9PT12b2lkIDA/ZmFsc2U6X3JlZjIyJGV4cGFuZFBhcmVudDtpZighdHJlZURhdGEmJnRhcmdldERlcHRoPT09MCl7cmV0dXJue3RyZWVEYXRhOltuZXdOb2RlXSx0cmVlSW5kZXg6MCxwYXRoOltnZXROb2RlS2V5KHtub2RlOm5ld05vZGUsdHJlZUluZGV4OjB9KV0scGFyZW50Tm9kZTpudWxsfTt9dmFyIGluc2VydFJlc3VsdD1hZGROb2RlQXREZXB0aEFuZEluZGV4KHt0YXJnZXREZXB0aDp0YXJnZXREZXB0aCxtaW5pbXVtVHJlZUluZGV4Om1pbmltdW1UcmVlSW5kZXgsbmV3Tm9kZTpuZXdOb2RlLGlnbm9yZUNvbGxhcHNlZDppZ25vcmVDb2xsYXBzZWQsZXhwYW5kUGFyZW50OmV4cGFuZFBhcmVudCxnZXROb2RlS2V5OmdldE5vZGVLZXksaXNQc2V1ZG9Sb290OnRydWUsaXNMYXN0Q2hpbGQ6dHJ1ZSxub2RlOntjaGlsZHJlbjp0cmVlRGF0YX0sY3VycmVudEluZGV4Oi0xLGN1cnJlbnREZXB0aDotMX0pO2lmKCEoImluc2VydGVkVHJlZUluZGV4ImluIGluc2VydFJlc3VsdCkpe3Rocm93IG5ldyBFcnJvcigiTm8gc3VpdGFibGUgcG9zaXRpb24gZm91bmQgdG8gaW5zZXJ0LiIpO312YXIgdHJlZUluZGV4PWluc2VydFJlc3VsdC5pbnNlcnRlZFRyZWVJbmRleDtyZXR1cm57dHJlZURhdGE6aW5zZXJ0UmVzdWx0Lm5vZGUuY2hpbGRyZW4sdHJlZUluZGV4OnRyZWVJbmRleCxwYXRoOltdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5zZXJ0UmVzdWx0LnBhcmVudFBhdGgpLFtnZXROb2RlS2V5KHtub2RlOm5ld05vZGUsdHJlZUluZGV4OnRyZWVJbmRleH0pXSkscGFyZW50Tm9kZTppbnNlcnRSZXN1bHQucGFyZW50Tm9kZX07fS8qKg0KICogR2V0IHRyZWUgZGF0YSBmbGF0dGVuZWQuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHt7DQogKiAgICAgIG5vZGU6IE9iamVjdCwNCiAqICAgICAgcGF0aDogW11zdHJpbmd8W11udW1iZXIsDQogKiAgICAgIGxvd2VyU2libGluZ0NvdW50czogW11udW1iZXINCiAqICB9fVtdIG5vZGVzIC0gVGhlIG5vZGUgYXJyYXkNCiAqL2lmKHR5cGVvZiBpbnNlcnROb2RlIT09J3VuZGVmaW5lZCcmJmluc2VydE5vZGUmJmluc2VydE5vZGU9PT1PYmplY3QoaW5zZXJ0Tm9kZSkmJk9iamVjdC5pc0V4dGVuc2libGUoaW5zZXJ0Tm9kZSkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnNlcnROb2RlLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJpbnNlcnROb2RlIixmaWxlbmFtZToic3JjXFxoZWxwZXIuanMifX0pO31leHBvcnQgZnVuY3Rpb24gZ2V0RmxhdERhdGFGcm9tVHJlZShfcmVmMjMpe3ZhciB0cmVlRGF0YT1fcmVmMjMudHJlZURhdGEsZ2V0Tm9kZUtleT1fcmVmMjMuZ2V0Tm9kZUtleSxfcmVmMjMkaWdub3JlQ29sbGFwc2U9X3JlZjIzLmlnbm9yZUNvbGxhcHNlZCxpZ25vcmVDb2xsYXBzZWQ9X3JlZjIzJGlnbm9yZUNvbGxhcHNlPT09dm9pZCAwP3RydWU6X3JlZjIzJGlnbm9yZUNvbGxhcHNlO2lmKCF0cmVlRGF0YXx8dHJlZURhdGEubGVuZ3RoPDEpe3JldHVybltdO312YXIgZmxhdHRlbmVkPVtdO3dhbGsoe3RyZWVEYXRhOnRyZWVEYXRhLGdldE5vZGVLZXk6Z2V0Tm9kZUtleSxpZ25vcmVDb2xsYXBzZWQ6aWdub3JlQ29sbGFwc2VkLGNhbGxiYWNrOmZ1bmN0aW9uIGNhbGxiYWNrKG5vZGVJbmZvKXtmbGF0dGVuZWQucHVzaChub2RlSW5mbyk7fX0pO3JldHVybiBmbGF0dGVuZWQ7fS8qKg0KICogR2VuZXJhdGUgYSB0cmVlIHN0cnVjdHVyZSBmcm9tIGZsYXQgZGF0YS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gZmxhdERhdGENCiAqIEBwYXJhbSB7IWZ1bmN0aW9uPX0gZ2V0S2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGENCiAqIEBwYXJhbSB7IWZ1bmN0aW9uPX0gZ2V0UGFyZW50S2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBwYXJlbnQga2V5IGZyb20gdGhlIG5vZGVEYXRhDQogKiBAcGFyYW0ge3N0cmluZ3xudW1iZXI9fSByb290S2V5IC0gVGhlIHZhbHVlIHJldHVybmVkIGJ5IGBnZXRQYXJlbnRLZXlgIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHJvb3Qgbm9kZS4NCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvciBleGFtcGxlLCBpZiB5b3VyIG5vZGVzIGhhdmUgaWQgMS05OSwgeW91IG1pZ2h0IHVzZSByb290S2V5ID0gMA0KICoNCiAqIEByZXR1cm4ge09iamVjdFtdfSB0cmVlRGF0YSAtIFRoZSBmbGF0IGRhdGEgcmVwcmVzZW50ZWQgYXMgYSB0cmVlDQogKi9pZih0eXBlb2YgZ2V0RmxhdERhdGFGcm9tVHJlZSE9PSd1bmRlZmluZWQnJiZnZXRGbGF0RGF0YUZyb21UcmVlJiZnZXRGbGF0RGF0YUZyb21UcmVlPT09T2JqZWN0KGdldEZsYXREYXRhRnJvbVRyZWUpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGdldEZsYXREYXRhRnJvbVRyZWUpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0RmxhdERhdGFGcm9tVHJlZSwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiZ2V0RmxhdERhdGFGcm9tVHJlZSIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIGdldFRyZWVGcm9tRmxhdERhdGEoX3JlZjI0KXt2YXIgZmxhdERhdGE9X3JlZjI0LmZsYXREYXRhLF9yZWYyNCRnZXRLZXk9X3JlZjI0LmdldEtleSxnZXRLZXk9X3JlZjI0JGdldEtleT09PXZvaWQgMD9mdW5jdGlvbihub2RlKXtyZXR1cm4gbm9kZS5pZDt9Ol9yZWYyNCRnZXRLZXksX3JlZjI0JGdldFBhcmVudEtleT1fcmVmMjQuZ2V0UGFyZW50S2V5LGdldFBhcmVudEtleT1fcmVmMjQkZ2V0UGFyZW50S2V5PT09dm9pZCAwP2Z1bmN0aW9uKG5vZGUpe3JldHVybiBub2RlLnBhcmVudElkO306X3JlZjI0JGdldFBhcmVudEtleSxfcmVmMjQkcm9vdEtleT1fcmVmMjQucm9vdEtleSxyb290S2V5PV9yZWYyNCRyb290S2V5PT09dm9pZCAwPyIwIjpfcmVmMjQkcm9vdEtleTtpZighZmxhdERhdGEpe3JldHVybltdO312YXIgY2hpbGRyZW5Ub1BhcmVudHM9e307ZmxhdERhdGEuZm9yRWFjaChmdW5jdGlvbihjaGlsZCl7dmFyIHBhcmVudEtleT1nZXRQYXJlbnRLZXkoY2hpbGQpO2lmKHBhcmVudEtleSBpbiBjaGlsZHJlblRvUGFyZW50cyl7Y2hpbGRyZW5Ub1BhcmVudHNbcGFyZW50S2V5XS5wdXNoKGNoaWxkKTt9ZWxzZXtjaGlsZHJlblRvUGFyZW50c1twYXJlbnRLZXldPVtjaGlsZF07fX0pO2lmKCEocm9vdEtleSBpbiBjaGlsZHJlblRvUGFyZW50cykpe3JldHVybltdO312YXIgdHJhdj1mdW5jdGlvbiB0cmF2KHBhcmVudCl7dmFyIHBhcmVudEtleT1nZXRLZXkocGFyZW50KTtpZihwYXJlbnRLZXkgaW4gY2hpbGRyZW5Ub1BhcmVudHMpe3JldHVybiBfb2JqZWN0U3ByZWFkKHt9LHBhcmVudCx7Y2hpbGRyZW46Y2hpbGRyZW5Ub1BhcmVudHNbcGFyZW50S2V5XS5tYXAoZnVuY3Rpb24oY2hpbGQpe3JldHVybiB0cmF2KGNoaWxkKTt9KX0pO31yZXR1cm4gX29iamVjdFNwcmVhZCh7fSxwYXJlbnQpO307cmV0dXJuIGNoaWxkcmVuVG9QYXJlbnRzW3Jvb3RLZXldLm1hcChmdW5jdGlvbihjaGlsZCl7cmV0dXJuIHRyYXYoY2hpbGQpO30pO30vKioNCiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlciBub2RlLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdH0gb2xkZXIgLSBQb3RlbnRpYWwgYW5jZXN0b3Igb2YgeW91bmdlciBub2RlDQogKiBAcGFyYW0geyFPYmplY3R9IHlvdW5nZXIgLSBQb3RlbnRpYWwgZGVzY2VuZGFudCBvZiBvbGRlciBub2RlDQogKg0KICogQHJldHVybiB7Ym9vbGVhbn0NCiAqL2lmKHR5cGVvZiBnZXRUcmVlRnJvbUZsYXREYXRhIT09J3VuZGVmaW5lZCcmJmdldFRyZWVGcm9tRmxhdERhdGEmJmdldFRyZWVGcm9tRmxhdERhdGE9PT1PYmplY3QoZ2V0VHJlZUZyb21GbGF0RGF0YSkmJk9iamVjdC5pc0V4dGVuc2libGUoZ2V0VHJlZUZyb21GbGF0RGF0YSkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRUcmVlRnJvbUZsYXREYXRhLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJnZXRUcmVlRnJvbUZsYXREYXRhIixmaWxlbmFtZToic3JjXFxoZWxwZXIuanMifX0pO31leHBvcnQgZnVuY3Rpb24gaXNEZXNjZW5kYW50KG9sZGVyLHlvdW5nZXIpe3JldHVybiEhb2xkZXIuY2hpbGRyZW4mJnR5cGVvZiBvbGRlci5jaGlsZHJlbiE9PSJmdW5jdGlvbiImJm9sZGVyLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24oY2hpbGQpe3JldHVybiBjaGlsZD09PXlvdW5nZXJ8fGlzRGVzY2VuZGFudChjaGlsZCx5b3VuZ2VyKTt9KTt9LyoqDQogKiBHZXQgdGhlIG1heGltdW0gZGVwdGggb2YgdGhlIGNoaWxkcmVuICh0aGUgZGVwdGggb2YgdGhlIHJvb3Qgbm9kZSBpcyAwKS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3R9IG5vZGUgLSBOb2RlIGluIHRoZSB0cmVlDQogKiBAcGFyYW0gez9udW1iZXJ9IGRlcHRoIC0gVGhlIGN1cnJlbnQgZGVwdGgNCiAqDQogKiBAcmV0dXJuIHtudW1iZXJ9IG1heERlcHRoIC0gVGhlIGRlZXBlc3QgZGVwdGggaW4gdGhlIHRyZWUNCiAqL2lmKHR5cGVvZiBpc0Rlc2NlbmRhbnQhPT0ndW5kZWZpbmVkJyYmaXNEZXNjZW5kYW50JiZpc0Rlc2NlbmRhbnQ9PT1PYmplY3QoaXNEZXNjZW5kYW50KSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShpc0Rlc2NlbmRhbnQpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoaXNEZXNjZW5kYW50LCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJpc0Rlc2NlbmRhbnQiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiBnZXREZXB0aChub2RlKXt2YXIgZGVwdGg9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOjA7aWYoIW5vZGUuY2hpbGRyZW4pe3JldHVybiBkZXB0aDt9aWYodHlwZW9mIG5vZGUuY2hpbGRyZW49PT0iZnVuY3Rpb24iKXtyZXR1cm4gZGVwdGgrMTt9cmV0dXJuIG5vZGUuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uKGRlZXBlc3QsY2hpbGQpe3JldHVybiBNYXRoLm1heChkZWVwZXN0LGdldERlcHRoKGNoaWxkLGRlcHRoKzEpKTt9LGRlcHRoKTt9LyoqDQogKiBGaW5kIG5vZGVzIG1hdGNoaW5nIGEgc2VhcmNoIHF1ZXJ5IGluIHRoZSB0cmVlLA0KICoNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHs/c3RyaW5nfG51bWJlcn0gc2VhcmNoUXVlcnkgLSBGdW5jdGlvbiByZXR1cm5pbmcgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBtYXRjaCBvciBub3QNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBzZWFyY2hNZXRob2QgLSBGdW5jdGlvbiByZXR1cm5pbmcgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBtYXRjaCBvciBub3QNCiAqIEBwYXJhbSB7P251bWJlcn0gc2VhcmNoRm9jdXNPZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSBtYXRjaCB0byBmb2N1cyBvbg0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmcuLCAwIGZvY3VzZXMgb24gdGhlIGZpcnN0IG1hdGNoLCAxIG9uIHRoZSBzZWNvbmQpDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRBbGxNYXRjaFBhdGhzIC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGF0aHMgdG8gYW55IG1hdGNoZWQgbm9kZQ0KICogQHBhcmFtIHtib29sZWFuPX0gZXhwYW5kRm9jdXNNYXRjaFBhdGhzIC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGF0aCB0byB0aGUgZm9jdXNlZCBub2RlDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IG1hdGNoZXMgLSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIG1hdGNoaW5nIGBub2RlYHMsIHRoZWlyIGBwYXRoYHMgYW5kIGB0cmVlSW5kZXhgcw0KICogQHJldHVybiB7T2JqZWN0W119IHRyZWVEYXRhIC0gVGhlIG9yaWdpbmFsIHRyZWUgZGF0YSB3aXRoIGFsbCByZWxldmFudCBub2RlcyBleHBhbmRlZC4NCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGV4cGFuZEFsbE1hdGNoUGF0aHMgYW5kIGV4cGFuZEZvY3VzTWF0Y2hQYXRocyBhcmUgYm90aCBmYWxzZSwNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbmFsIHRyZWUgZGF0YS4NCiAqL2lmKHR5cGVvZiBnZXREZXB0aCE9PSd1bmRlZmluZWQnJiZnZXREZXB0aCYmZ2V0RGVwdGg9PT1PYmplY3QoZ2V0RGVwdGgpJiZPYmplY3QuaXNFeHRlbnNpYmxlKGdldERlcHRoKSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGdldERlcHRoLCdfX2ZpbGVtZXRhJyx7ZW51bWVyYWJsZTp0cnVlLGNvbmZpZ3VyYWJsZTp0cnVlLHZhbHVlOntuYW1lOiJnZXREZXB0aCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIGZpbmQoX3JlZjI1KXt2YXIgZ2V0Tm9kZUtleT1fcmVmMjUuZ2V0Tm9kZUtleSx0cmVlRGF0YT1fcmVmMjUudHJlZURhdGEsc2VhcmNoUXVlcnk9X3JlZjI1LnNlYXJjaFF1ZXJ5LHNlYXJjaE1ldGhvZD1fcmVmMjUuc2VhcmNoTWV0aG9kLHNlYXJjaEZvY3VzT2Zmc2V0PV9yZWYyNS5zZWFyY2hGb2N1c09mZnNldCxfcmVmMjUkZXhwYW5kQWxsTWF0Y2g9X3JlZjI1LmV4cGFuZEFsbE1hdGNoUGF0aHMsZXhwYW5kQWxsTWF0Y2hQYXRocz1fcmVmMjUkZXhwYW5kQWxsTWF0Y2g9PT12b2lkIDA/ZmFsc2U6X3JlZjI1JGV4cGFuZEFsbE1hdGNoLF9yZWYyNSRleHBhbmRGb2N1c01hdD1fcmVmMjUuZXhwYW5kRm9jdXNNYXRjaFBhdGhzLGV4cGFuZEZvY3VzTWF0Y2hQYXRocz1fcmVmMjUkZXhwYW5kRm9jdXNNYXQ9PT12b2lkIDA/dHJ1ZTpfcmVmMjUkZXhwYW5kRm9jdXNNYXQ7dmFyIG1hdGNoQ291bnQ9MDt2YXIgdHJhdj1mdW5jdGlvbiB0cmF2KF9yZWYyNil7dmFyIF9yZWYyNiRpc1BzZXVkb1Jvb3Q9X3JlZjI2LmlzUHNldWRvUm9vdCxpc1BzZXVkb1Jvb3Q9X3JlZjI2JGlzUHNldWRvUm9vdD09PXZvaWQgMD9mYWxzZTpfcmVmMjYkaXNQc2V1ZG9Sb290LG5vZGU9X3JlZjI2Lm5vZGUsY3VycmVudEluZGV4PV9yZWYyNi5jdXJyZW50SW5kZXgsX3JlZjI2JHBhdGg9X3JlZjI2LnBhdGgscGF0aD1fcmVmMjYkcGF0aD09PXZvaWQgMD9bXTpfcmVmMjYkcGF0aDt2YXIgbWF0Y2hlcz1bXTt2YXIgaXNTZWxmTWF0Y2g9ZmFsc2U7dmFyIGhhc0ZvY3VzTWF0Y2g9ZmFsc2U7Ly8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCnZhciBzZWxmUGF0aD1pc1BzZXVkb1Jvb3Q/W106W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXRoKSxbZ2V0Tm9kZUtleSh7bm9kZTpub2RlLHRyZWVJbmRleDpjdXJyZW50SW5kZXh9KV0pO3ZhciBleHRyYUluZm89aXNQc2V1ZG9Sb290P251bGw6e3BhdGg6c2VsZlBhdGgsdHJlZUluZGV4OmN1cnJlbnRJbmRleH07Ly8gTm9kZXMgd2l0aCB3aXRoIGNoaWxkcmVuIHRoYXQgYXJlbid0IGxhenkKdmFyIGhhc0NoaWxkcmVuPW5vZGUuY2hpbGRyZW4mJnR5cGVvZiBub2RlLmNoaWxkcmVuIT09ImZ1bmN0aW9uIiYmbm9kZS5jaGlsZHJlbi5sZW5ndGg+MDsvLyBFeGFtaW5lIHRoZSBjdXJyZW50IG5vZGUgdG8gc2VlIGlmIGl0IGlzIGEgbWF0Y2gKaWYoIWlzUHNldWRvUm9vdCYmc2VhcmNoTWV0aG9kKF9vYmplY3RTcHJlYWQoe30sZXh0cmFJbmZvLHtub2RlOm5vZGUsc2VhcmNoUXVlcnk6c2VhcmNoUXVlcnl9KSkpe2lmKG1hdGNoQ291bnQ9PT1zZWFyY2hGb2N1c09mZnNldCl7aGFzRm9jdXNNYXRjaD10cnVlO30vLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgbm9kZXMsIHNvIHdlIGtub3cgd2hlbiB0aGUgc2VhcmNoRm9jdXNPZmZzZXQKLy8gIGlzIHJlYWNoZWQKbWF0Y2hDb3VudCs9MTsvLyBXZSBjYW5ub3QgYWRkIHRoaXMgbm9kZSB0byB0aGUgbWF0Y2hlcyByaWdodCBhd2F5LCBhcyBpdCBtYXkgYmUgY2hhbmdlZAovLyAgZHVyaW5nIHRoZSBzZWFyY2ggb2YgdGhlIGRlc2NlbmRhbnRzLiBUaGUgZW50aXJlIG5vZGUgaXMgdXNlZCBpbgovLyAgY29tcGFyaXNvbnMgYmV0d2VlbiBub2RlcyBpbnNpZGUgdGhlIGBtYXRjaGVzYCBhbmQgYHRyZWVEYXRhYCByZXN1bHRzCi8vICBvZiB0aGlzIG1ldGhvZCAoYGZpbmRgKQppc1NlbGZNYXRjaD10cnVlO312YXIgY2hpbGRJbmRleD1jdXJyZW50SW5kZXg7dmFyIG5ld05vZGU9X29iamVjdFNwcmVhZCh7fSxub2RlKTtpZihoYXNDaGlsZHJlbil7Ly8gR2V0IGFsbCBkZXNjZW5kYW50cwpuZXdOb2RlLmNoaWxkcmVuPW5ld05vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKXt2YXIgbWFwUmVzdWx0PXRyYXYoe25vZGU6Y2hpbGQsY3VycmVudEluZGV4OmNoaWxkSW5kZXgrMSxwYXRoOnNlbGZQYXRofSk7Ly8gSWdub3JlIGhpZGRlbiBub2RlcyBieSBvbmx5IGFkdmFuY2luZyB0aGUgaW5kZXggY291bnRlciB0byB0aGUgcmV0dXJuZWQgdHJlZUluZGV4Ci8vIGlmIHRoZSBjaGlsZCBpcyBleHBhbmRlZC4KLy8KLy8gVGhlIGNoaWxkIGNvdWxkIGhhdmUgYmVlbiBleHBhbmRlZCBmcm9tIHRoZSBzdGFydCwKLy8gb3IgZXhwYW5kZWQgZHVlIHRvIGEgbWF0Y2hpbmcgbm9kZSBiZWluZyBmb3VuZCBpbiBpdHMgZGVzY2VuZGFudHMKaWYobWFwUmVzdWx0Lm5vZGUuZXhwYW5kZWQpe2NoaWxkSW5kZXg9bWFwUmVzdWx0LnRyZWVJbmRleDt9ZWxzZXtjaGlsZEluZGV4Kz0xO31pZihtYXBSZXN1bHQubWF0Y2hlcy5sZW5ndGg+MHx8bWFwUmVzdWx0Lmhhc0ZvY3VzTWF0Y2gpe21hdGNoZXM9W10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShtYXRjaGVzKSxfdG9Db25zdW1hYmxlQXJyYXkobWFwUmVzdWx0Lm1hdGNoZXMpKTtpZihtYXBSZXN1bHQuaGFzRm9jdXNNYXRjaCl7aGFzRm9jdXNNYXRjaD10cnVlO30vLyBFeHBhbmQgdGhlIGN1cnJlbnQgbm9kZSBpZiBpdCBoYXMgZGVzY2VuZGFudHMgbWF0Y2hpbmcgdGhlIHNlYXJjaAovLyBhbmQgdGhlIHNldHRpbmdzIGFyZSBzZXQgdG8gZG8gc28uCmlmKGV4cGFuZEFsbE1hdGNoUGF0aHMmJm1hcFJlc3VsdC5tYXRjaGVzLmxlbmd0aD4wfHwoZXhwYW5kQWxsTWF0Y2hQYXRoc3x8ZXhwYW5kRm9jdXNNYXRjaFBhdGhzKSYmbWFwUmVzdWx0Lmhhc0ZvY3VzTWF0Y2gpe25ld05vZGUuZXhwYW5kZWQ9dHJ1ZTt9fXJldHVybiBtYXBSZXN1bHQubm9kZTt9KTt9Ly8gQ2Fubm90IGFzc2lnbiBhIHRyZWVJbmRleCB0byBoaWRkZW4gbm9kZXMKaWYoIWlzUHNldWRvUm9vdCYmIW5ld05vZGUuZXhwYW5kZWQpe21hdGNoZXM9bWF0Y2hlcy5tYXAoZnVuY3Rpb24obWF0Y2gpe3JldHVybiBfb2JqZWN0U3ByZWFkKHt9LG1hdGNoLHt0cmVlSW5kZXg6bnVsbH0pO30pO30vLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBtYXRjaGVzIGlmIGl0IGZpdHMgdGhlIHNlYXJjaCBjcml0ZXJpYS4KLy8gVGhpcyBpcyBwZXJmb3JtZWQgYXQgdGhlIGxhc3QgbWludXRlIHNvIG5ld05vZGUgY2FuIGJlIHNlbnQgaW4gaXRzIGZpbmFsIGZvcm0uCmlmKGlzU2VsZk1hdGNoKXttYXRjaGVzPVtfb2JqZWN0U3ByZWFkKHt9LGV4dHJhSW5mbyx7bm9kZTpuZXdOb2RlfSldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobWF0Y2hlcykpO31yZXR1cm57bm9kZTptYXRjaGVzLmxlbmd0aD4wP25ld05vZGU6bm9kZSxtYXRjaGVzOm1hdGNoZXMsaGFzRm9jdXNNYXRjaDpoYXNGb2N1c01hdGNoLHRyZWVJbmRleDpjaGlsZEluZGV4fTt9O3ZhciByZXN1bHQ9dHJhdih7bm9kZTp7Y2hpbGRyZW46dHJlZURhdGF9LGlzUHNldWRvUm9vdDp0cnVlLGN1cnJlbnRJbmRleDotMX0pO3JldHVybnttYXRjaGVzOnJlc3VsdC5tYXRjaGVzLHRyZWVEYXRhOnJlc3VsdC5ub2RlLmNoaWxkcmVufTt9aWYodHlwZW9mIGZpbmQhPT0ndW5kZWZpbmVkJyYmZmluZCYmZmluZD09PU9iamVjdChmaW5kKSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShmaW5kKSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbmQsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6ImZpbmQiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiB0cmVlVG9MaXN0KGFycil7dmFyIHRyZWVMaXN0PWFycnx8W107Ly/mnKvnuqfoioLngrkKdmFyIGxlYWZzPVtdOy8v5qC5CnZhciByb290cz1bXTsvL+aJgOacieiKgueCuQp2YXIgbGlzdD1bXTtmb3IodmFyIGk9MDtpPHRyZWVMaXN0Lmxlbmd0aDtpKyspe3ZhciBkPXRyZWVMaXN0W2ldO2lmKCFkKXtjb250aW51ZTt9dmFyIGNoaWxkcmVucz1kLmNoaWxkcmVufHxbXTtkLl9fZGVwdGg9MDtsaXN0LnB1c2goZCk7cm9vdHMucHVzaChkKTtpZihjaGlsZHJlbnMubGVuZ3RoPjApe2dldENoaWxkcmVuKGQsMCk7fWVsc2V7bGVhZnMucHVzaChkKTt9fWZ1bmN0aW9uIGdldENoaWxkcmVuKGQsZGVwdGgpe3ZhciB0ZW1wQXJyPWQuY2hpbGRyZW58fFtdO2Zvcih2YXIgX2k9MDtfaTx0ZW1wQXJyLmxlbmd0aDtfaSsrKXt2YXIgX2Q9dGVtcEFycltfaV07dmFyIF9jaGlsZHJlbnM9X2QuY2hpbGRyZW58fFtdO19kLl9fZGVwdGg9ZGVwdGgrMTtsaXN0LnB1c2goX2QpO2lmKF9jaGlsZHJlbnMubGVuZ3RoPjApe2dldENoaWxkcmVuKF9kLGRlcHRoKzEpO31lbHNle2xlYWZzLnB1c2goX2QpO319fXJldHVybntsaXN0Omxpc3QsbGVhZnM6bGVhZnMscm9vdHM6cm9vdHN9O31pZih0eXBlb2YgdHJlZVRvTGlzdCE9PSd1bmRlZmluZWQnJiZ0cmVlVG9MaXN0JiZ0cmVlVG9MaXN0PT09T2JqZWN0KHRyZWVUb0xpc3QpJiZPYmplY3QuaXNFeHRlbnNpYmxlKHRyZWVUb0xpc3QpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodHJlZVRvTGlzdCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToidHJlZVRvTGlzdCIsZmlsZW5hbWU6InNyY1xcaGVscGVyLmpzIn19KTt9ZXhwb3J0IGZ1bmN0aW9uIGdldERhdGFMaXN0V2l0aEV4cGFuZGVkKGxpc3Qpe3ZhciBleHBhbmRlZEtleXM9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT11bmRlZmluZWQ/YXJndW1lbnRzWzFdOltdO3ZhciByb3dLZXk9YXJndW1lbnRzLmxlbmd0aD4yP2FyZ3VtZW50c1syXTp1bmRlZmluZWQ7dmFyIGFycj1bXTtmb3IodmFyIGk9MDtpPGxpc3QubGVuZ3RoO2krKyl7dmFyIGQ9bGlzdFtpXTtkLl9fZGVwdGg9MDthcnIucHVzaChkKTtpZihleHBhbmRlZEtleXMuaW5kZXhPZihkW3Jvd0tleV0pPi0xKXtpZihkLmNoaWxkcmVuKXtzZXRDaGlsZHJlbihkLDApO319fWZ1bmN0aW9uIHNldENoaWxkcmVuKGMsZGVwdGgpe3ZhciBjQXJyPWMuY2hpbGRyZW47Zm9yKHZhciBfaTI9MDtfaTI8Y0Fyci5sZW5ndGg7X2kyKyspe3ZhciBfZDI9Y0FycltfaTJdO19kMi5fX2RlcHRoPWRlcHRoKzE7YXJyLnB1c2goX2QyKTtpZihleHBhbmRlZEtleXMuaW5kZXhPZihfZDJbcm93S2V5XSk+LTEpe2lmKF9kMi5jaGlsZHJlbil7c2V0Q2hpbGRyZW4oX2QyLGRlcHRoKzEpO319fX1yZXR1cm4gYXJyO31pZih0eXBlb2YgZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQhPT0ndW5kZWZpbmVkJyYmZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQmJmdldERhdGFMaXN0V2l0aEV4cGFuZGVkPT09T2JqZWN0KGdldERhdGFMaXN0V2l0aEV4cGFuZGVkKSYmT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCwnX19maWxlbWV0YScse2VudW1lcmFibGU6dHJ1ZSxjb25maWd1cmFibGU6dHJ1ZSx2YWx1ZTp7bmFtZToiZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQiLGZpbGVuYW1lOiJzcmNcXGhlbHBlci5qcyJ9fSk7fWV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aCgpe3ZhciB1c2VyQWdlbnQ9bmF2aWdhdG9yLnVzZXJBZ2VudDsvL+WPluW+l+a1j+iniOWZqOeahHVzZXJBZ2VudOWtl+espuS4sgppZih1c2VyQWdlbnQuaW5kZXhPZigiQ2hyb21lIik+LTEpe3JldHVybiA2O312YXIgb1A9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicCIpLHN0eWxlcz17d2lkdGg6IjEwMHB4IixoZWlnaHQ6IjEwMHB4IixvdmVyZmxvd1k6InNjcm9sbCJ9LGksc2Nyb2xsYmFyV2lkdGg7Zm9yKGkgaW4gc3R5bGVzKXtvUC5zdHlsZVtpXT1zdHlsZXNbaV07fWRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob1ApO3Njcm9sbGJhcldpZHRoPW9QLm9mZnNldFdpZHRoLW9QLmNsaWVudFdpZHRoO29QLnJlbW92ZSgpO3JldHVybiBzY3JvbGxiYXJXaWR0aDt9aWYodHlwZW9mIGdldFNjcm9sbGJhcldpZHRoIT09J3VuZGVmaW5lZCcmJmdldFNjcm9sbGJhcldpZHRoJiZnZXRTY3JvbGxiYXJXaWR0aD09PU9iamVjdChnZXRTY3JvbGxiYXJXaWR0aCkmJk9iamVjdC5pc0V4dGVuc2libGUoZ2V0U2Nyb2xsYmFyV2lkdGgpKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0U2Nyb2xsYmFyV2lkdGgsJ19fZmlsZW1ldGEnLHtlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWUsdmFsdWU6e25hbWU6ImdldFNjcm9sbGJhcldpZHRoIixmaWxlbmFtZToic3JjXFxoZWxwZXIuanMifX0pO30="},{"version":3,"sources":["E:\\WebRoot\\tablex\\src\\helper.js"],"names":["getNodeDataAtTreeIndexOrNextIndex","targetIndex","node","currentIndex","getNodeKey","path","lowerSiblingCounts","ignoreCollapsed","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","walkDescendants","callback","parentNode","selfInfo","callbackResult","mapDescendants","nextNode","map","child","mapResult","getVisibleNodeCount","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","index","walk","toggleExpandedForAll","changeNodeAtPath","newNode","RESULT_MISS","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","removeNode","removedNode","removedTreeIndex","nextTreeData","getNodeAtPath","foundNodeInfo","err","addNodeUnderParent","parentKey","expandParent","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","key","addNodeAtDepthAndIndex","targetDepth","minimumTreeIndex","isLastChild","currentDepth","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","depth","insertResult","getFlatDataFromTree","flattened","nodeInfo","push","getTreeFromFlatData","flatData","getKey","id","getParentKey","parentId","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","searchQuery","searchMethod","searchFocusOffset","expandAllMatchPaths","expandFocusMatchPaths","matchCount","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","treeToList","arr","treeList","leafs","roots","list","d","childrens","__depth","getChildren","tempArr","getDataListWithExpanded","expandedKeys","rowKey","indexOf","setChildren","c","cArr","getScrollbarWidth","userAgent","navigator","oP","document","createElement","styles","width","height","overflowY","scrollbarWidth","style","body","appendChild","offsetWidth","clientWidth","remove"],"mappings":"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","sourcesContent":["/**\r\n * Performs a depth-first traversal over all of the node descendants,\r\n * incrementing currentIndex by 1 for each\r\n */\r\nfunction getNodeDataAtTreeIndexOrNextIndex({\r\n  targetIndex,\r\n  node,\r\n  currentIndex,\r\n  getNodeKey,\r\n  path = [],\r\n  lowerSiblingCounts = [],\r\n  ignoreCollapsed = true,\r\n  isPseudoRoot = false\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = !isPseudoRoot\r\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\r\n    : [];\r\n\r\n  // Return target node when found\r\n  if (currentIndex === targetIndex) {\r\n    return {\r\n      node,\r\n      lowerSiblingCounts,\r\n      path: selfPath\r\n    };\r\n  }\r\n\r\n  // Add one and continue for nodes with no children or hidden children\r\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\r\n    return { nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Iterate over each child and their descendants and return the\r\n  // target node if childIndex reaches the targetIndex\r\n  let childIndex = currentIndex + 1;\r\n  const childCount = node.children.length;\r\n  for (let i = 0; i < childCount; i += 1) {\r\n    const result = getNodeDataAtTreeIndexOrNextIndex({\r\n      ignoreCollapsed,\r\n      getNodeKey,\r\n      targetIndex,\r\n      node: node.children[i],\r\n      currentIndex: childIndex,\r\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n      path: selfPath\r\n    });\r\n\r\n    if (result.node) {\r\n      return result;\r\n    }\r\n\r\n    childIndex = result.nextIndex;\r\n  }\r\n\r\n  // If the target node is not found, return the farthest traversed index\r\n  return { nextIndex: childIndex };\r\n}\r\n\r\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\r\n  return (\r\n    getNodeDataAtTreeIndexOrNextIndex({\r\n      getNodeKey: () => {},\r\n      ignoreCollapsed,\r\n      node,\r\n      currentIndex: 0,\r\n      targetIndex: -1\r\n    }).nextIndex - 1\r\n  );\r\n}\r\n\r\n/**\r\n * Walk all descendants of the given node, depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction walkDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n  const selfInfo = isPseudoRoot\r\n    ? null\r\n    : {\r\n        node,\r\n        parentNode,\r\n        path: selfPath,\r\n        lowerSiblingCounts,\r\n        treeIndex: currentIndex\r\n      };\r\n\r\n  if (!isPseudoRoot) {\r\n    const callbackResult = callback(selfInfo);\r\n\r\n    // Cut walk short if the callback returned false\r\n    if (callbackResult === false) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return currentIndex;\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = node.children.length;\r\n  if (typeof node.children !== \"function\") {\r\n    for (let i = 0; i < childCount; i += 1) {\r\n      childIndex = walkDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: node.children[i],\r\n        parentNode: isPseudoRoot ? null : node,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n\r\n      // Cut walk short if the callback returned false\r\n      if (childIndex === false) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return childIndex;\r\n}\r\n\r\n/**\r\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction mapDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  const nextNode = { ...node };\r\n\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\r\n  const selfInfo = {\r\n    node: nextNode,\r\n    parentNode,\r\n    path: selfPath,\r\n    lowerSiblingCounts,\r\n    treeIndex: currentIndex\r\n  };\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !nextNode.children ||\r\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return {\r\n      treeIndex: currentIndex,\r\n      node: callback(selfInfo)\r\n    };\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = nextNode.children.length;\r\n  if (typeof nextNode.children !== \"function\") {\r\n    nextNode.children = nextNode.children.map((child, i) => {\r\n      const mapResult = mapDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: child,\r\n        parentNode: isPseudoRoot ? null : nextNode,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n      childIndex = mapResult.treeIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  return {\r\n    node: callback(selfInfo),\r\n    treeIndex: childIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Count all the visible (expanded) descendants in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n *\r\n * @return {number} count\r\n */\r\nexport function getVisibleNodeCount({ treeData }) {\r\n  const traverse = node => {\r\n    if (\r\n      !node.children ||\r\n      node.expanded !== true ||\r\n      typeof node.children === \"function\"\r\n    ) {\r\n      return 1;\r\n    }\r\n\r\n    return (\r\n      1 +\r\n      node.children.reduce(\r\n        (total, currentNode) => total + traverse(currentNode),\r\n        0\r\n      )\r\n    );\r\n  };\r\n\r\n  return treeData.reduce(\r\n    (total, currentNode) => total + traverse(currentNode),\r\n    0\r\n  );\r\n}\r\n\r\n/**\r\n * Get the <targetIndex>th visible node in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} targetIndex - The index of the node to search for\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }|null} node - The node at targetIndex, or null if not found\r\n */\r\nexport function getVisibleNodeInfoAtIndex({\r\n  treeData,\r\n  index: targetIndex,\r\n  getNodeKey\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return null;\r\n  }\r\n\r\n  // Call the tree traversal with a pseudo-root node\r\n  const result = getNodeDataAtTreeIndexOrNextIndex({\r\n    targetIndex,\r\n    getNodeKey,\r\n    node: {\r\n      children: treeData,\r\n      expanded: true\r\n    },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: [],\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result.node) {\r\n    return result;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Walk descendants depth-first and call a callback on each\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return void\r\n */\r\nexport function walk({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return;\r\n  }\r\n\r\n  walkDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  });\r\n}\r\n\r\n/**\r\n * Perform a depth-first transversal of the descendants and\r\n *  make a change to every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function map({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  return mapDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  }).node.children;\r\n}\r\n\r\n/**\r\n * Expand or close every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?boolean} expanded - Whether the node is expanded or not\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\r\n  return map({\r\n    treeData,\r\n    callback: ({ node }) => ({ ...node, expanded }),\r\n    getNodeKey: ({ treeIndex }) => treeIndex,\r\n    ignoreCollapsed: false\r\n  });\r\n}\r\n\r\n/**\r\n * Replaces node at path with object, or callback-defined object\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function changeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  newNode,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  const RESULT_MISS = \"RESULT_MISS\";\r\n  const traverse = ({\r\n    isPseudoRoot = false,\r\n    node,\r\n    currentTreeIndex,\r\n    pathIndex\r\n  }) => {\r\n    if (\r\n      !isPseudoRoot &&\r\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\r\n    ) {\r\n      return RESULT_MISS;\r\n    }\r\n\r\n    if (pathIndex >= path.length - 1) {\r\n      // If this is the final location in the path, return its changed form\r\n      return typeof newNode === \"function\"\r\n        ? newNode({ node, treeIndex: currentTreeIndex })\r\n        : newNode;\r\n    }\r\n    if (!node.children) {\r\n      // If this node is part of the path, but has no children, return the unchanged node\r\n      throw new Error(\"Path referenced children of node with no children.\");\r\n    }\r\n\r\n    let nextTreeIndex = currentTreeIndex + 1;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      const result = traverse({\r\n        node: node.children[i],\r\n        currentTreeIndex: nextTreeIndex,\r\n        pathIndex: pathIndex + 1\r\n      });\r\n\r\n      // If the result went down the correct path\r\n      if (result !== RESULT_MISS) {\r\n        if (result) {\r\n          // If the result was truthy (in this case, an object),\r\n          //  pass it to the next level of recursion up\r\n          return {\r\n            ...node,\r\n            children: [\r\n              ...node.children.slice(0, i),\r\n              result,\r\n              ...node.children.slice(i + 1)\r\n            ]\r\n          };\r\n        }\r\n        // If the result was falsy (returned from the newNode function), then\r\n        //  delete the node from the array.\r\n        return {\r\n          ...node,\r\n          children: [\r\n            ...node.children.slice(0, i),\r\n            ...node.children.slice(i + 1)\r\n          ]\r\n        };\r\n      }\r\n\r\n      nextTreeIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    return RESULT_MISS;\r\n  };\r\n\r\n  // Use a pseudo-root node in the beginning traversal\r\n  const result = traverse({\r\n    node: { children: treeData },\r\n    currentTreeIndex: -1,\r\n    pathIndex: -1,\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result === RESULT_MISS) {\r\n    throw new Error(\"No node found at the given path.\");\r\n  }\r\n\r\n  return result.children;\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The tree data with the node removed\r\n */\r\nexport function removeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  return changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: null // Delete the node\r\n  });\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node removed\r\n * @return {Object} result.node - The node that was removed\r\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\r\n */\r\nexport function removeNode({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let removedNode = null;\r\n  let removedTreeIndex = null;\r\n  const nextTreeData = changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: ({ node, treeIndex }) => {\r\n      // Store the target node and delete it from the tree\r\n      removedNode = node;\r\n      removedTreeIndex = treeIndex;\r\n\r\n      return null;\r\n    }\r\n  });\r\n\r\n  return {\r\n    treeData: nextTreeData,\r\n    node: removedNode,\r\n    treeIndex: removedTreeIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the node at the specified path\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n */\r\nexport function getNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let foundNodeInfo = null;\r\n\r\n  try {\r\n    changeNodeAtPath({\r\n      treeData,\r\n      path,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      newNode: ({ node, treeIndex }) => {\r\n        foundNodeInfo = { node, treeIndex };\r\n        return node;\r\n      }\r\n    });\r\n  } catch (err) {\r\n    // Ignore the error -- the null return will be explanation enough\r\n  }\r\n\r\n  return foundNodeInfo;\r\n}\r\n\r\n/**\r\n * Adds the node to the specified parent and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {!Object} newNode - The node to insert\r\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The updated tree data\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n */\r\nexport function addNodeUnderParent({\r\n  treeData,\r\n  newNode,\r\n  parentKey = null,\r\n  getNodeKey,\r\n  ignoreCollapsed = true,\r\n  expandParent = false,\r\n  addAsFirstChild = false\r\n}) {\r\n  if (parentKey === null) {\r\n    return {\r\n      treeData: [...(treeData || []), newNode],\r\n      treeIndex: (treeData || []).length\r\n    };\r\n  }\r\n\r\n  let insertedTreeIndex = null;\r\n  let hasBeenAdded = false;\r\n  const changedTreeData = map({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: ({ node, treeIndex, path }) => {\r\n      const key = path ? path[path.length - 1] : null;\r\n      // Return nodes that are not the parent as-is\r\n      if (hasBeenAdded || key !== parentKey) {\r\n        return node;\r\n      }\r\n      hasBeenAdded = true;\r\n\r\n      const parentNode = {\r\n        ...node\r\n      };\r\n\r\n      if (expandParent) {\r\n        parentNode.expanded = true;\r\n      }\r\n\r\n      // If no children exist yet, just add the single newNode\r\n      if (!parentNode.children) {\r\n        insertedTreeIndex = treeIndex + 1;\r\n        return {\r\n          ...parentNode,\r\n          children: [newNode]\r\n        };\r\n      }\r\n\r\n      if (typeof parentNode.children === \"function\") {\r\n        throw new Error(\"Cannot add to children defined by a function\");\r\n      }\r\n\r\n      let nextTreeIndex = treeIndex + 1;\r\n      for (let i = 0; i < parentNode.children.length; i += 1) {\r\n        nextTreeIndex +=\r\n          1 +\r\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\r\n      }\r\n\r\n      insertedTreeIndex = nextTreeIndex;\r\n\r\n      const children = addAsFirstChild\r\n        ? [newNode, ...parentNode.children]\r\n        : [...parentNode.children, newNode];\r\n\r\n      return {\r\n        ...parentNode,\r\n        children\r\n      };\r\n    }\r\n  });\r\n\r\n  if (!hasBeenAdded) {\r\n    throw new Error(\"No node found with the given key.\");\r\n  }\r\n\r\n  return {\r\n    treeData: changedTreeData,\r\n    treeIndex: insertedTreeIndex\r\n  };\r\n}\r\n\r\nfunction addNodeAtDepthAndIndex({\r\n  targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  ignoreCollapsed,\r\n  expandParent,\r\n  isPseudoRoot = false,\r\n  isLastChild,\r\n  node,\r\n  currentIndex,\r\n  currentDepth,\r\n  getNodeKey,\r\n  path = []\r\n}) {\r\n  const selfPath = n =>\r\n    isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\r\n\r\n  // If the current position is the only possible place to add, add it\r\n  if (\r\n    currentIndex >= minimumTreeIndex - 1 ||\r\n    (isLastChild && !(node.children && node.children.length))\r\n  ) {\r\n    if (typeof node.children === \"function\") {\r\n      throw new Error(\"Cannot add to children defined by a function\");\r\n    } else {\r\n      const extraNodeProps = expandParent ? { expanded: true } : {};\r\n      const nextNode = {\r\n        ...node,\r\n\r\n        ...extraNodeProps,\r\n        children: node.children ? [newNode, ...node.children] : [newNode]\r\n      };\r\n\r\n      return {\r\n        node: nextNode,\r\n        nextIndex: currentIndex + 2,\r\n        insertedTreeIndex: currentIndex + 1,\r\n        parentPath: selfPath(nextNode),\r\n        parentNode: isPseudoRoot ? null : nextNode\r\n      };\r\n    }\r\n  }\r\n\r\n  // If this is the target depth for the insertion,\r\n  // i.e., where the newNode can be added to the current node's children\r\n  if (currentDepth >= targetDepth - 1) {\r\n    // Skip over nodes with no children or hidden children\r\n    if (\r\n      !node.children ||\r\n      typeof node.children === \"function\" ||\r\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return { node, nextIndex: currentIndex + 1 };\r\n    }\r\n\r\n    // Scan over the children to see if there's a place among them that fulfills\r\n    // the minimumTreeIndex requirement\r\n    let childIndex = currentIndex + 1;\r\n    let insertedTreeIndex = null;\r\n    let insertIndex = null;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      // If a valid location is found, mark it as the insertion location and\r\n      // break out of the loop\r\n      if (childIndex >= minimumTreeIndex) {\r\n        insertedTreeIndex = childIndex;\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n\r\n      // Increment the index by the child itself plus the number of descendants it has\r\n      childIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    // If no valid indices to add the node were found\r\n    if (insertIndex === null) {\r\n      // If the last position in this node's children is less than the minimum index\r\n      // and there are more children on the level of this node, return without insertion\r\n      if (childIndex < minimumTreeIndex && !isLastChild) {\r\n        return { node, nextIndex: childIndex };\r\n      }\r\n\r\n      // Use the last position in the children array to insert the newNode\r\n      insertedTreeIndex = childIndex;\r\n      insertIndex = node.children.length;\r\n    }\r\n\r\n    // Insert the newNode at the insertIndex\r\n    const nextNode = {\r\n      ...node,\r\n      children: [\r\n        ...node.children.slice(0, insertIndex),\r\n        newNode,\r\n        ...node.children.slice(insertIndex)\r\n      ]\r\n    };\r\n\r\n    // Return node with successful insert result\r\n    return {\r\n      node: nextNode,\r\n      nextIndex: childIndex,\r\n      insertedTreeIndex,\r\n      parentPath: selfPath(nextNode),\r\n      parentNode: isPseudoRoot ? null : nextNode\r\n    };\r\n  }\r\n\r\n  // Skip over nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    typeof node.children === \"function\" ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return { node, nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Get all descendants\r\n  let insertedTreeIndex = null;\r\n  let pathFragment = null;\r\n  let parentNode = null;\r\n  let childIndex = currentIndex + 1;\r\n  let newChildren = node.children;\r\n  if (typeof newChildren !== \"function\") {\r\n    newChildren = newChildren.map((child, i) => {\r\n      if (insertedTreeIndex !== null) {\r\n        return child;\r\n      }\r\n\r\n      const mapResult = addNodeAtDepthAndIndex({\r\n        targetDepth,\r\n        minimumTreeIndex,\r\n        newNode,\r\n        ignoreCollapsed,\r\n        expandParent,\r\n        isLastChild: isLastChild && i === newChildren.length - 1,\r\n        node: child,\r\n        currentIndex: childIndex,\r\n        currentDepth: currentDepth + 1,\r\n        getNodeKey,\r\n        path: [] // Cannot determine the parent path until the children have been processed\r\n      });\r\n\r\n      if (\"insertedTreeIndex\" in mapResult) {\r\n        ({\r\n          insertedTreeIndex,\r\n          parentNode,\r\n          parentPath: pathFragment\r\n        } = mapResult);\r\n      }\r\n\r\n      childIndex = mapResult.nextIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  const nextNode = { ...node, children: newChildren };\r\n  const result = {\r\n    node: nextNode,\r\n    nextIndex: childIndex\r\n  };\r\n\r\n  if (insertedTreeIndex !== null) {\r\n    result.insertedTreeIndex = insertedTreeIndex;\r\n    result.parentPath = [...selfPath(nextNode), ...pathFragment];\r\n    result.parentNode = parentNode;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Insert a node into the tree at the given depth, after the minimum index\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n * @param {!Object} newNode - The node to insert into the tree\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node added\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n * @return {Object} result.parentNode - The parent node of the inserted node\r\n */\r\nexport function insertNode({\r\n  treeData,\r\n  depth: targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  getNodeKey = () => {},\r\n  ignoreCollapsed = true,\r\n  expandParent = false\r\n}) {\r\n  if (!treeData && targetDepth === 0) {\r\n    return {\r\n      treeData: [newNode],\r\n      treeIndex: 0,\r\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\r\n      parentNode: null\r\n    };\r\n  }\r\n\r\n  const insertResult = addNodeAtDepthAndIndex({\r\n    targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    ignoreCollapsed,\r\n    expandParent,\r\n    getNodeKey,\r\n    isPseudoRoot: true,\r\n    isLastChild: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    currentDepth: -1\r\n  });\r\n\r\n  if (!(\"insertedTreeIndex\" in insertResult)) {\r\n    throw new Error(\"No suitable position found to insert.\");\r\n  }\r\n\r\n  const treeIndex = insertResult.insertedTreeIndex;\r\n  return {\r\n    treeData: insertResult.node.children,\r\n    treeIndex,\r\n    path: [\r\n      ...insertResult.parentPath,\r\n      getNodeKey({ node: newNode, treeIndex })\r\n    ],\r\n    parentNode: insertResult.parentNode\r\n  };\r\n}\r\n\r\n/**\r\n * Get tree data flattened.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }}[] nodes - The node array\r\n */\r\nexport function getFlatDataFromTree({\r\n  treeData,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  const flattened = [];\r\n  walk({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: nodeInfo => {\r\n      flattened.push(nodeInfo);\r\n    }\r\n  });\r\n\r\n  return flattened;\r\n}\r\n\r\n/**\r\n * Generate a tree structure from flat data.\r\n *\r\n * @param {!Object[]} flatData\r\n * @param {!function=} getKey - Function to get the key from the nodeData\r\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n *\r\n * @return {Object[]} treeData - The flat data represented as a tree\r\n */\r\nexport function getTreeFromFlatData({\r\n  flatData,\r\n  getKey = node => node.id,\r\n  getParentKey = node => node.parentId,\r\n  rootKey = \"0\"\r\n}) {\r\n  if (!flatData) {\r\n    return [];\r\n  }\r\n\r\n  const childrenToParents = {};\r\n  flatData.forEach(child => {\r\n    const parentKey = getParentKey(child);\r\n\r\n    if (parentKey in childrenToParents) {\r\n      childrenToParents[parentKey].push(child);\r\n    } else {\r\n      childrenToParents[parentKey] = [child];\r\n    }\r\n  });\r\n\r\n  if (!(rootKey in childrenToParents)) {\r\n    return [];\r\n  }\r\n\r\n  const trav = parent => {\r\n    const parentKey = getKey(parent);\r\n    if (parentKey in childrenToParents) {\r\n      return {\r\n        ...parent,\r\n        children: childrenToParents[parentKey].map(child => trav(child))\r\n      };\r\n    }\r\n\r\n    return { ...parent };\r\n  };\r\n\r\n  return childrenToParents[rootKey].map(child => trav(child));\r\n}\r\n\r\n/**\r\n * Check if a node is a descendant of another node.\r\n *\r\n * @param {!Object} older - Potential ancestor of younger node\r\n * @param {!Object} younger - Potential descendant of older node\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isDescendant(older, younger) {\r\n  return (\r\n    !!older.children &&\r\n    typeof older.children !== \"function\" &&\r\n    older.children.some(\r\n      child => child === younger || isDescendant(child, younger)\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Get the maximum depth of the children (the depth of the root node is 0).\r\n *\r\n * @param {!Object} node - Node in the tree\r\n * @param {?number} depth - The current depth\r\n *\r\n * @return {number} maxDepth - The deepest depth in the tree\r\n */\r\nexport function getDepth(node, depth = 0) {\r\n  if (!node.children) {\r\n    return depth;\r\n  }\r\n\r\n  if (typeof node.children === \"function\") {\r\n    return depth + 1;\r\n  }\r\n\r\n  return node.children.reduce(\r\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\r\n    depth\r\n  );\r\n}\r\n\r\n/**\r\n * Find nodes matching a search query in the tree,\r\n *\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n *\r\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n *                               it will be the same as the original tree data.\r\n */\r\nexport function find({\r\n  getNodeKey,\r\n  treeData,\r\n  searchQuery,\r\n  searchMethod,\r\n  searchFocusOffset,\r\n  expandAllMatchPaths = false,\r\n  expandFocusMatchPaths = true\r\n}) {\r\n  let matchCount = 0;\r\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\r\n    let matches = [];\r\n    let isSelfMatch = false;\r\n    let hasFocusMatch = false;\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n    const extraInfo = isPseudoRoot\r\n      ? null\r\n      : {\r\n          path: selfPath,\r\n          treeIndex: currentIndex\r\n        };\r\n\r\n    // Nodes with with children that aren't lazy\r\n    const hasChildren =\r\n      node.children &&\r\n      typeof node.children !== \"function\" &&\r\n      node.children.length > 0;\r\n\r\n    // Examine the current node to see if it is a match\r\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\r\n      if (matchCount === searchFocusOffset) {\r\n        hasFocusMatch = true;\r\n      }\r\n\r\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\r\n      //  is reached\r\n      matchCount += 1;\r\n\r\n      // We cannot add this node to the matches right away, as it may be changed\r\n      //  during the search of the descendants. The entire node is used in\r\n      //  comparisons between nodes inside the `matches` and `treeData` results\r\n      //  of this method (`find`)\r\n      isSelfMatch = true;\r\n    }\r\n\r\n    let childIndex = currentIndex;\r\n    const newNode = { ...node };\r\n    if (hasChildren) {\r\n      // Get all descendants\r\n      newNode.children = newNode.children.map(child => {\r\n        const mapResult = trav({\r\n          node: child,\r\n          currentIndex: childIndex + 1,\r\n          path: selfPath\r\n        });\r\n\r\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\r\n        // if the child is expanded.\r\n        //\r\n        // The child could have been expanded from the start,\r\n        // or expanded due to a matching node being found in its descendants\r\n        if (mapResult.node.expanded) {\r\n          childIndex = mapResult.treeIndex;\r\n        } else {\r\n          childIndex += 1;\r\n        }\r\n\r\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\r\n          matches = [...matches, ...mapResult.matches];\r\n          if (mapResult.hasFocusMatch) {\r\n            hasFocusMatch = true;\r\n          }\r\n\r\n          // Expand the current node if it has descendants matching the search\r\n          // and the settings are set to do so.\r\n          if (\r\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\r\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\r\n              mapResult.hasFocusMatch)\r\n          ) {\r\n            newNode.expanded = true;\r\n          }\r\n        }\r\n\r\n        return mapResult.node;\r\n      });\r\n    }\r\n\r\n    // Cannot assign a treeIndex to hidden nodes\r\n    if (!isPseudoRoot && !newNode.expanded) {\r\n      matches = matches.map(match => ({\r\n        ...match,\r\n        treeIndex: null\r\n      }));\r\n    }\r\n\r\n    // Add this node to the matches if it fits the search criteria.\r\n    // This is performed at the last minute so newNode can be sent in its final form.\r\n    if (isSelfMatch) {\r\n      matches = [{ ...extraInfo, node: newNode }, ...matches];\r\n    }\r\n\r\n    return {\r\n      node: matches.length > 0 ? newNode : node,\r\n      matches,\r\n      hasFocusMatch,\r\n      treeIndex: childIndex\r\n    };\r\n  };\r\n\r\n  const result = trav({\r\n    node: { children: treeData },\r\n    isPseudoRoot: true,\r\n    currentIndex: -1\r\n  });\r\n\r\n  return {\r\n    matches: result.matches,\r\n    treeData: result.node.children\r\n  };\r\n}\r\n\r\nexport function treeToList(arr) {\r\n  let treeList = arr || [];\r\n\r\n  //\r\n  let leafs = [];\r\n\r\n  //\r\n  let roots = [];\r\n\r\n  //\r\n  let list = [];\r\n\r\n  for (let i = 0; i < treeList.length; i++) {\r\n    const d = treeList[i];\r\n\r\n    if (!d) {\r\n      continue;\r\n    }\r\n\r\n    const childrens = d.children || [];\r\n\r\n    d.__depth = 0;\r\n\r\n    list.push(d);\r\n    roots.push(d);\r\n\r\n    if (childrens.length > 0) {\r\n      getChildren(d, 0);\r\n    } else {\r\n      leafs.push(d);\r\n    }\r\n  }\r\n\r\n  function getChildren(d, depth) {\r\n    const tempArr = d.children || [];\r\n\r\n    for (let i = 0; i < tempArr.length; i++) {\r\n      const d = tempArr[i];\r\n      const childrens = d.children || [];\r\n\r\n      d.__depth = depth + 1;\r\n\r\n      list.push(d);\r\n\r\n      if (childrens.length > 0) {\r\n        getChildren(d, depth + 1);\r\n      } else {\r\n        leafs.push(d);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { list, leafs, roots };\r\n}\r\n\r\nexport function getDataListWithExpanded(list, expandedKeys = [], rowKey) {\r\n  let arr = [];\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    let d = list[i];\r\n\r\n    d.__depth = 0;\r\n\r\n    arr.push(d);\r\n\r\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n      if (d.children) {\r\n        setChildren(d, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  function setChildren(c, depth) {\r\n    let cArr = c.children;\r\n    for (let i = 0; i < cArr.length; i++) {\r\n      let d = cArr[i];\r\n      d.__depth = depth + 1;\r\n      arr.push(d);\r\n\r\n      if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n        if (d.children) {\r\n          setChildren(d, depth + 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\nexport function getScrollbarWidth() {\r\n  var userAgent = navigator.userAgent; //userAgent\r\n\r\n  if (userAgent.indexOf(\"Chrome\") > -1) {\r\n    return 6;\r\n  }\r\n\r\n  var oP = document.createElement(\"p\"),\r\n    styles = {\r\n      width: \"100px\",\r\n      height: \"100px\",\r\n      overflowY: \"scroll\"\r\n    },\r\n    i,\r\n    scrollbarWidth;\r\n\r\n  for (i in styles) {\r\n    oP.style[i] = styles[i];\r\n  }\r\n  document.body.appendChild(oP);\r\n  scrollbarWidth = oP.offsetWidth - oP.clientWidth;\r\n  oP.remove();\r\n\r\n  return scrollbarWidth;\r\n}\r\n"]}]}