{"remainingRequest":"E:\\WebRoot\\tablex\\node_modules\\thread-loader\\dist\\cjs.js??ref--5-1!E:\\WebRoot\\tablex\\node_modules\\babel-loader\\lib\\index.js??ref--5-2!E:\\WebRoot\\tablex\\node_modules\\source-map-loader\\index.js!E:\\WebRoot\\tablex\\src\\helper.js","dependencies":[{"path":"E:\\WebRoot\\tablex\\src\\helper.js","mtime":1559204542871},{"path":"E:\\WebRoot\\tablex\\node_modules\\umi-library\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1559204841349},{"path":"E:\\WebRoot\\tablex\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1554780430526},{"path":"E:\\WebRoot\\tablex\\node_modules\\babel-loader\\lib\\index.js","mtime":1551944504366},{"path":"E:\\WebRoot\\tablex\\node_modules\\source-map-loader\\index.js","mtime":1551944506105}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiRTpcXFdlYlJvb3RcXHRhYmxleFxcbm9kZV9tb2R1bGVzXFx1bWktbGlicmFyeVxcbm9kZV9tb2R1bGVzXFxkb2N6XFxub2RlX21vZHVsZXNcXGJhYmVsLXByZXNldC1yZWFjdC1hcHBcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFNwcmVhZCI7CmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAiRTpcXFdlYlJvb3RcXHRhYmxleFxcbm9kZV9tb2R1bGVzXFx1bWktbGlicmFyeVxcbm9kZV9tb2R1bGVzXFxkb2N6XFxub2RlX21vZHVsZXNcXGJhYmVsLXByZXNldC1yZWFjdC1hcHBcXG5vZGVfbW9kdWxlc1xcQGJhYmVsXFxydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5IjsKCihmdW5jdGlvbiAoKSB7CiAgdmFyIGVudGVyTW9kdWxlID0gKHR5cGVvZiByZWFjdEhvdExvYWRlckdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyByZWFjdEhvdExvYWRlckdsb2JhbCA6IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKSkuZW50ZXJNb2R1bGU7CiAgZW50ZXJNb2R1bGUgJiYgZW50ZXJNb2R1bGUobW9kdWxlKTsKfSkoKTsKCi8qKg0KICogUGVyZm9ybXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb3ZlciBhbGwgb2YgdGhlIG5vZGUgZGVzY2VuZGFudHMsDQogKiBpbmNyZW1lbnRpbmcgY3VycmVudEluZGV4IGJ5IDEgZm9yIGVhY2gNCiAqLwpmdW5jdGlvbiBnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoX3JlZikgewogIHZhciB0YXJnZXRJbmRleCA9IF9yZWYudGFyZ2V0SW5kZXgsCiAgICAgIG5vZGUgPSBfcmVmLm5vZGUsCiAgICAgIGN1cnJlbnRJbmRleCA9IF9yZWYuY3VycmVudEluZGV4LAogICAgICBnZXROb2RlS2V5ID0gX3JlZi5nZXROb2RlS2V5LAogICAgICBfcmVmJHBhdGggPSBfcmVmLnBhdGgsCiAgICAgIHBhdGggPSBfcmVmJHBhdGggPT09IHZvaWQgMCA/IFtdIDogX3JlZiRwYXRoLAogICAgICBfcmVmJGxvd2VyU2libGluZ0NvdW4gPSBfcmVmLmxvd2VyU2libGluZ0NvdW50cywKICAgICAgbG93ZXJTaWJsaW5nQ291bnRzID0gX3JlZiRsb3dlclNpYmxpbmdDb3VuID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkbG93ZXJTaWJsaW5nQ291biwKICAgICAgX3JlZiRpZ25vcmVDb2xsYXBzZWQgPSBfcmVmLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZiRpZ25vcmVDb2xsYXBzZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGlnbm9yZUNvbGxhcHNlZCwKICAgICAgX3JlZiRpc1BzZXVkb1Jvb3QgPSBfcmVmLmlzUHNldWRvUm9vdCwKICAgICAgaXNQc2V1ZG9Sb290ID0gX3JlZiRpc1BzZXVkb1Jvb3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpc1BzZXVkb1Jvb3Q7CiAgLy8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCiAgdmFyIHNlbGZQYXRoID0gIWlzUHNldWRvUm9vdCA/IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksIFtnZXROb2RlS2V5KHsKICAgIG5vZGU6IG5vZGUsCiAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogIH0pXSkgOiBbXTsgLy8gUmV0dXJuIHRhcmdldCBub2RlIHdoZW4gZm91bmQKCiAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdGFyZ2V0SW5kZXgpIHsKICAgIHJldHVybiB7CiAgICAgIG5vZGU6IG5vZGUsCiAgICAgIGxvd2VyU2libGluZ0NvdW50czogbG93ZXJTaWJsaW5nQ291bnRzLAogICAgICBwYXRoOiBzZWxmUGF0aAogICAgfTsKICB9IC8vIEFkZCBvbmUgYW5kIGNvbnRpbnVlIGZvciBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIG9yIGhpZGRlbiBjaGlsZHJlbgoKCiAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IGlnbm9yZUNvbGxhcHNlZCAmJiBub2RlLmV4cGFuZGVkICE9PSB0cnVlKSB7CiAgICByZXR1cm4gewogICAgICBuZXh0SW5kZXg6IGN1cnJlbnRJbmRleCArIDEKICAgIH07CiAgfSAvLyBJdGVyYXRlIG92ZXIgZWFjaCBjaGlsZCBhbmQgdGhlaXIgZGVzY2VuZGFudHMgYW5kIHJldHVybiB0aGUKICAvLyB0YXJnZXQgbm9kZSBpZiBjaGlsZEluZGV4IHJlYWNoZXMgdGhlIHRhcmdldEluZGV4CgoKICB2YXIgY2hpbGRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7CiAgdmFyIGNoaWxkQ291bnQgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyBpICs9IDEpIHsKICAgIHZhciByZXN1bHQgPSBnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoewogICAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgICAgdGFyZ2V0SW5kZXg6IHRhcmdldEluZGV4LAogICAgICBub2RlOiBub2RlLmNoaWxkcmVuW2ldLAogICAgICBjdXJyZW50SW5kZXg6IGNoaWxkSW5kZXgsCiAgICAgIGxvd2VyU2libGluZ0NvdW50czogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsb3dlclNpYmxpbmdDb3VudHMpLCBbY2hpbGRDb3VudCAtIGkgLSAxXSksCiAgICAgIHBhdGg6IHNlbGZQYXRoCiAgICB9KTsKCiAgICBpZiAocmVzdWx0Lm5vZGUpIHsKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KCiAgICBjaGlsZEluZGV4ID0gcmVzdWx0Lm5leHRJbmRleDsKICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSBpcyBub3QgZm91bmQsIHJldHVybiB0aGUgZmFydGhlc3QgdHJhdmVyc2VkIGluZGV4CgoKICByZXR1cm4gewogICAgbmV4dEluZGV4OiBjaGlsZEluZGV4CiAgfTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldERlc2NlbmRhbnRDb3VudChfcmVmMikgewogIHZhciBub2RlID0gX3JlZjIubm9kZSwKICAgICAgX3JlZjIkaWdub3JlQ29sbGFwc2VkID0gX3JlZjIuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMiRpZ25vcmVDb2xsYXBzZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRpZ25vcmVDb2xsYXBzZWQ7CiAgcmV0dXJuIGdldE5vZGVEYXRhQXRUcmVlSW5kZXhPck5leHRJbmRleCh7CiAgICBnZXROb2RlS2V5OiBmdW5jdGlvbiBnZXROb2RlS2V5KCkge30sCiAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgIG5vZGU6IG5vZGUsCiAgICBjdXJyZW50SW5kZXg6IDAsCiAgICB0YXJnZXRJbmRleDogLTEKICB9KS5uZXh0SW5kZXggLSAxOwp9Ci8qKg0KICogV2FsayBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIGdpdmVuIG5vZGUsIGRlcHRoLWZpcnN0DQogKg0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBGdW5jdGlvbiBwYXJhbWV0ZXJzDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIG5vZGUNCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFyZ3MuZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhcmdzLmlzUHNldWRvUm9vdCAtIElmIHRydWUsIHRoaXMgbm9kZSBoYXMgbm8gcmVhbCBkYXRhLCBhbmQgb25seSBzZXJ2ZXMNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBwYXJlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgdHJlZQ0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3Mubm9kZSAtIEEgdHJlZSBub2RlDQogKiBAcGFyYW0ge09iamVjdD19IGFyZ3MucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiBgbm9kZWANCiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmN1cnJlbnRJbmRleCAtIFRoZSB0cmVlSW5kZXggb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBhcmdzLnBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBjaGFuZ2VkDQogKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLmxvd2VyU2libGluZ0NvdW50cyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvdW50IG9mIHNpYmxpbmdzIGJlbmVhdGggdGhlDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzIG5vZGVzIGluIHRoaXMgcGF0aA0KICoNCiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gbmV4dEluZGV4IC0gSW5kZXggb2YgdGhlIG5leHQgc2libGluZyBvZiBgbm9kZWAsDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGZhbHNlIGlmIHRoZSB3YWxrIHNob3VsZCBiZSB0ZXJtaW5hdGVkDQogKi8KCmlmICh0eXBlb2YgZ2V0RGVzY2VuZGFudENvdW50ICE9PSAndW5kZWZpbmVkJyAmJiBnZXREZXNjZW5kYW50Q291bnQgJiYgZ2V0RGVzY2VuZGFudENvdW50ID09PSBPYmplY3QoZ2V0RGVzY2VuZGFudENvdW50KSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldERlc2NlbmRhbnRDb3VudCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0RGVzY2VuZGFudENvdW50LCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0RGVzY2VuZGFudENvdW50IiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZnVuY3Rpb24gd2Fsa0Rlc2NlbmRhbnRzKF9yZWYzKSB7CiAgdmFyIGNhbGxiYWNrID0gX3JlZjMuY2FsbGJhY2ssCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMy5nZXROb2RlS2V5LAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMy5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIF9yZWYzJGlzUHNldWRvUm9vdCA9IF9yZWYzLmlzUHNldWRvUm9vdCwKICAgICAgaXNQc2V1ZG9Sb290ID0gX3JlZjMkaXNQc2V1ZG9Sb290ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlzUHNldWRvUm9vdCwKICAgICAgbm9kZSA9IF9yZWYzLm5vZGUsCiAgICAgIF9yZWYzJHBhcmVudE5vZGUgPSBfcmVmMy5wYXJlbnROb2RlLAogICAgICBwYXJlbnROb2RlID0gX3JlZjMkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYzJHBhcmVudE5vZGUsCiAgICAgIGN1cnJlbnRJbmRleCA9IF9yZWYzLmN1cnJlbnRJbmRleCwKICAgICAgX3JlZjMkcGF0aCA9IF9yZWYzLnBhdGgsCiAgICAgIHBhdGggPSBfcmVmMyRwYXRoID09PSB2b2lkIDAgPyBbXSA6IF9yZWYzJHBhdGgsCiAgICAgIF9yZWYzJGxvd2VyU2libGluZ0NvdSA9IF9yZWYzLmxvd2VyU2libGluZ0NvdW50cywKICAgICAgbG93ZXJTaWJsaW5nQ291bnRzID0gX3JlZjMkbG93ZXJTaWJsaW5nQ291ID09PSB2b2lkIDAgPyBbXSA6IF9yZWYzJGxvd2VyU2libGluZ0NvdTsKICAvLyBUaGUgcHNldWRvLXJvb3QgaXMgbm90IGNvbnNpZGVyZWQgaW4gdGhlIHBhdGgKICB2YXIgc2VsZlBhdGggPSBpc1BzZXVkb1Jvb3QgPyBbXSA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksIFtnZXROb2RlS2V5KHsKICAgIG5vZGU6IG5vZGUsCiAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogIH0pXSk7CiAgdmFyIHNlbGZJbmZvID0gaXNQc2V1ZG9Sb290ID8gbnVsbCA6IHsKICAgIG5vZGU6IG5vZGUsCiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLAogICAgcGF0aDogc2VsZlBhdGgsCiAgICBsb3dlclNpYmxpbmdDb3VudHM6IGxvd2VyU2libGluZ0NvdW50cywKICAgIHRyZWVJbmRleDogY3VycmVudEluZGV4CiAgfTsKCiAgaWYgKCFpc1BzZXVkb1Jvb3QpIHsKICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrKHNlbGZJbmZvKTsgLy8gQ3V0IHdhbGsgc2hvcnQgaWYgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlCgogICAgaWYgKGNhbGxiYWNrUmVzdWx0ID09PSBmYWxzZSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfSAvLyBSZXR1cm4gc2VsZiBvbiBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIG9yIGhpZGRlbiBjaGlsZHJlbgoKCiAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuZXhwYW5kZWQgIT09IHRydWUgJiYgaWdub3JlQ29sbGFwc2VkICYmICFpc1BzZXVkb1Jvb3QpIHsKICAgIHJldHVybiBjdXJyZW50SW5kZXg7CiAgfSAvLyBHZXQgYWxsIGRlc2NlbmRhbnRzCgoKICB2YXIgY2hpbGRJbmRleCA9IGN1cnJlbnRJbmRleDsKICB2YXIgY2hpbGRDb3VudCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOwoKICBpZiAodHlwZW9mIG5vZGUuY2hpbGRyZW4gIT09ICJmdW5jdGlvbiIpIHsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSArPSAxKSB7CiAgICAgIGNoaWxkSW5kZXggPSB3YWxrRGVzY2VuZGFudHMoewogICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjaywKICAgICAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgICAgIG5vZGU6IG5vZGUuY2hpbGRyZW5baV0sCiAgICAgICAgcGFyZW50Tm9kZTogaXNQc2V1ZG9Sb290ID8gbnVsbCA6IG5vZGUsCiAgICAgICAgY3VycmVudEluZGV4OiBjaGlsZEluZGV4ICsgMSwKICAgICAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG93ZXJTaWJsaW5nQ291bnRzKSwgW2NoaWxkQ291bnQgLSBpIC0gMV0pLAogICAgICAgIHBhdGg6IHNlbGZQYXRoCiAgICAgIH0pOyAvLyBDdXQgd2FsayBzaG9ydCBpZiB0aGUgY2FsbGJhY2sgcmV0dXJuZWQgZmFsc2UKCiAgICAgIGlmIChjaGlsZEluZGV4ID09PSBmYWxzZSkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIGNoaWxkSW5kZXg7Cn0KLyoqDQogKiBQZXJmb3JtIGEgY2hhbmdlIG9uIHRoZSBnaXZlbiBub2RlIGFuZCBhbGwgaXRzIGRlc2NlbmRhbnRzLCB0cmF2ZXJzaW5nIHRoZSB0cmVlIGRlcHRoLWZpcnN0DQogKg0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgLSBGdW5jdGlvbiBwYXJhbWV0ZXJzDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbiBlYWNoIG5vZGUNCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGFyZ3MuZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhcmdzLmlzUHNldWRvUm9vdCAtIElmIHRydWUsIHRoaXMgbm9kZSBoYXMgbm8gcmVhbCBkYXRhLCBhbmQgb25seSBzZXJ2ZXMNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIHRoZSBwYXJlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgdHJlZQ0KICogQHBhcmFtIHtPYmplY3R9IGFyZ3Mubm9kZSAtIEEgdHJlZSBub2RlDQogKiBAcGFyYW0ge09iamVjdD19IGFyZ3MucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiBgbm9kZWANCiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmN1cnJlbnRJbmRleCAtIFRoZSB0cmVlSW5kZXggb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBhcmdzLnBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBjaGFuZ2VkDQogKiBAcGFyYW0ge251bWJlcltdfSBhcmdzLmxvd2VyU2libGluZ0NvdW50cyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvdW50IG9mIHNpYmxpbmdzIGJlbmVhdGggdGhlDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzIG5vZGVzIGluIHRoaXMgcGF0aA0KICoNCiAqIEByZXR1cm4ge251bWJlcnxmYWxzZX0gbmV4dEluZGV4IC0gSW5kZXggb2YgdGhlIG5leHQgc2libGluZyBvZiBgbm9kZWAsDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIGZhbHNlIGlmIHRoZSB3YWxrIHNob3VsZCBiZSB0ZXJtaW5hdGVkDQogKi8KCgpmdW5jdGlvbiBtYXBEZXNjZW5kYW50cyhfcmVmNCkgewogIHZhciBjYWxsYmFjayA9IF9yZWY0LmNhbGxiYWNrLAogICAgICBnZXROb2RlS2V5ID0gX3JlZjQuZ2V0Tm9kZUtleSwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjQuaWdub3JlQ29sbGFwc2VkLAogICAgICBfcmVmNCRpc1BzZXVkb1Jvb3QgPSBfcmVmNC5pc1BzZXVkb1Jvb3QsCiAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWY0JGlzUHNldWRvUm9vdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNCRpc1BzZXVkb1Jvb3QsCiAgICAgIG5vZGUgPSBfcmVmNC5ub2RlLAogICAgICBfcmVmNCRwYXJlbnROb2RlID0gX3JlZjQucGFyZW50Tm9kZSwKICAgICAgcGFyZW50Tm9kZSA9IF9yZWY0JHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNCRwYXJlbnROb2RlLAogICAgICBjdXJyZW50SW5kZXggPSBfcmVmNC5jdXJyZW50SW5kZXgsCiAgICAgIF9yZWY0JHBhdGggPSBfcmVmNC5wYXRoLAogICAgICBwYXRoID0gX3JlZjQkcGF0aCA9PT0gdm9pZCAwID8gW10gOiBfcmVmNCRwYXRoLAogICAgICBfcmVmNCRsb3dlclNpYmxpbmdDb3UgPSBfcmVmNC5sb3dlclNpYmxpbmdDb3VudHMsCiAgICAgIGxvd2VyU2libGluZ0NvdW50cyA9IF9yZWY0JGxvd2VyU2libGluZ0NvdSA9PT0gdm9pZCAwID8gW10gOiBfcmVmNCRsb3dlclNpYmxpbmdDb3U7CgogIHZhciBuZXh0Tm9kZSA9IF9vYmplY3RTcHJlYWQoe30sIG5vZGUpOyAvLyBUaGUgcHNldWRvLXJvb3QgaXMgbm90IGNvbnNpZGVyZWQgaW4gdGhlIHBhdGgKCgogIHZhciBzZWxmUGF0aCA9IGlzUHNldWRvUm9vdCA/IFtdIDogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXRoKSwgW2dldE5vZGVLZXkoewogICAgbm9kZTogbmV4dE5vZGUsCiAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogIH0pXSk7CiAgdmFyIHNlbGZJbmZvID0gewogICAgbm9kZTogbmV4dE5vZGUsCiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLAogICAgcGF0aDogc2VsZlBhdGgsCiAgICBsb3dlclNpYmxpbmdDb3VudHM6IGxvd2VyU2libGluZ0NvdW50cywKICAgIHRyZWVJbmRleDogY3VycmVudEluZGV4CiAgfTsgLy8gUmV0dXJuIHNlbGYgb24gbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KCiAgaWYgKCFuZXh0Tm9kZS5jaGlsZHJlbiB8fCBuZXh0Tm9kZS5leHBhbmRlZCAhPT0gdHJ1ZSAmJiBpZ25vcmVDb2xsYXBzZWQgJiYgIWlzUHNldWRvUm9vdCkgewogICAgcmV0dXJuIHsKICAgICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgsCiAgICAgIG5vZGU6IGNhbGxiYWNrKHNlbGZJbmZvKQogICAgfTsKICB9IC8vIEdldCBhbGwgZGVzY2VuZGFudHMKCgogIHZhciBjaGlsZEluZGV4ID0gY3VycmVudEluZGV4OwogIHZhciBjaGlsZENvdW50ID0gbmV4dE5vZGUuY2hpbGRyZW4ubGVuZ3RoOwoKICBpZiAodHlwZW9mIG5leHROb2RlLmNoaWxkcmVuICE9PSAiZnVuY3Rpb24iKSB7CiAgICBuZXh0Tm9kZS5jaGlsZHJlbiA9IG5leHROb2RlLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAoY2hpbGQsIGkpIHsKICAgICAgdmFyIG1hcFJlc3VsdCA9IG1hcERlc2NlbmRhbnRzKHsKICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssCiAgICAgICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgICAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgICAgICBub2RlOiBjaGlsZCwKICAgICAgICBwYXJlbnROb2RlOiBpc1BzZXVkb1Jvb3QgPyBudWxsIDogbmV4dE5vZGUsCiAgICAgICAgY3VycmVudEluZGV4OiBjaGlsZEluZGV4ICsgMSwKICAgICAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG93ZXJTaWJsaW5nQ291bnRzKSwgW2NoaWxkQ291bnQgLSBpIC0gMV0pLAogICAgICAgIHBhdGg6IHNlbGZQYXRoCiAgICAgIH0pOwogICAgICBjaGlsZEluZGV4ID0gbWFwUmVzdWx0LnRyZWVJbmRleDsKICAgICAgcmV0dXJuIG1hcFJlc3VsdC5ub2RlOwogICAgfSk7CiAgfQoKICByZXR1cm4gewogICAgbm9kZTogY2FsbGJhY2soc2VsZkluZm8pLAogICAgdHJlZUluZGV4OiBjaGlsZEluZGV4CiAgfTsKfQovKioNCiAqIENvdW50IGFsbCB0aGUgdmlzaWJsZSAoZXhwYW5kZWQpIGRlc2NlbmRhbnRzIGluIHRoZSB0cmVlIGRhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKg0KICogQHJldHVybiB7bnVtYmVyfSBjb3VudA0KICovCgoKZXhwb3J0IGZ1bmN0aW9uIGdldFZpc2libGVOb2RlQ291bnQoX3JlZjUpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmNS50cmVlRGF0YTsKCiAgdmFyIHRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2Uobm9kZSkgewogICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IG5vZGUuZXhwYW5kZWQgIT09IHRydWUgfHwgdHlwZW9mIG5vZGUuY2hpbGRyZW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgcmV0dXJuIDE7CiAgICB9CgogICAgcmV0dXJuIDEgKyBub2RlLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIGN1cnJlbnROb2RlKSB7CiAgICAgIHJldHVybiB0b3RhbCArIHRyYXZlcnNlKGN1cnJlbnROb2RlKTsKICAgIH0sIDApOwogIH07CgogIHJldHVybiB0cmVlRGF0YS5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCBjdXJyZW50Tm9kZSkgewogICAgcmV0dXJuIHRvdGFsICsgdHJhdmVyc2UoY3VycmVudE5vZGUpOwogIH0sIDApOwp9Ci8qKg0KICogR2V0IHRoZSA8dGFyZ2V0SW5kZXg+dGggdmlzaWJsZSBub2RlIGluIHRoZSB0cmVlIGRhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFudW1iZXJ9IHRhcmdldEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBub2RlIHRvIHNlYXJjaCBmb3INCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqDQogKiBAcmV0dXJuIHt7DQogKiAgICAgIG5vZGU6IE9iamVjdCwNCiAqICAgICAgcGF0aDogW11zdHJpbmd8W11udW1iZXIsDQogKiAgICAgIGxvd2VyU2libGluZ0NvdW50czogW11udW1iZXINCiAqICB9fG51bGx9IG5vZGUgLSBUaGUgbm9kZSBhdCB0YXJnZXRJbmRleCwgb3IgbnVsbCBpZiBub3QgZm91bmQNCiAqLwoKaWYgKHR5cGVvZiBnZXRWaXNpYmxlTm9kZUNvdW50ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRWaXNpYmxlTm9kZUNvdW50ICYmIGdldFZpc2libGVOb2RlQ291bnQgPT09IE9iamVjdChnZXRWaXNpYmxlTm9kZUNvdW50KSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldFZpc2libGVOb2RlQ291bnQpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldFZpc2libGVOb2RlQ291bnQsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXRWaXNpYmxlTm9kZUNvdW50IiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgoX3JlZjYpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmNi50cmVlRGF0YSwKICAgICAgdGFyZ2V0SW5kZXggPSBfcmVmNi5pbmRleCwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWY2LmdldE5vZGVLZXk7CgogIGlmICghdHJlZURhdGEgfHwgdHJlZURhdGEubGVuZ3RoIDwgMSkgewogICAgcmV0dXJuIG51bGw7CiAgfSAvLyBDYWxsIHRoZSB0cmVlIHRyYXZlcnNhbCB3aXRoIGEgcHNldWRvLXJvb3Qgbm9kZQoKCiAgdmFyIHJlc3VsdCA9IGdldE5vZGVEYXRhQXRUcmVlSW5kZXhPck5leHRJbmRleCh7CiAgICB0YXJnZXRJbmRleDogdGFyZ2V0SW5kZXgsCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgbm9kZTogewogICAgICBjaGlsZHJlbjogdHJlZURhdGEsCiAgICAgIGV4cGFuZGVkOiB0cnVlCiAgICB9LAogICAgY3VycmVudEluZGV4OiAtMSwKICAgIHBhdGg6IFtdLAogICAgbG93ZXJTaWJsaW5nQ291bnRzOiBbXSwKICAgIGlzUHNldWRvUm9vdDogdHJ1ZQogIH0pOwoKICBpZiAocmVzdWx0Lm5vZGUpIHsKICAgIHJldHVybiByZXN1bHQ7CiAgfQoKICByZXR1cm4gbnVsbDsKfQovKioNCiAqIFdhbGsgZGVzY2VuZGFudHMgZGVwdGgtZmlyc3QgYW5kIGNhbGwgYSBjYWxsYmFjayBvbiBlYWNoDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBub2RlDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHZvaWQNCiAqLwoKaWYgKHR5cGVvZiBnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4ICYmIGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXggPT09IE9iamVjdChnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4KSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4IiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIHdhbGsoX3JlZjcpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmNy50cmVlRGF0YSwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWY3LmdldE5vZGVLZXksCiAgICAgIGNhbGxiYWNrID0gX3JlZjcuY2FsbGJhY2ssCiAgICAgIF9yZWY3JGlnbm9yZUNvbGxhcHNlZCA9IF9yZWY3Lmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjckaWdub3JlQ29sbGFwc2VkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjckaWdub3JlQ29sbGFwc2VkOwoKICBpZiAoIXRyZWVEYXRhIHx8IHRyZWVEYXRhLmxlbmd0aCA8IDEpIHsKICAgIHJldHVybjsKICB9CgogIHdhbGtEZXNjZW5kYW50cyh7CiAgICBjYWxsYmFjazogY2FsbGJhY2ssCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBpc1BzZXVkb1Jvb3Q6IHRydWUsCiAgICBub2RlOiB7CiAgICAgIGNoaWxkcmVuOiB0cmVlRGF0YQogICAgfSwKICAgIGN1cnJlbnRJbmRleDogLTEsCiAgICBwYXRoOiBbXSwKICAgIGxvd2VyU2libGluZ0NvdW50czogW10KICB9KTsKfQovKioNCiAqIFBlcmZvcm0gYSBkZXB0aC1maXJzdCB0cmFuc3ZlcnNhbCBvZiB0aGUgZGVzY2VuZGFudHMgYW5kDQogKiAgbWFrZSBhIGNoYW5nZSB0byBldmVyeSBub2RlIGluIHRoZSB0cmVlDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBub2RlDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gY2hhbmdlZFRyZWVEYXRhIC0gVGhlIGNoYW5nZWQgdHJlZSBkYXRhDQogKi8KCmlmICh0eXBlb2Ygd2FsayAhPT0gJ3VuZGVmaW5lZCcgJiYgd2FsayAmJiB3YWxrID09PSBPYmplY3Qod2FsaykgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh3YWxrKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3YWxrLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAid2FsayIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBtYXAoX3JlZjgpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmOC50cmVlRGF0YSwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWY4LmdldE5vZGVLZXksCiAgICAgIGNhbGxiYWNrID0gX3JlZjguY2FsbGJhY2ssCiAgICAgIF9yZWY4JGlnbm9yZUNvbGxhcHNlZCA9IF9yZWY4Lmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjgkaWdub3JlQ29sbGFwc2VkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjgkaWdub3JlQ29sbGFwc2VkOwoKICBpZiAoIXRyZWVEYXRhIHx8IHRyZWVEYXRhLmxlbmd0aCA8IDEpIHsKICAgIHJldHVybiBbXTsKICB9CgogIHJldHVybiBtYXBEZXNjZW5kYW50cyh7CiAgICBjYWxsYmFjazogY2FsbGJhY2ssCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBpc1BzZXVkb1Jvb3Q6IHRydWUsCiAgICBub2RlOiB7CiAgICAgIGNoaWxkcmVuOiB0cmVlRGF0YQogICAgfSwKICAgIGN1cnJlbnRJbmRleDogLTEsCiAgICBwYXRoOiBbXSwKICAgIGxvd2VyU2libGluZ0NvdW50czogW10KICB9KS5ub2RlLmNoaWxkcmVuOwp9Ci8qKg0KICogRXhwYW5kIG9yIGNsb3NlIGV2ZXJ5IG5vZGUgaW4gdGhlIHRyZWUNCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGEgLSBUcmVlIGRhdGENCiAqIEBwYXJhbSB7P2Jvb2xlYW59IGV4cGFuZGVkIC0gV2hldGhlciB0aGUgbm9kZSBpcyBleHBhbmRlZCBvciBub3QNCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gY2hhbmdlZFRyZWVEYXRhIC0gVGhlIGNoYW5nZWQgdHJlZSBkYXRhDQogKi8KCmlmICh0eXBlb2YgbWFwICE9PSAndW5kZWZpbmVkJyAmJiBtYXAgJiYgbWFwID09PSBPYmplY3QobWFwKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKG1hcCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAibWFwIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUV4cGFuZGVkRm9yQWxsKF9yZWY5KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjkudHJlZURhdGEsCiAgICAgIF9yZWY5JGV4cGFuZGVkID0gX3JlZjkuZXhwYW5kZWQsCiAgICAgIGV4cGFuZGVkID0gX3JlZjkkZXhwYW5kZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmOSRleHBhbmRlZDsKICByZXR1cm4gbWFwKHsKICAgIHRyZWVEYXRhOiB0cmVlRGF0YSwKICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhfcmVmMTApIHsKICAgICAgdmFyIG5vZGUgPSBfcmVmMTAubm9kZTsKICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIG5vZGUsIHsKICAgICAgICBleHBhbmRlZDogZXhwYW5kZWQKICAgICAgfSk7CiAgICB9LAogICAgZ2V0Tm9kZUtleTogZnVuY3Rpb24gZ2V0Tm9kZUtleShfcmVmMTEpIHsKICAgICAgdmFyIHRyZWVJbmRleCA9IF9yZWYxMS50cmVlSW5kZXg7CiAgICAgIHJldHVybiB0cmVlSW5kZXg7CiAgICB9LAogICAgaWdub3JlQ29sbGFwc2VkOiBmYWxzZQogIH0pOwp9Ci8qKg0KICogUmVwbGFjZXMgbm9kZSBhdCBwYXRoIHdpdGggb2JqZWN0LCBvciBjYWxsYmFjay1kZWZpbmVkIG9iamVjdA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YQ0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gcGF0aCAtIEFycmF5IG9mIGtleXMgbGVhZGluZyB1cCB0byBub2RlIHRvIGJlIGNoYW5nZWQNCiAqIEBwYXJhbSB7ZnVuY3Rpb258YW55fSBuZXdOb2RlIC0gTm9kZSB0byByZXBsYWNlIHRoZSBub2RlIGF0IHRoZSBwYXRoIHdpdGgsIG9yIGEgZnVuY3Rpb24gcHJvZHVjaW5nIHRoZSBuZXcgbm9kZQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IGNoYW5nZWRUcmVlRGF0YSAtIFRoZSBjaGFuZ2VkIHRyZWUgZGF0YQ0KICovCgppZiAodHlwZW9mIHRvZ2dsZUV4cGFuZGVkRm9yQWxsICE9PSAndW5kZWZpbmVkJyAmJiB0b2dnbGVFeHBhbmRlZEZvckFsbCAmJiB0b2dnbGVFeHBhbmRlZEZvckFsbCA9PT0gT2JqZWN0KHRvZ2dsZUV4cGFuZGVkRm9yQWxsKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHRvZ2dsZUV4cGFuZGVkRm9yQWxsKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0b2dnbGVFeHBhbmRlZEZvckFsbCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogInRvZ2dsZUV4cGFuZGVkRm9yQWxsIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGNoYW5nZU5vZGVBdFBhdGgoX3JlZjEyKSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjEyLnRyZWVEYXRhLAogICAgICBwYXRoID0gX3JlZjEyLnBhdGgsCiAgICAgIG5ld05vZGUgPSBfcmVmMTIubmV3Tm9kZSwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYxMi5nZXROb2RlS2V5LAogICAgICBfcmVmMTIkaWdub3JlQ29sbGFwc2UgPSBfcmVmMTIuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMTIkaWdub3JlQ29sbGFwc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMTIkaWdub3JlQ29sbGFwc2U7CiAgdmFyIFJFU1VMVF9NSVNTID0gIlJFU1VMVF9NSVNTIjsKCiAgdmFyIHRyYXZlcnNlID0gZnVuY3Rpb24gdHJhdmVyc2UoX3JlZjEzKSB7CiAgICB2YXIgX3JlZjEzJGlzUHNldWRvUm9vdCA9IF9yZWYxMy5pc1BzZXVkb1Jvb3QsCiAgICAgICAgaXNQc2V1ZG9Sb290ID0gX3JlZjEzJGlzUHNldWRvUm9vdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTMkaXNQc2V1ZG9Sb290LAogICAgICAgIG5vZGUgPSBfcmVmMTMubm9kZSwKICAgICAgICBjdXJyZW50VHJlZUluZGV4ID0gX3JlZjEzLmN1cnJlbnRUcmVlSW5kZXgsCiAgICAgICAgcGF0aEluZGV4ID0gX3JlZjEzLnBhdGhJbmRleDsKCiAgICBpZiAoIWlzUHNldWRvUm9vdCAmJiBnZXROb2RlS2V5KHsKICAgICAgbm9kZTogbm9kZSwKICAgICAgdHJlZUluZGV4OiBjdXJyZW50VHJlZUluZGV4CiAgICB9KSAhPT0gcGF0aFtwYXRoSW5kZXhdKSB7CiAgICAgIHJldHVybiBSRVNVTFRfTUlTUzsKICAgIH0KCiAgICBpZiAocGF0aEluZGV4ID49IHBhdGgubGVuZ3RoIC0gMSkgewogICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaW5hbCBsb2NhdGlvbiBpbiB0aGUgcGF0aCwgcmV0dXJuIGl0cyBjaGFuZ2VkIGZvcm0KICAgICAgcmV0dXJuIHR5cGVvZiBuZXdOb2RlID09PSAiZnVuY3Rpb24iID8gbmV3Tm9kZSh7CiAgICAgICAgbm9kZTogbm9kZSwKICAgICAgICB0cmVlSW5kZXg6IGN1cnJlbnRUcmVlSW5kZXgKICAgICAgfSkgOiBuZXdOb2RlOwogICAgfQoKICAgIGlmICghbm9kZS5jaGlsZHJlbikgewogICAgICAvLyBJZiB0aGlzIG5vZGUgaXMgcGFydCBvZiB0aGUgcGF0aCwgYnV0IGhhcyBubyBjaGlsZHJlbiwgcmV0dXJuIHRoZSB1bmNoYW5nZWQgbm9kZQogICAgICB0aHJvdyBuZXcgRXJyb3IoIlBhdGggcmVmZXJlbmNlZCBjaGlsZHJlbiBvZiBub2RlIHdpdGggbm8gY2hpbGRyZW4uIik7CiAgICB9CgogICAgdmFyIG5leHRUcmVlSW5kZXggPSBjdXJyZW50VHJlZUluZGV4ICsgMTsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgdmFyIF9yZXN1bHQgPSB0cmF2ZXJzZSh7CiAgICAgICAgbm9kZTogbm9kZS5jaGlsZHJlbltpXSwKICAgICAgICBjdXJyZW50VHJlZUluZGV4OiBuZXh0VHJlZUluZGV4LAogICAgICAgIHBhdGhJbmRleDogcGF0aEluZGV4ICsgMQogICAgICB9KTsgLy8gSWYgdGhlIHJlc3VsdCB3ZW50IGRvd24gdGhlIGNvcnJlY3QgcGF0aAoKCiAgICAgIGlmIChfcmVzdWx0ICE9PSBSRVNVTFRfTUlTUykgewogICAgICAgIGlmIChfcmVzdWx0KSB7CiAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IHdhcyB0cnV0aHkgKGluIHRoaXMgY2FzZSwgYW4gb2JqZWN0KSwKICAgICAgICAgIC8vICBwYXNzIGl0IHRvIHRoZSBuZXh0IGxldmVsIG9mIHJlY3Vyc2lvbiB1cAogICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIG5vZGUsIHsKICAgICAgICAgICAgY2hpbGRyZW46IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZS5jaGlsZHJlbi5zbGljZSgwLCBpKSksIFtfcmVzdWx0XSwgX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoaSArIDEpKSkKICAgICAgICAgIH0pOwogICAgICAgIH0gLy8gSWYgdGhlIHJlc3VsdCB3YXMgZmFsc3kgKHJldHVybmVkIGZyb20gdGhlIG5ld05vZGUgZnVuY3Rpb24pLCB0aGVuCiAgICAgICAgLy8gIGRlbGV0ZSB0aGUgbm9kZSBmcm9tIHRoZSBhcnJheS4KCgogICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBub2RlLCB7CiAgICAgICAgICBjaGlsZHJlbjogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKDAsIGkpKSwgX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoaSArIDEpKSkKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgbmV4dFRyZWVJbmRleCArPSAxICsgZ2V0RGVzY2VuZGFudENvdW50KHsKICAgICAgICBub2RlOiBub2RlLmNoaWxkcmVuW2ldLAogICAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkCiAgICAgIH0pOwogICAgfQoKICAgIHJldHVybiBSRVNVTFRfTUlTUzsKICB9OyAvLyBVc2UgYSBwc2V1ZG8tcm9vdCBub2RlIGluIHRoZSBiZWdpbm5pbmcgdHJhdmVyc2FsCgoKICB2YXIgcmVzdWx0ID0gdHJhdmVyc2UoewogICAgbm9kZTogewogICAgICBjaGlsZHJlbjogdHJlZURhdGEKICAgIH0sCiAgICBjdXJyZW50VHJlZUluZGV4OiAtMSwKICAgIHBhdGhJbmRleDogLTEsCiAgICBpc1BzZXVkb1Jvb3Q6IHRydWUKICB9KTsKCiAgaWYgKHJlc3VsdCA9PT0gUkVTVUxUX01JU1MpIHsKICAgIHRocm93IG5ldyBFcnJvcigiTm8gbm9kZSBmb3VuZCBhdCB0aGUgZ2l2ZW4gcGF0aC4iKTsKICB9CgogIHJldHVybiByZXN1bHQuY2hpbGRyZW47Cn0KLyoqDQogKiBSZW1vdmVzIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHRyZWVEYXRhLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YQ0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gcGF0aCAtIEFycmF5IG9mIGtleXMgbGVhZGluZyB1cCB0byBub2RlIHRvIGJlIGRlbGV0ZWQNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge09iamVjdFtdfSBjaGFuZ2VkVHJlZURhdGEgLSBUaGUgdHJlZSBkYXRhIHdpdGggdGhlIG5vZGUgcmVtb3ZlZA0KICovCgppZiAodHlwZW9mIGNoYW5nZU5vZGVBdFBhdGggIT09ICd1bmRlZmluZWQnICYmIGNoYW5nZU5vZGVBdFBhdGggJiYgY2hhbmdlTm9kZUF0UGF0aCA9PT0gT2JqZWN0KGNoYW5nZU5vZGVBdFBhdGgpICYmIE9iamVjdC5pc0V4dGVuc2libGUoY2hhbmdlTm9kZUF0UGF0aCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2hhbmdlTm9kZUF0UGF0aCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImNoYW5nZU5vZGVBdFBhdGgiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZUF0UGF0aChfcmVmMTQpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmMTQudHJlZURhdGEsCiAgICAgIHBhdGggPSBfcmVmMTQucGF0aCwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYxNC5nZXROb2RlS2V5LAogICAgICBfcmVmMTQkaWdub3JlQ29sbGFwc2UgPSBfcmVmMTQuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMTQkaWdub3JlQ29sbGFwc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMTQkaWdub3JlQ29sbGFwc2U7CiAgcmV0dXJuIGNoYW5nZU5vZGVBdFBhdGgoewogICAgdHJlZURhdGE6IHRyZWVEYXRhLAogICAgcGF0aDogcGF0aCwKICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgIG5ld05vZGU6IG51bGwgLy8gRGVsZXRlIHRoZSBub2RlCgogIH0pOwp9Ci8qKg0KICogUmVtb3ZlcyB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0cmVlRGF0YS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGENCiAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBkZWxldGVkDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdA0KICogQHJldHVybiB7T2JqZWN0W119IHJlc3VsdC50cmVlRGF0YSAtIFRoZSB0cmVlIGRhdGEgd2l0aCB0aGUgbm9kZSByZW1vdmVkDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdC5ub2RlIC0gVGhlIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZA0KICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQudHJlZUluZGV4IC0gVGhlIHByZXZpb3VzIHRyZWVJbmRleCBvZiB0aGUgcmVtb3ZlZCBub2RlDQogKi8KCmlmICh0eXBlb2YgcmVtb3ZlTm9kZUF0UGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVtb3ZlTm9kZUF0UGF0aCAmJiByZW1vdmVOb2RlQXRQYXRoID09PSBPYmplY3QocmVtb3ZlTm9kZUF0UGF0aCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShyZW1vdmVOb2RlQXRQYXRoKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW1vdmVOb2RlQXRQYXRoLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAicmVtb3ZlTm9kZUF0UGF0aCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKF9yZWYxNSkgewogIHZhciB0cmVlRGF0YSA9IF9yZWYxNS50cmVlRGF0YSwKICAgICAgcGF0aCA9IF9yZWYxNS5wYXRoLAogICAgICBnZXROb2RlS2V5ID0gX3JlZjE1LmdldE5vZGVLZXksCiAgICAgIF9yZWYxNSRpZ25vcmVDb2xsYXBzZSA9IF9yZWYxNS5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYxNSRpZ25vcmVDb2xsYXBzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYxNSRpZ25vcmVDb2xsYXBzZTsKICB2YXIgcmVtb3ZlZE5vZGUgPSBudWxsOwogIHZhciByZW1vdmVkVHJlZUluZGV4ID0gbnVsbDsKICB2YXIgbmV4dFRyZWVEYXRhID0gY2hhbmdlTm9kZUF0UGF0aCh7CiAgICB0cmVlRGF0YTogdHJlZURhdGEsCiAgICBwYXRoOiBwYXRoLAogICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgbmV3Tm9kZTogZnVuY3Rpb24gbmV3Tm9kZShfcmVmMTYpIHsKICAgICAgdmFyIG5vZGUgPSBfcmVmMTYubm9kZSwKICAgICAgICAgIHRyZWVJbmRleCA9IF9yZWYxNi50cmVlSW5kZXg7CiAgICAgIC8vIFN0b3JlIHRoZSB0YXJnZXQgbm9kZSBhbmQgZGVsZXRlIGl0IGZyb20gdGhlIHRyZWUKICAgICAgcmVtb3ZlZE5vZGUgPSBub2RlOwogICAgICByZW1vdmVkVHJlZUluZGV4ID0gdHJlZUluZGV4OwogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICB9KTsKICByZXR1cm4gewogICAgdHJlZURhdGE6IG5leHRUcmVlRGF0YSwKICAgIG5vZGU6IHJlbW92ZWROb2RlLAogICAgdHJlZUluZGV4OiByZW1vdmVkVHJlZUluZGV4CiAgfTsKfQovKioNCiAqIEdldHMgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgZGVsZXRlZA0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0fG51bGx9IG5vZGVJbmZvIC0gVGhlIG5vZGUgaW5mbyBhdCB0aGUgZ2l2ZW4gcGF0aCwgb3IgbnVsbCBpZiBub3QgZm91bmQNCiAqLwoKaWYgKHR5cGVvZiByZW1vdmVOb2RlICE9PSAndW5kZWZpbmVkJyAmJiByZW1vdmVOb2RlICYmIHJlbW92ZU5vZGUgPT09IE9iamVjdChyZW1vdmVOb2RlKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKHJlbW92ZU5vZGUpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbW92ZU5vZGUsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJyZW1vdmVOb2RlIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVBdFBhdGgoX3JlZjE3KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjE3LnRyZWVEYXRhLAogICAgICBwYXRoID0gX3JlZjE3LnBhdGgsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMTcuZ2V0Tm9kZUtleSwKICAgICAgX3JlZjE3JGlnbm9yZUNvbGxhcHNlID0gX3JlZjE3Lmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjE3JGlnbm9yZUNvbGxhcHNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjE3JGlnbm9yZUNvbGxhcHNlOwogIHZhciBmb3VuZE5vZGVJbmZvID0gbnVsbDsKCiAgdHJ5IHsKICAgIGNoYW5nZU5vZGVBdFBhdGgoewogICAgICB0cmVlRGF0YTogdHJlZURhdGEsCiAgICAgIHBhdGg6IHBhdGgsCiAgICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgICBuZXdOb2RlOiBmdW5jdGlvbiBuZXdOb2RlKF9yZWYxOCkgewogICAgICAgIHZhciBub2RlID0gX3JlZjE4Lm5vZGUsCiAgICAgICAgICAgIHRyZWVJbmRleCA9IF9yZWYxOC50cmVlSW5kZXg7CiAgICAgICAgZm91bmROb2RlSW5mbyA9IHsKICAgICAgICAgIG5vZGU6IG5vZGUsCiAgICAgICAgICB0cmVlSW5kZXg6IHRyZWVJbmRleAogICAgICAgIH07CiAgICAgICAgcmV0dXJuIG5vZGU7CiAgICAgIH0KICAgIH0pOwogIH0gY2F0Y2ggKGVycikgey8vIElnbm9yZSB0aGUgZXJyb3IgLS0gdGhlIG51bGwgcmV0dXJuIHdpbGwgYmUgZXhwbGFuYXRpb24gZW5vdWdoCiAgfQoKICByZXR1cm4gZm91bmROb2RlSW5mbzsKfQovKioNCiAqIEFkZHMgdGhlIG5vZGUgdG8gdGhlIHNwZWNpZmllZCBwYXJlbnQgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0cmVlRGF0YS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGENCiAqIEBwYXJhbSB7IU9iamVjdH0gbmV3Tm9kZSAtIFRoZSBub2RlIHRvIGluc2VydA0KICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBwYXJlbnRLZXkgLSBUaGUga2V5IG9mIHRoZSB0by1iZSBwYXJlbnROb2RlIG9mIHRoZSBub2RlDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4cGFuZFBhcmVudCAtIElmIHRydWUsIGV4cGFuZHMgdGhlIHBhcmVudE5vZGUgc3BlY2lmaWVkIGJ5IHBhcmVudFBhdGgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGFkZEFzRmlyc3RDaGlsZCAtIElmIHRydWUsIGFkZHMgbmV3IG5vZGUgYXMgZmlyc3QgY2hpbGQgb2YgdHJlZQ0KICoNCiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0DQogKiBAcmV0dXJuIHtPYmplY3RbXX0gcmVzdWx0LnRyZWVEYXRhIC0gVGhlIHVwZGF0ZWQgdHJlZSBkYXRhDQogKiBAcmV0dXJuIHtudW1iZXJ9IHJlc3VsdC50cmVlSW5kZXggLSBUaGUgdHJlZSBpbmRleCBhdCB3aGljaCB0aGUgbm9kZSB3YXMgaW5zZXJ0ZWQNCiAqLwoKaWYgKHR5cGVvZiBnZXROb2RlQXRQYXRoICE9PSAndW5kZWZpbmVkJyAmJiBnZXROb2RlQXRQYXRoICYmIGdldE5vZGVBdFBhdGggPT09IE9iamVjdChnZXROb2RlQXRQYXRoKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldE5vZGVBdFBhdGgpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldE5vZGVBdFBhdGgsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXROb2RlQXRQYXRoIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGFkZE5vZGVVbmRlclBhcmVudChfcmVmMTkpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmMTkudHJlZURhdGEsCiAgICAgIG5ld05vZGUgPSBfcmVmMTkubmV3Tm9kZSwKICAgICAgX3JlZjE5JHBhcmVudEtleSA9IF9yZWYxOS5wYXJlbnRLZXksCiAgICAgIHBhcmVudEtleSA9IF9yZWYxOSRwYXJlbnRLZXkgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMTkkcGFyZW50S2V5LAogICAgICBnZXROb2RlS2V5ID0gX3JlZjE5LmdldE5vZGVLZXksCiAgICAgIF9yZWYxOSRpZ25vcmVDb2xsYXBzZSA9IF9yZWYxOS5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYxOSRpZ25vcmVDb2xsYXBzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYxOSRpZ25vcmVDb2xsYXBzZSwKICAgICAgX3JlZjE5JGV4cGFuZFBhcmVudCA9IF9yZWYxOS5leHBhbmRQYXJlbnQsCiAgICAgIGV4cGFuZFBhcmVudCA9IF9yZWYxOSRleHBhbmRQYXJlbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjE5JGV4cGFuZFBhcmVudCwKICAgICAgX3JlZjE5JGFkZEFzRmlyc3RDaGlsID0gX3JlZjE5LmFkZEFzRmlyc3RDaGlsZCwKICAgICAgYWRkQXNGaXJzdENoaWxkID0gX3JlZjE5JGFkZEFzRmlyc3RDaGlsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxOSRhZGRBc0ZpcnN0Q2hpbDsKCiAgaWYgKHBhcmVudEtleSA9PT0gbnVsbCkgewogICAgcmV0dXJuIHsKICAgICAgdHJlZURhdGE6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodHJlZURhdGEgfHwgW10pLCBbbmV3Tm9kZV0pLAogICAgICB0cmVlSW5kZXg6ICh0cmVlRGF0YSB8fCBbXSkubGVuZ3RoCiAgICB9OwogIH0KCiAgdmFyIGluc2VydGVkVHJlZUluZGV4ID0gbnVsbDsKICB2YXIgaGFzQmVlbkFkZGVkID0gZmFsc2U7CiAgdmFyIGNoYW5nZWRUcmVlRGF0YSA9IG1hcCh7CiAgICB0cmVlRGF0YTogdHJlZURhdGEsCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soX3JlZjIwKSB7CiAgICAgIHZhciBub2RlID0gX3JlZjIwLm5vZGUsCiAgICAgICAgICB0cmVlSW5kZXggPSBfcmVmMjAudHJlZUluZGV4LAogICAgICAgICAgcGF0aCA9IF9yZWYyMC5wYXRoOwogICAgICB2YXIga2V5ID0gcGF0aCA/IHBhdGhbcGF0aC5sZW5ndGggLSAxXSA6IG51bGw7IC8vIFJldHVybiBub2RlcyB0aGF0IGFyZSBub3QgdGhlIHBhcmVudCBhcy1pcwoKICAgICAgaWYgKGhhc0JlZW5BZGRlZCB8fCBrZXkgIT09IHBhcmVudEtleSkgewogICAgICAgIHJldHVybiBub2RlOwogICAgICB9CgogICAgICBoYXNCZWVuQWRkZWQgPSB0cnVlOwoKICAgICAgdmFyIHBhcmVudE5vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBub2RlKTsKCiAgICAgIGlmIChleHBhbmRQYXJlbnQpIHsKICAgICAgICBwYXJlbnROb2RlLmV4cGFuZGVkID0gdHJ1ZTsKICAgICAgfSAvLyBJZiBubyBjaGlsZHJlbiBleGlzdCB5ZXQsIGp1c3QgYWRkIHRoZSBzaW5nbGUgbmV3Tm9kZQoKCiAgICAgIGlmICghcGFyZW50Tm9kZS5jaGlsZHJlbikgewogICAgICAgIGluc2VydGVkVHJlZUluZGV4ID0gdHJlZUluZGV4ICsgMTsKICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcGFyZW50Tm9kZSwgewogICAgICAgICAgY2hpbGRyZW46IFtuZXdOb2RlXQogICAgICAgIH0pOwogICAgICB9CgogICAgICBpZiAodHlwZW9mIHBhcmVudE5vZGUuY2hpbGRyZW4gPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBhZGQgdG8gY2hpbGRyZW4gZGVmaW5lZCBieSBhIGZ1bmN0aW9uIik7CiAgICAgIH0KCiAgICAgIHZhciBuZXh0VHJlZUluZGV4ID0gdHJlZUluZGV4ICsgMTsKCiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgIG5leHRUcmVlSW5kZXggKz0gMSArIGdldERlc2NlbmRhbnRDb3VudCh7CiAgICAgICAgICBub2RlOiBwYXJlbnROb2RlLmNoaWxkcmVuW2ldLAogICAgICAgICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQKICAgICAgICB9KTsKICAgICAgfQoKICAgICAgaW5zZXJ0ZWRUcmVlSW5kZXggPSBuZXh0VHJlZUluZGV4OwogICAgICB2YXIgY2hpbGRyZW4gPSBhZGRBc0ZpcnN0Q2hpbGQgPyBbbmV3Tm9kZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJlbnROb2RlLmNoaWxkcmVuKSkgOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhcmVudE5vZGUuY2hpbGRyZW4pLCBbbmV3Tm9kZV0pOwogICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcGFyZW50Tm9kZSwgewogICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbgogICAgICB9KTsKICAgIH0KICB9KTsKCiAgaWYgKCFoYXNCZWVuQWRkZWQpIHsKICAgIHRocm93IG5ldyBFcnJvcigiTm8gbm9kZSBmb3VuZCB3aXRoIHRoZSBnaXZlbiBrZXkuIik7CiAgfQoKICByZXR1cm4gewogICAgdHJlZURhdGE6IGNoYW5nZWRUcmVlRGF0YSwKICAgIHRyZWVJbmRleDogaW5zZXJ0ZWRUcmVlSW5kZXgKICB9Owp9CgppZiAodHlwZW9mIGFkZE5vZGVVbmRlclBhcmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgYWRkTm9kZVVuZGVyUGFyZW50ICYmIGFkZE5vZGVVbmRlclBhcmVudCA9PT0gT2JqZWN0KGFkZE5vZGVVbmRlclBhcmVudCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShhZGROb2RlVW5kZXJQYXJlbnQpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFkZE5vZGVVbmRlclBhcmVudCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImFkZE5vZGVVbmRlclBhcmVudCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIGFkZE5vZGVBdERlcHRoQW5kSW5kZXgoX3JlZjIxKSB7CiAgdmFyIHRhcmdldERlcHRoID0gX3JlZjIxLnRhcmdldERlcHRoLAogICAgICBtaW5pbXVtVHJlZUluZGV4ID0gX3JlZjIxLm1pbmltdW1UcmVlSW5kZXgsCiAgICAgIG5ld05vZGUgPSBfcmVmMjEubmV3Tm9kZSwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjIxLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgZXhwYW5kUGFyZW50ID0gX3JlZjIxLmV4cGFuZFBhcmVudCwKICAgICAgX3JlZjIxJGlzUHNldWRvUm9vdCA9IF9yZWYyMS5pc1BzZXVkb1Jvb3QsCiAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWYyMSRpc1BzZXVkb1Jvb3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIxJGlzUHNldWRvUm9vdCwKICAgICAgaXNMYXN0Q2hpbGQgPSBfcmVmMjEuaXNMYXN0Q2hpbGQsCiAgICAgIG5vZGUgPSBfcmVmMjEubm9kZSwKICAgICAgY3VycmVudEluZGV4ID0gX3JlZjIxLmN1cnJlbnRJbmRleCwKICAgICAgY3VycmVudERlcHRoID0gX3JlZjIxLmN1cnJlbnREZXB0aCwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYyMS5nZXROb2RlS2V5LAogICAgICBfcmVmMjEkcGF0aCA9IF9yZWYyMS5wYXRoLAogICAgICBwYXRoID0gX3JlZjIxJHBhdGggPT09IHZvaWQgMCA/IFtdIDogX3JlZjIxJHBhdGg7CgogIHZhciBzZWxmUGF0aCA9IGZ1bmN0aW9uIHNlbGZQYXRoKG4pIHsKICAgIHJldHVybiBpc1BzZXVkb1Jvb3QgPyBbXSA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksIFtnZXROb2RlS2V5KHsKICAgICAgbm9kZTogbiwKICAgICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgKICAgIH0pXSk7CiAgfTsgLy8gSWYgdGhlIGN1cnJlbnQgcG9zaXRpb24gaXMgdGhlIG9ubHkgcG9zc2libGUgcGxhY2UgdG8gYWRkLCBhZGQgaXQKCgogIGlmIChjdXJyZW50SW5kZXggPj0gbWluaW11bVRyZWVJbmRleCAtIDEgfHwgaXNMYXN0Q2hpbGQgJiYgIShub2RlLmNoaWxkcmVuICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSkgewogICAgaWYgKHR5cGVvZiBub2RlLmNoaWxkcmVuID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiQ2Fubm90IGFkZCB0byBjaGlsZHJlbiBkZWZpbmVkIGJ5IGEgZnVuY3Rpb24iKTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBleHRyYU5vZGVQcm9wcyA9IGV4cGFuZFBhcmVudCA/IHsKICAgICAgICBleHBhbmRlZDogdHJ1ZQogICAgICB9IDoge307CgogICAgICB2YXIgX25leHROb2RlID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSwgZXh0cmFOb2RlUHJvcHMsIHsKICAgICAgICBjaGlsZHJlbjogbm9kZS5jaGlsZHJlbiA/IFtuZXdOb2RlXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4pKSA6IFtuZXdOb2RlXQogICAgICB9KTsKCiAgICAgIHJldHVybiB7CiAgICAgICAgbm9kZTogX25leHROb2RlLAogICAgICAgIG5leHRJbmRleDogY3VycmVudEluZGV4ICsgMiwKICAgICAgICBpbnNlcnRlZFRyZWVJbmRleDogY3VycmVudEluZGV4ICsgMSwKICAgICAgICBwYXJlbnRQYXRoOiBzZWxmUGF0aChfbmV4dE5vZGUpLAogICAgICAgIHBhcmVudE5vZGU6IGlzUHNldWRvUm9vdCA/IG51bGwgOiBfbmV4dE5vZGUKICAgICAgfTsKICAgIH0KICB9IC8vIElmIHRoaXMgaXMgdGhlIHRhcmdldCBkZXB0aCBmb3IgdGhlIGluc2VydGlvbiwKICAvLyBpLmUuLCB3aGVyZSB0aGUgbmV3Tm9kZSBjYW4gYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgbm9kZSdzIGNoaWxkcmVuCgoKICBpZiAoY3VycmVudERlcHRoID49IHRhcmdldERlcHRoIC0gMSkgewogICAgLy8gU2tpcCBvdmVyIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gb3IgaGlkZGVuIGNoaWxkcmVuCiAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgdHlwZW9mIG5vZGUuY2hpbGRyZW4gPT09ICJmdW5jdGlvbiIgfHwgbm9kZS5leHBhbmRlZCAhPT0gdHJ1ZSAmJiBpZ25vcmVDb2xsYXBzZWQgJiYgIWlzUHNldWRvUm9vdCkgewogICAgICByZXR1cm4gewogICAgICAgIG5vZGU6IG5vZGUsCiAgICAgICAgbmV4dEluZGV4OiBjdXJyZW50SW5kZXggKyAxCiAgICAgIH07CiAgICB9IC8vIFNjYW4gb3ZlciB0aGUgY2hpbGRyZW4gdG8gc2VlIGlmIHRoZXJlJ3MgYSBwbGFjZSBhbW9uZyB0aGVtIHRoYXQgZnVsZmlsbHMKICAgIC8vIHRoZSBtaW5pbXVtVHJlZUluZGV4IHJlcXVpcmVtZW50CgoKICAgIHZhciBfY2hpbGRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7CgogICAgdmFyIF9pbnNlcnRlZFRyZWVJbmRleCA9IG51bGw7CiAgICB2YXIgaW5zZXJ0SW5kZXggPSBudWxsOwoKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkgewogICAgICAvLyBJZiBhIHZhbGlkIGxvY2F0aW9uIGlzIGZvdW5kLCBtYXJrIGl0IGFzIHRoZSBpbnNlcnRpb24gbG9jYXRpb24gYW5kCiAgICAgIC8vIGJyZWFrIG91dCBvZiB0aGUgbG9vcAogICAgICBpZiAoX2NoaWxkSW5kZXggPj0gbWluaW11bVRyZWVJbmRleCkgewogICAgICAgIF9pbnNlcnRlZFRyZWVJbmRleCA9IF9jaGlsZEluZGV4OwogICAgICAgIGluc2VydEluZGV4ID0gaTsKICAgICAgICBicmVhazsKICAgICAgfSAvLyBJbmNyZW1lbnQgdGhlIGluZGV4IGJ5IHRoZSBjaGlsZCBpdHNlbGYgcGx1cyB0aGUgbnVtYmVyIG9mIGRlc2NlbmRhbnRzIGl0IGhhcwoKCiAgICAgIF9jaGlsZEluZGV4ICs9IDEgKyBnZXREZXNjZW5kYW50Q291bnQoewogICAgICAgIG5vZGU6IG5vZGUuY2hpbGRyZW5baV0sCiAgICAgICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQKICAgICAgfSk7CiAgICB9IC8vIElmIG5vIHZhbGlkIGluZGljZXMgdG8gYWRkIHRoZSBub2RlIHdlcmUgZm91bmQKCgogICAgaWYgKGluc2VydEluZGV4ID09PSBudWxsKSB7CiAgICAgIC8vIElmIHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoaXMgbm9kZSdzIGNoaWxkcmVuIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSBpbmRleAogICAgICAvLyBhbmQgdGhlcmUgYXJlIG1vcmUgY2hpbGRyZW4gb24gdGhlIGxldmVsIG9mIHRoaXMgbm9kZSwgcmV0dXJuIHdpdGhvdXQgaW5zZXJ0aW9uCiAgICAgIGlmIChfY2hpbGRJbmRleCA8IG1pbmltdW1UcmVlSW5kZXggJiYgIWlzTGFzdENoaWxkKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIG5vZGU6IG5vZGUsCiAgICAgICAgICBuZXh0SW5kZXg6IF9jaGlsZEluZGV4CiAgICAgICAgfTsKICAgICAgfSAvLyBVc2UgdGhlIGxhc3QgcG9zaXRpb24gaW4gdGhlIGNoaWxkcmVuIGFycmF5IHRvIGluc2VydCB0aGUgbmV3Tm9kZQoKCiAgICAgIF9pbnNlcnRlZFRyZWVJbmRleCA9IF9jaGlsZEluZGV4OwogICAgICBpbnNlcnRJbmRleCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOwogICAgfSAvLyBJbnNlcnQgdGhlIG5ld05vZGUgYXQgdGhlIGluc2VydEluZGV4CgoKICAgIHZhciBfbmV4dE5vZGUyID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSwgewogICAgICBjaGlsZHJlbjogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKDAsIGluc2VydEluZGV4KSksIFtuZXdOb2RlXSwgX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoaW5zZXJ0SW5kZXgpKSkKICAgIH0pOyAvLyBSZXR1cm4gbm9kZSB3aXRoIHN1Y2Nlc3NmdWwgaW5zZXJ0IHJlc3VsdAoKCiAgICByZXR1cm4gewogICAgICBub2RlOiBfbmV4dE5vZGUyLAogICAgICBuZXh0SW5kZXg6IF9jaGlsZEluZGV4LAogICAgICBpbnNlcnRlZFRyZWVJbmRleDogX2luc2VydGVkVHJlZUluZGV4LAogICAgICBwYXJlbnRQYXRoOiBzZWxmUGF0aChfbmV4dE5vZGUyKSwKICAgICAgcGFyZW50Tm9kZTogaXNQc2V1ZG9Sb290ID8gbnVsbCA6IF9uZXh0Tm9kZTIKICAgIH07CiAgfSAvLyBTa2lwIG92ZXIgbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KCgogIGlmICghbm9kZS5jaGlsZHJlbiB8fCB0eXBlb2Ygbm9kZS5jaGlsZHJlbiA9PT0gImZ1bmN0aW9uIiB8fCBub2RlLmV4cGFuZGVkICE9PSB0cnVlICYmIGlnbm9yZUNvbGxhcHNlZCAmJiAhaXNQc2V1ZG9Sb290KSB7CiAgICByZXR1cm4gewogICAgICBub2RlOiBub2RlLAogICAgICBuZXh0SW5kZXg6IGN1cnJlbnRJbmRleCArIDEKICAgIH07CiAgfSAvLyBHZXQgYWxsIGRlc2NlbmRhbnRzCgoKICB2YXIgaW5zZXJ0ZWRUcmVlSW5kZXggPSBudWxsOwogIHZhciBwYXRoRnJhZ21lbnQgPSBudWxsOwogIHZhciBwYXJlbnROb2RlID0gbnVsbDsKICB2YXIgY2hpbGRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7CiAgdmFyIG5ld0NoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjsKCiAgaWYgKHR5cGVvZiBuZXdDaGlsZHJlbiAhPT0gImZ1bmN0aW9uIikgewogICAgbmV3Q2hpbGRyZW4gPSBuZXdDaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpKSB7CiAgICAgIGlmIChpbnNlcnRlZFRyZWVJbmRleCAhPT0gbnVsbCkgewogICAgICAgIHJldHVybiBjaGlsZDsKICAgICAgfQoKICAgICAgdmFyIG1hcFJlc3VsdCA9IGFkZE5vZGVBdERlcHRoQW5kSW5kZXgoewogICAgICAgIHRhcmdldERlcHRoOiB0YXJnZXREZXB0aCwKICAgICAgICBtaW5pbXVtVHJlZUluZGV4OiBtaW5pbXVtVHJlZUluZGV4LAogICAgICAgIG5ld05vZGU6IG5ld05vZGUsCiAgICAgICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICAgICAgZXhwYW5kUGFyZW50OiBleHBhbmRQYXJlbnQsCiAgICAgICAgaXNMYXN0Q2hpbGQ6IGlzTGFzdENoaWxkICYmIGkgPT09IG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEsCiAgICAgICAgbm9kZTogY2hpbGQsCiAgICAgICAgY3VycmVudEluZGV4OiBjaGlsZEluZGV4LAogICAgICAgIGN1cnJlbnREZXB0aDogY3VycmVudERlcHRoICsgMSwKICAgICAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgICAgIHBhdGg6IFtdIC8vIENhbm5vdCBkZXRlcm1pbmUgdGhlIHBhcmVudCBwYXRoIHVudGlsIHRoZSBjaGlsZHJlbiBoYXZlIGJlZW4gcHJvY2Vzc2VkCgogICAgICB9KTsKCiAgICAgIGlmICgiaW5zZXJ0ZWRUcmVlSW5kZXgiIGluIG1hcFJlc3VsdCkgewogICAgICAgIGluc2VydGVkVHJlZUluZGV4ID0gbWFwUmVzdWx0Lmluc2VydGVkVHJlZUluZGV4OwogICAgICAgIHBhcmVudE5vZGUgPSBtYXBSZXN1bHQucGFyZW50Tm9kZTsKICAgICAgICBwYXRoRnJhZ21lbnQgPSBtYXBSZXN1bHQucGFyZW50UGF0aDsKICAgICAgfQoKICAgICAgY2hpbGRJbmRleCA9IG1hcFJlc3VsdC5uZXh0SW5kZXg7CiAgICAgIHJldHVybiBtYXBSZXN1bHQubm9kZTsKICAgIH0pOwogIH0KCiAgdmFyIG5leHROb2RlID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSwgewogICAgY2hpbGRyZW46IG5ld0NoaWxkcmVuCiAgfSk7CgogIHZhciByZXN1bHQgPSB7CiAgICBub2RlOiBuZXh0Tm9kZSwKICAgIG5leHRJbmRleDogY2hpbGRJbmRleAogIH07CgogIGlmIChpbnNlcnRlZFRyZWVJbmRleCAhPT0gbnVsbCkgewogICAgcmVzdWx0Lmluc2VydGVkVHJlZUluZGV4ID0gaW5zZXJ0ZWRUcmVlSW5kZXg7CiAgICByZXN1bHQucGFyZW50UGF0aCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc2VsZlBhdGgobmV4dE5vZGUpKSwgX3RvQ29uc3VtYWJsZUFycmF5KHBhdGhGcmFnbWVudCkpOwogICAgcmVzdWx0LnBhcmVudE5vZGUgPSBwYXJlbnROb2RlOwogIH0KCiAgcmV0dXJuIHJlc3VsdDsKfQovKioNCiAqIEluc2VydCBhIG5vZGUgaW50byB0aGUgdHJlZSBhdCB0aGUgZ2l2ZW4gZGVwdGgsIGFmdGVyIHRoZSBtaW5pbXVtIGluZGV4DQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFudW1iZXJ9IGRlcHRoIC0gVGhlIGRlcHRoIHRvIGluc2VydCB0aGUgbm9kZSBhdCAodGhlIGZpcnN0IGxldmVsIG9mIHRoZSBhcnJheSBiZWluZyBkZXB0aCAwKQ0KICogQHBhcmFtIHshbnVtYmVyfSBtaW5pbXVtVHJlZUluZGV4IC0gVGhlIGxvd2VzdCBwb3NzaWJsZSB0cmVlSW5kZXggdG8gaW5zZXJ0IHRoZSBub2RlIGF0DQogKiBAcGFyYW0geyFPYmplY3R9IG5ld05vZGUgLSBUaGUgbm9kZSB0byBpbnNlcnQgaW50byB0aGUgdHJlZQ0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRQYXJlbnQgLSBJZiB0cnVlLCBleHBhbmRzIHRoZSBwYXJlbnQgb2YgdGhlIGluc2VydGVkIG5vZGUNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdA0KICogQHJldHVybiB7T2JqZWN0W119IHJlc3VsdC50cmVlRGF0YSAtIFRoZSB0cmVlIGRhdGEgd2l0aCB0aGUgbm9kZSBhZGRlZA0KICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQudHJlZUluZGV4IC0gVGhlIHRyZWUgaW5kZXggYXQgd2hpY2ggdGhlIG5vZGUgd2FzIGluc2VydGVkDQogKiBAcmV0dXJuIHtudW1iZXJbXXxzdHJpbmdbXX0gcmVzdWx0LnBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdG8gdGhlIG5vZGUgbG9jYXRpb24gYWZ0ZXIgaW5zZXJ0aW9uDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdC5wYXJlbnROb2RlIC0gVGhlIHBhcmVudCBub2RlIG9mIHRoZSBpbnNlcnRlZCBub2RlDQogKi8KCgpleHBvcnQgZnVuY3Rpb24gaW5zZXJ0Tm9kZShfcmVmMjIpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmMjIudHJlZURhdGEsCiAgICAgIHRhcmdldERlcHRoID0gX3JlZjIyLmRlcHRoLAogICAgICBtaW5pbXVtVHJlZUluZGV4ID0gX3JlZjIyLm1pbmltdW1UcmVlSW5kZXgsCiAgICAgIG5ld05vZGUgPSBfcmVmMjIubmV3Tm9kZSwKICAgICAgX3JlZjIyJGdldE5vZGVLZXkgPSBfcmVmMjIuZ2V0Tm9kZUtleSwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYyMiRnZXROb2RlS2V5ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF9yZWYyMiRnZXROb2RlS2V5LAogICAgICBfcmVmMjIkaWdub3JlQ29sbGFwc2UgPSBfcmVmMjIuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMjIkaWdub3JlQ29sbGFwc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMjIkaWdub3JlQ29sbGFwc2UsCiAgICAgIF9yZWYyMiRleHBhbmRQYXJlbnQgPSBfcmVmMjIuZXhwYW5kUGFyZW50LAogICAgICBleHBhbmRQYXJlbnQgPSBfcmVmMjIkZXhwYW5kUGFyZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyMiRleHBhbmRQYXJlbnQ7CgogIGlmICghdHJlZURhdGEgJiYgdGFyZ2V0RGVwdGggPT09IDApIHsKICAgIHJldHVybiB7CiAgICAgIHRyZWVEYXRhOiBbbmV3Tm9kZV0sCiAgICAgIHRyZWVJbmRleDogMCwKICAgICAgcGF0aDogW2dldE5vZGVLZXkoewogICAgICAgIG5vZGU6IG5ld05vZGUsCiAgICAgICAgdHJlZUluZGV4OiAwCiAgICAgIH0pXSwKICAgICAgcGFyZW50Tm9kZTogbnVsbAogICAgfTsKICB9CgogIHZhciBpbnNlcnRSZXN1bHQgPSBhZGROb2RlQXREZXB0aEFuZEluZGV4KHsKICAgIHRhcmdldERlcHRoOiB0YXJnZXREZXB0aCwKICAgIG1pbmltdW1UcmVlSW5kZXg6IG1pbmltdW1UcmVlSW5kZXgsCiAgICBuZXdOb2RlOiBuZXdOb2RlLAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBleHBhbmRQYXJlbnQ6IGV4cGFuZFBhcmVudCwKICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICBpc1BzZXVkb1Jvb3Q6IHRydWUsCiAgICBpc0xhc3RDaGlsZDogdHJ1ZSwKICAgIG5vZGU6IHsKICAgICAgY2hpbGRyZW46IHRyZWVEYXRhCiAgICB9LAogICAgY3VycmVudEluZGV4OiAtMSwKICAgIGN1cnJlbnREZXB0aDogLTEKICB9KTsKCiAgaWYgKCEoImluc2VydGVkVHJlZUluZGV4IiBpbiBpbnNlcnRSZXN1bHQpKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIk5vIHN1aXRhYmxlIHBvc2l0aW9uIGZvdW5kIHRvIGluc2VydC4iKTsKICB9CgogIHZhciB0cmVlSW5kZXggPSBpbnNlcnRSZXN1bHQuaW5zZXJ0ZWRUcmVlSW5kZXg7CiAgcmV0dXJuIHsKICAgIHRyZWVEYXRhOiBpbnNlcnRSZXN1bHQubm9kZS5jaGlsZHJlbiwKICAgIHRyZWVJbmRleDogdHJlZUluZGV4LAogICAgcGF0aDogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShpbnNlcnRSZXN1bHQucGFyZW50UGF0aCksIFtnZXROb2RlS2V5KHsKICAgICAgbm9kZTogbmV3Tm9kZSwKICAgICAgdHJlZUluZGV4OiB0cmVlSW5kZXgKICAgIH0pXSksCiAgICBwYXJlbnROb2RlOiBpbnNlcnRSZXN1bHQucGFyZW50Tm9kZQogIH07Cn0KLyoqDQogKiBHZXQgdHJlZSBkYXRhIGZsYXR0ZW5lZC4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGEgLSBUcmVlIGRhdGENCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge3sNCiAqICAgICAgbm9kZTogT2JqZWN0LA0KICogICAgICBwYXRoOiBbXXN0cmluZ3xbXW51bWJlciwNCiAqICAgICAgbG93ZXJTaWJsaW5nQ291bnRzOiBbXW51bWJlcg0KICogIH19W10gbm9kZXMgLSBUaGUgbm9kZSBhcnJheQ0KICovCgppZiAodHlwZW9mIGluc2VydE5vZGUgIT09ICd1bmRlZmluZWQnICYmIGluc2VydE5vZGUgJiYgaW5zZXJ0Tm9kZSA9PT0gT2JqZWN0KGluc2VydE5vZGUpICYmIE9iamVjdC5pc0V4dGVuc2libGUoaW5zZXJ0Tm9kZSkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zZXJ0Tm9kZSwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImluc2VydE5vZGUiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gZ2V0RmxhdERhdGFGcm9tVHJlZShfcmVmMjMpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmMjMudHJlZURhdGEsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMjMuZ2V0Tm9kZUtleSwKICAgICAgX3JlZjIzJGlnbm9yZUNvbGxhcHNlID0gX3JlZjIzLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjIzJGlnbm9yZUNvbGxhcHNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIzJGlnbm9yZUNvbGxhcHNlOwoKICBpZiAoIXRyZWVEYXRhIHx8IHRyZWVEYXRhLmxlbmd0aCA8IDEpIHsKICAgIHJldHVybiBbXTsKICB9CgogIHZhciBmbGF0dGVuZWQgPSBbXTsKICB3YWxrKHsKICAgIHRyZWVEYXRhOiB0cmVlRGF0YSwKICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgIGNhbGxiYWNrOiBmdW5jdGlvbiBjYWxsYmFjayhub2RlSW5mbykgewogICAgICBmbGF0dGVuZWQucHVzaChub2RlSW5mbyk7CiAgICB9CiAgfSk7CiAgcmV0dXJuIGZsYXR0ZW5lZDsKfQovKioNCiAqIEdlbmVyYXRlIGEgdHJlZSBzdHJ1Y3R1cmUgZnJvbSBmbGF0IGRhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IGZsYXREYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbj19IGdldEtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbj19IGdldFBhcmVudEtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUgcGFyZW50IGtleSBmcm9tIHRoZSBub2RlRGF0YQ0KICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyPX0gcm9vdEtleSAtIFRoZSB2YWx1ZSByZXR1cm5lZCBieSBgZ2V0UGFyZW50S2V5YCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSByb290IG5vZGUuDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGb3IgZXhhbXBsZSwgaWYgeW91ciBub2RlcyBoYXZlIGlkIDEtOTksIHlvdSBtaWdodCB1c2Ugcm9vdEtleSA9IDANCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gdHJlZURhdGEgLSBUaGUgZmxhdCBkYXRhIHJlcHJlc2VudGVkIGFzIGEgdHJlZQ0KICovCgppZiAodHlwZW9mIGdldEZsYXREYXRhRnJvbVRyZWUgIT09ICd1bmRlZmluZWQnICYmIGdldEZsYXREYXRhRnJvbVRyZWUgJiYgZ2V0RmxhdERhdGFGcm9tVHJlZSA9PT0gT2JqZWN0KGdldEZsYXREYXRhRnJvbVRyZWUpICYmIE9iamVjdC5pc0V4dGVuc2libGUoZ2V0RmxhdERhdGFGcm9tVHJlZSkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0RmxhdERhdGFGcm9tVHJlZSwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImdldEZsYXREYXRhRnJvbVRyZWUiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gZ2V0VHJlZUZyb21GbGF0RGF0YShfcmVmMjQpIHsKICB2YXIgZmxhdERhdGEgPSBfcmVmMjQuZmxhdERhdGEsCiAgICAgIF9yZWYyNCRnZXRLZXkgPSBfcmVmMjQuZ2V0S2V5LAogICAgICBnZXRLZXkgPSBfcmVmMjQkZ2V0S2V5ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobm9kZSkgewogICAgcmV0dXJuIG5vZGUuaWQ7CiAgfSA6IF9yZWYyNCRnZXRLZXksCiAgICAgIF9yZWYyNCRnZXRQYXJlbnRLZXkgPSBfcmVmMjQuZ2V0UGFyZW50S2V5LAogICAgICBnZXRQYXJlbnRLZXkgPSBfcmVmMjQkZ2V0UGFyZW50S2V5ID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobm9kZSkgewogICAgcmV0dXJuIG5vZGUucGFyZW50SWQ7CiAgfSA6IF9yZWYyNCRnZXRQYXJlbnRLZXksCiAgICAgIF9yZWYyNCRyb290S2V5ID0gX3JlZjI0LnJvb3RLZXksCiAgICAgIHJvb3RLZXkgPSBfcmVmMjQkcm9vdEtleSA9PT0gdm9pZCAwID8gIjAiIDogX3JlZjI0JHJvb3RLZXk7CgogIGlmICghZmxhdERhdGEpIHsKICAgIHJldHVybiBbXTsKICB9CgogIHZhciBjaGlsZHJlblRvUGFyZW50cyA9IHt9OwogIGZsYXREYXRhLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7CiAgICB2YXIgcGFyZW50S2V5ID0gZ2V0UGFyZW50S2V5KGNoaWxkKTsKCiAgICBpZiAocGFyZW50S2V5IGluIGNoaWxkcmVuVG9QYXJlbnRzKSB7CiAgICAgIGNoaWxkcmVuVG9QYXJlbnRzW3BhcmVudEtleV0ucHVzaChjaGlsZCk7CiAgICB9IGVsc2UgewogICAgICBjaGlsZHJlblRvUGFyZW50c1twYXJlbnRLZXldID0gW2NoaWxkXTsKICAgIH0KICB9KTsKCiAgaWYgKCEocm9vdEtleSBpbiBjaGlsZHJlblRvUGFyZW50cykpIHsKICAgIHJldHVybiBbXTsKICB9CgogIHZhciB0cmF2ID0gZnVuY3Rpb24gdHJhdihwYXJlbnQpIHsKICAgIHZhciBwYXJlbnRLZXkgPSBnZXRLZXkocGFyZW50KTsKCiAgICBpZiAocGFyZW50S2V5IGluIGNoaWxkcmVuVG9QYXJlbnRzKSB7CiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnQsIHsKICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5Ub1BhcmVudHNbcGFyZW50S2V5XS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7CiAgICAgICAgICByZXR1cm4gdHJhdihjaGlsZCk7CiAgICAgICAgfSkKICAgICAgfSk7CiAgICB9CgogICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHBhcmVudCk7CiAgfTsKCiAgcmV0dXJuIGNoaWxkcmVuVG9QYXJlbnRzW3Jvb3RLZXldLm1hcChmdW5jdGlvbiAoY2hpbGQpIHsKICAgIHJldHVybiB0cmF2KGNoaWxkKTsKICB9KTsKfQovKioNCiAqIENoZWNrIGlmIGEgbm9kZSBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlciBub2RlLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdH0gb2xkZXIgLSBQb3RlbnRpYWwgYW5jZXN0b3Igb2YgeW91bmdlciBub2RlDQogKiBAcGFyYW0geyFPYmplY3R9IHlvdW5nZXIgLSBQb3RlbnRpYWwgZGVzY2VuZGFudCBvZiBvbGRlciBub2RlDQogKg0KICogQHJldHVybiB7Ym9vbGVhbn0NCiAqLwoKaWYgKHR5cGVvZiBnZXRUcmVlRnJvbUZsYXREYXRhICE9PSAndW5kZWZpbmVkJyAmJiBnZXRUcmVlRnJvbUZsYXREYXRhICYmIGdldFRyZWVGcm9tRmxhdERhdGEgPT09IE9iamVjdChnZXRUcmVlRnJvbUZsYXREYXRhKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldFRyZWVGcm9tRmxhdERhdGEpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldFRyZWVGcm9tRmxhdERhdGEsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXRUcmVlRnJvbUZsYXREYXRhIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGlzRGVzY2VuZGFudChvbGRlciwgeW91bmdlcikgewogIHJldHVybiAhIW9sZGVyLmNoaWxkcmVuICYmIHR5cGVvZiBvbGRlci5jaGlsZHJlbiAhPT0gImZ1bmN0aW9uIiAmJiBvbGRlci5jaGlsZHJlbi5zb21lKGZ1bmN0aW9uIChjaGlsZCkgewogICAgcmV0dXJuIGNoaWxkID09PSB5b3VuZ2VyIHx8IGlzRGVzY2VuZGFudChjaGlsZCwgeW91bmdlcik7CiAgfSk7Cn0KLyoqDQogKiBHZXQgdGhlIG1heGltdW0gZGVwdGggb2YgdGhlIGNoaWxkcmVuICh0aGUgZGVwdGggb2YgdGhlIHJvb3Qgbm9kZSBpcyAwKS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3R9IG5vZGUgLSBOb2RlIGluIHRoZSB0cmVlDQogKiBAcGFyYW0gez9udW1iZXJ9IGRlcHRoIC0gVGhlIGN1cnJlbnQgZGVwdGgNCiAqDQogKiBAcmV0dXJuIHtudW1iZXJ9IG1heERlcHRoIC0gVGhlIGRlZXBlc3QgZGVwdGggaW4gdGhlIHRyZWUNCiAqLwoKaWYgKHR5cGVvZiBpc0Rlc2NlbmRhbnQgIT09ICd1bmRlZmluZWQnICYmIGlzRGVzY2VuZGFudCAmJiBpc0Rlc2NlbmRhbnQgPT09IE9iamVjdChpc0Rlc2NlbmRhbnQpICYmIE9iamVjdC5pc0V4dGVuc2libGUoaXNEZXNjZW5kYW50KSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpc0Rlc2NlbmRhbnQsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJpc0Rlc2NlbmRhbnQiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gZ2V0RGVwdGgobm9kZSkgewogIHZhciBkZXB0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDsKCiAgaWYgKCFub2RlLmNoaWxkcmVuKSB7CiAgICByZXR1cm4gZGVwdGg7CiAgfQoKICBpZiAodHlwZW9mIG5vZGUuY2hpbGRyZW4gPT09ICJmdW5jdGlvbiIpIHsKICAgIHJldHVybiBkZXB0aCArIDE7CiAgfQoKICByZXR1cm4gbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKGRlZXBlc3QsIGNoaWxkKSB7CiAgICByZXR1cm4gTWF0aC5tYXgoZGVlcGVzdCwgZ2V0RGVwdGgoY2hpbGQsIGRlcHRoICsgMSkpOwogIH0sIGRlcHRoKTsKfQovKioNCiAqIEZpbmQgbm9kZXMgbWF0Y2hpbmcgYSBzZWFyY2ggcXVlcnkgaW4gdGhlIHRyZWUsDQogKg0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0gez9zdHJpbmd8bnVtYmVyfSBzZWFyY2hRdWVyeSAtIEZ1bmN0aW9uIHJldHVybmluZyBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgbm9kZSBpcyBhIG1hdGNoIG9yIG5vdA0KICogQHBhcmFtIHshZnVuY3Rpb259IHNlYXJjaE1ldGhvZCAtIEZ1bmN0aW9uIHJldHVybmluZyBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgbm9kZSBpcyBhIG1hdGNoIG9yIG5vdA0KICogQHBhcmFtIHs/bnVtYmVyfSBzZWFyY2hGb2N1c09mZnNldCAtIFRoZSBvZmZzZXQgb2YgdGhlIG1hdGNoIHRvIGZvY3VzIG9uDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGUuZy4sIDAgZm9jdXNlcyBvbiB0aGUgZmlyc3QgbWF0Y2gsIDEgb24gdGhlIHNlY29uZCkNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4cGFuZEFsbE1hdGNoUGF0aHMgLSBJZiB0cnVlLCBleHBhbmRzIHRoZSBwYXRocyB0byBhbnkgbWF0Y2hlZCBub2RlDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRGb2N1c01hdGNoUGF0aHMgLSBJZiB0cnVlLCBleHBhbmRzIHRoZSBwYXRoIHRvIHRoZSBmb2N1c2VkIG5vZGUNCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gbWF0Y2hlcyAtIEFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgbWF0Y2hpbmcgYG5vZGVgcywgdGhlaXIgYHBhdGhgcyBhbmQgYHRyZWVJbmRleGBzDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gdHJlZURhdGEgLSBUaGUgb3JpZ2luYWwgdHJlZSBkYXRhIHdpdGggYWxsIHJlbGV2YW50IG5vZGVzIGV4cGFuZGVkLg0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgZXhwYW5kQWxsTWF0Y2hQYXRocyBhbmQgZXhwYW5kRm9jdXNNYXRjaFBhdGhzIGFyZSBib3RoIGZhbHNlLA0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luYWwgdHJlZSBkYXRhLg0KICovCgppZiAodHlwZW9mIGdldERlcHRoICE9PSAndW5kZWZpbmVkJyAmJiBnZXREZXB0aCAmJiBnZXREZXB0aCA9PT0gT2JqZWN0KGdldERlcHRoKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldERlcHRoKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXREZXB0aCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImdldERlcHRoIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGZpbmQoX3JlZjI1KSB7CiAgdmFyIGdldE5vZGVLZXkgPSBfcmVmMjUuZ2V0Tm9kZUtleSwKICAgICAgdHJlZURhdGEgPSBfcmVmMjUudHJlZURhdGEsCiAgICAgIHNlYXJjaFF1ZXJ5ID0gX3JlZjI1LnNlYXJjaFF1ZXJ5LAogICAgICBzZWFyY2hNZXRob2QgPSBfcmVmMjUuc2VhcmNoTWV0aG9kLAogICAgICBzZWFyY2hGb2N1c09mZnNldCA9IF9yZWYyNS5zZWFyY2hGb2N1c09mZnNldCwKICAgICAgX3JlZjI1JGV4cGFuZEFsbE1hdGNoID0gX3JlZjI1LmV4cGFuZEFsbE1hdGNoUGF0aHMsCiAgICAgIGV4cGFuZEFsbE1hdGNoUGF0aHMgPSBfcmVmMjUkZXhwYW5kQWxsTWF0Y2ggPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjI1JGV4cGFuZEFsbE1hdGNoLAogICAgICBfcmVmMjUkZXhwYW5kRm9jdXNNYXQgPSBfcmVmMjUuZXhwYW5kRm9jdXNNYXRjaFBhdGhzLAogICAgICBleHBhbmRGb2N1c01hdGNoUGF0aHMgPSBfcmVmMjUkZXhwYW5kRm9jdXNNYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMjUkZXhwYW5kRm9jdXNNYXQ7CiAgdmFyIG1hdGNoQ291bnQgPSAwOwoKICB2YXIgdHJhdiA9IGZ1bmN0aW9uIHRyYXYoX3JlZjI2KSB7CiAgICB2YXIgX3JlZjI2JGlzUHNldWRvUm9vdCA9IF9yZWYyNi5pc1BzZXVkb1Jvb3QsCiAgICAgICAgaXNQc2V1ZG9Sb290ID0gX3JlZjI2JGlzUHNldWRvUm9vdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMjYkaXNQc2V1ZG9Sb290LAogICAgICAgIG5vZGUgPSBfcmVmMjYubm9kZSwKICAgICAgICBjdXJyZW50SW5kZXggPSBfcmVmMjYuY3VycmVudEluZGV4LAogICAgICAgIF9yZWYyNiRwYXRoID0gX3JlZjI2LnBhdGgsCiAgICAgICAgcGF0aCA9IF9yZWYyNiRwYXRoID09PSB2b2lkIDAgPyBbXSA6IF9yZWYyNiRwYXRoOwogICAgdmFyIG1hdGNoZXMgPSBbXTsKICAgIHZhciBpc1NlbGZNYXRjaCA9IGZhbHNlOwogICAgdmFyIGhhc0ZvY3VzTWF0Y2ggPSBmYWxzZTsgLy8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCgogICAgdmFyIHNlbGZQYXRoID0gaXNQc2V1ZG9Sb290ID8gW10gOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpLCBbZ2V0Tm9kZUtleSh7CiAgICAgIG5vZGU6IG5vZGUsCiAgICAgIHRyZWVJbmRleDogY3VycmVudEluZGV4CiAgICB9KV0pOwogICAgdmFyIGV4dHJhSW5mbyA9IGlzUHNldWRvUm9vdCA/IG51bGwgOiB7CiAgICAgIHBhdGg6IHNlbGZQYXRoLAogICAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogICAgfTsgLy8gTm9kZXMgd2l0aCB3aXRoIGNoaWxkcmVuIHRoYXQgYXJlbid0IGxhenkKCiAgICB2YXIgaGFzQ2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuICYmIHR5cGVvZiBub2RlLmNoaWxkcmVuICE9PSAiZnVuY3Rpb24iICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMDsgLy8gRXhhbWluZSB0aGUgY3VycmVudCBub2RlIHRvIHNlZSBpZiBpdCBpcyBhIG1hdGNoCgogICAgaWYgKCFpc1BzZXVkb1Jvb3QgJiYgc2VhcmNoTWV0aG9kKF9vYmplY3RTcHJlYWQoe30sIGV4dHJhSW5mbywgewogICAgICBub2RlOiBub2RlLAogICAgICBzZWFyY2hRdWVyeTogc2VhcmNoUXVlcnkKICAgIH0pKSkgewogICAgICBpZiAobWF0Y2hDb3VudCA9PT0gc2VhcmNoRm9jdXNPZmZzZXQpIHsKICAgICAgICBoYXNGb2N1c01hdGNoID0gdHJ1ZTsKICAgICAgfSAvLyBLZWVwIHRyYWNrIG9mIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgbm9kZXMsIHNvIHdlIGtub3cgd2hlbiB0aGUgc2VhcmNoRm9jdXNPZmZzZXQKICAgICAgLy8gIGlzIHJlYWNoZWQKCgogICAgICBtYXRjaENvdW50ICs9IDE7IC8vIFdlIGNhbm5vdCBhZGQgdGhpcyBub2RlIHRvIHRoZSBtYXRjaGVzIHJpZ2h0IGF3YXksIGFzIGl0IG1heSBiZSBjaGFuZ2VkCiAgICAgIC8vICBkdXJpbmcgdGhlIHNlYXJjaCBvZiB0aGUgZGVzY2VuZGFudHMuIFRoZSBlbnRpcmUgbm9kZSBpcyB1c2VkIGluCiAgICAgIC8vICBjb21wYXJpc29ucyBiZXR3ZWVuIG5vZGVzIGluc2lkZSB0aGUgYG1hdGNoZXNgIGFuZCBgdHJlZURhdGFgIHJlc3VsdHMKICAgICAgLy8gIG9mIHRoaXMgbWV0aG9kIChgZmluZGApCgogICAgICBpc1NlbGZNYXRjaCA9IHRydWU7CiAgICB9CgogICAgdmFyIGNoaWxkSW5kZXggPSBjdXJyZW50SW5kZXg7CgogICAgdmFyIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBub2RlKTsKCiAgICBpZiAoaGFzQ2hpbGRyZW4pIHsKICAgICAgLy8gR2V0IGFsbCBkZXNjZW5kYW50cwogICAgICBuZXdOb2RlLmNoaWxkcmVuID0gbmV3Tm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7CiAgICAgICAgdmFyIG1hcFJlc3VsdCA9IHRyYXYoewogICAgICAgICAgbm9kZTogY2hpbGQsCiAgICAgICAgICBjdXJyZW50SW5kZXg6IGNoaWxkSW5kZXggKyAxLAogICAgICAgICAgcGF0aDogc2VsZlBhdGgKICAgICAgICB9KTsgLy8gSWdub3JlIGhpZGRlbiBub2RlcyBieSBvbmx5IGFkdmFuY2luZyB0aGUgaW5kZXggY291bnRlciB0byB0aGUgcmV0dXJuZWQgdHJlZUluZGV4CiAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGlzIGV4cGFuZGVkLgogICAgICAgIC8vCiAgICAgICAgLy8gVGhlIGNoaWxkIGNvdWxkIGhhdmUgYmVlbiBleHBhbmRlZCBmcm9tIHRoZSBzdGFydCwKICAgICAgICAvLyBvciBleHBhbmRlZCBkdWUgdG8gYSBtYXRjaGluZyBub2RlIGJlaW5nIGZvdW5kIGluIGl0cyBkZXNjZW5kYW50cwoKICAgICAgICBpZiAobWFwUmVzdWx0Lm5vZGUuZXhwYW5kZWQpIHsKICAgICAgICAgIGNoaWxkSW5kZXggPSBtYXBSZXN1bHQudHJlZUluZGV4OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjaGlsZEluZGV4ICs9IDE7CiAgICAgICAgfQoKICAgICAgICBpZiAobWFwUmVzdWx0Lm1hdGNoZXMubGVuZ3RoID4gMCB8fCBtYXBSZXN1bHQuaGFzRm9jdXNNYXRjaCkgewogICAgICAgICAgbWF0Y2hlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobWF0Y2hlcyksIF90b0NvbnN1bWFibGVBcnJheShtYXBSZXN1bHQubWF0Y2hlcykpOwoKICAgICAgICAgIGlmIChtYXBSZXN1bHQuaGFzRm9jdXNNYXRjaCkgewogICAgICAgICAgICBoYXNGb2N1c01hdGNoID0gdHJ1ZTsKICAgICAgICAgIH0gLy8gRXhwYW5kIHRoZSBjdXJyZW50IG5vZGUgaWYgaXQgaGFzIGRlc2NlbmRhbnRzIG1hdGNoaW5nIHRoZSBzZWFyY2gKICAgICAgICAgIC8vIGFuZCB0aGUgc2V0dGluZ3MgYXJlIHNldCB0byBkbyBzby4KCgogICAgICAgICAgaWYgKGV4cGFuZEFsbE1hdGNoUGF0aHMgJiYgbWFwUmVzdWx0Lm1hdGNoZXMubGVuZ3RoID4gMCB8fCAoZXhwYW5kQWxsTWF0Y2hQYXRocyB8fCBleHBhbmRGb2N1c01hdGNoUGF0aHMpICYmIG1hcFJlc3VsdC5oYXNGb2N1c01hdGNoKSB7CiAgICAgICAgICAgIG5ld05vZGUuZXhwYW5kZWQgPSB0cnVlOwogICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5ub2RlOwogICAgICB9KTsKICAgIH0gLy8gQ2Fubm90IGFzc2lnbiBhIHRyZWVJbmRleCB0byBoaWRkZW4gbm9kZXMKCgogICAgaWYgKCFpc1BzZXVkb1Jvb3QgJiYgIW5ld05vZGUuZXhwYW5kZWQpIHsKICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkgewogICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBtYXRjaCwgewogICAgICAgICAgdHJlZUluZGV4OiBudWxsCiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfSAvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBtYXRjaGVzIGlmIGl0IGZpdHMgdGhlIHNlYXJjaCBjcml0ZXJpYS4KICAgIC8vIFRoaXMgaXMgcGVyZm9ybWVkIGF0IHRoZSBsYXN0IG1pbnV0ZSBzbyBuZXdOb2RlIGNhbiBiZSBzZW50IGluIGl0cyBmaW5hbCBmb3JtLgoKCiAgICBpZiAoaXNTZWxmTWF0Y2gpIHsKICAgICAgbWF0Y2hlcyA9IFtfb2JqZWN0U3ByZWFkKHt9LCBleHRyYUluZm8sIHsKICAgICAgICBub2RlOiBuZXdOb2RlCiAgICAgIH0pXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1hdGNoZXMpKTsKICAgIH0KCiAgICByZXR1cm4gewogICAgICBub2RlOiBtYXRjaGVzLmxlbmd0aCA+IDAgPyBuZXdOb2RlIDogbm9kZSwKICAgICAgbWF0Y2hlczogbWF0Y2hlcywKICAgICAgaGFzRm9jdXNNYXRjaDogaGFzRm9jdXNNYXRjaCwKICAgICAgdHJlZUluZGV4OiBjaGlsZEluZGV4CiAgICB9OwogIH07CgogIHZhciByZXN1bHQgPSB0cmF2KHsKICAgIG5vZGU6IHsKICAgICAgY2hpbGRyZW46IHRyZWVEYXRhCiAgICB9LAogICAgaXNQc2V1ZG9Sb290OiB0cnVlLAogICAgY3VycmVudEluZGV4OiAtMQogIH0pOwogIHJldHVybiB7CiAgICBtYXRjaGVzOiByZXN1bHQubWF0Y2hlcywKICAgIHRyZWVEYXRhOiByZXN1bHQubm9kZS5jaGlsZHJlbgogIH07Cn0KCmlmICh0eXBlb2YgZmluZCAhPT0gJ3VuZGVmaW5lZCcgJiYgZmluZCAmJiBmaW5kID09PSBPYmplY3QoZmluZCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShmaW5kKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaW5kLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZmluZCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiB0cmVlVG9MaXN0KGFycikgewogIHZhciB0cmVlTGlzdCA9IGFyciB8fCBbXTsgLy/mnKvnuqfoioLngrkKCiAgdmFyIGxlYWZzID0gW107IC8v5qC5CgogIHZhciByb290cyA9IFtdOyAvL+aJgOacieiKgueCuQoKICB2YXIgbGlzdCA9IFtdOwoKICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWVMaXN0Lmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgZCA9IHRyZWVMaXN0W2ldOwoKICAgIGlmICghZCkgewogICAgICBjb250aW51ZTsKICAgIH0KCiAgICB2YXIgY2hpbGRyZW5zID0gZC5jaGlsZHJlbiB8fCBbXTsKICAgIGQuX19kZXB0aCA9IDA7CiAgICBsaXN0LnB1c2goZCk7CiAgICByb290cy5wdXNoKGQpOwoKICAgIGlmIChjaGlsZHJlbnMubGVuZ3RoID4gMCkgewogICAgICBnZXRDaGlsZHJlbihkLCAwKTsKICAgIH0gZWxzZSB7CiAgICAgIGxlYWZzLnB1c2goZCk7CiAgICB9CiAgfQoKICBmdW5jdGlvbiBnZXRDaGlsZHJlbihkLCBkZXB0aCkgewogICAgdmFyIHRlbXBBcnIgPSBkLmNoaWxkcmVuIHx8IFtdOwoKICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0ZW1wQXJyLmxlbmd0aDsgX2krKykgewogICAgICB2YXIgX2QgPSB0ZW1wQXJyW19pXTsKCiAgICAgIHZhciBfY2hpbGRyZW5zID0gX2QuY2hpbGRyZW4gfHwgW107CgogICAgICBfZC5fX2RlcHRoID0gZGVwdGggKyAxOwogICAgICBsaXN0LnB1c2goX2QpOwoKICAgICAgaWYgKF9jaGlsZHJlbnMubGVuZ3RoID4gMCkgewogICAgICAgIGdldENoaWxkcmVuKF9kLCBkZXB0aCArIDEpOwogICAgICB9IGVsc2UgewogICAgICAgIGxlYWZzLnB1c2goX2QpOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gewogICAgbGlzdDogbGlzdCwKICAgIGxlYWZzOiBsZWFmcywKICAgIHJvb3RzOiByb290cwogIH07Cn0KCmlmICh0eXBlb2YgdHJlZVRvTGlzdCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHJlZVRvTGlzdCAmJiB0cmVlVG9MaXN0ID09PSBPYmplY3QodHJlZVRvTGlzdCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh0cmVlVG9MaXN0KSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0cmVlVG9MaXN0LCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAidHJlZVRvTGlzdCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhTGlzdFdpdGhFeHBhbmRlZChsaXN0KSB7CiAgdmFyIGV4cGFuZGVkS2V5cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107CiAgdmFyIHJvd0tleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkOwogIHZhciBhcnIgPSBbXTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgZCA9IGxpc3RbaV07CiAgICBkLl9fZGVwdGggPSAwOwogICAgYXJyLnB1c2goZCk7CgogICAgaWYgKGV4cGFuZGVkS2V5cy5pbmRleE9mKGRbcm93S2V5XSkgPiAtMSkgewogICAgICBpZiAoZC5jaGlsZHJlbikgewogICAgICAgIHNldENoaWxkcmVuKGQsIDApOwogICAgICB9CiAgICB9CiAgfQoKICBmdW5jdGlvbiBzZXRDaGlsZHJlbihjLCBkZXB0aCkgewogICAgdmFyIGNBcnIgPSBjLmNoaWxkcmVuOwoKICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNBcnIubGVuZ3RoOyBfaTIrKykgewogICAgICB2YXIgX2QyID0gY0FycltfaTJdOwogICAgICBfZDIuX19kZXB0aCA9IGRlcHRoICsgMTsKICAgICAgYXJyLnB1c2goX2QyKTsKCiAgICAgIGlmIChleHBhbmRlZEtleXMuaW5kZXhPZihfZDJbcm93S2V5XSkgPiAtMSkgewogICAgICAgIGlmIChfZDIuY2hpbGRyZW4pIHsKICAgICAgICAgIHNldENoaWxkcmVuKF9kMiwgZGVwdGggKyAxKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBhcnI7Cn0KCmlmICh0eXBlb2YgZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQgIT09ICd1bmRlZmluZWQnICYmIGdldERhdGFMaXN0V2l0aEV4cGFuZGVkICYmIGdldERhdGFMaXN0V2l0aEV4cGFuZGVkID09PSBPYmplY3QoZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQpICYmIE9iamVjdC5pc0V4dGVuc2libGUoZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldERhdGFMaXN0V2l0aEV4cGFuZGVkLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7CiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7IC8v5Y+W5b6X5rWP6KeI5Zmo55qEdXNlckFnZW505a2X56ym5LiyCgogIGlmICh1c2VyQWdlbnQuaW5kZXhPZigiQ2hyb21lIikgPiAtMSkgewogICAgcmV0dXJuIDY7CiAgfQoKICB2YXIgb1AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJwIiksCiAgICAgIHN0eWxlcyA9IHsKICAgIHdpZHRoOiAiMTAwcHgiLAogICAgaGVpZ2h0OiAiMTAwcHgiLAogICAgb3ZlcmZsb3dZOiAic2Nyb2xsIgogIH0sCiAgICAgIGksCiAgICAgIHNjcm9sbGJhcldpZHRoOwoKICBmb3IgKGkgaW4gc3R5bGVzKSB7CiAgICBvUC5zdHlsZVtpXSA9IHN0eWxlc1tpXTsKICB9CgogIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob1ApOwogIHNjcm9sbGJhcldpZHRoID0gb1Aub2Zmc2V0V2lkdGggLSBvUC5jbGllbnRXaWR0aDsKICBvUC5yZW1vdmUoKTsKICByZXR1cm4gc2Nyb2xsYmFyV2lkdGg7Cn0KCmlmICh0eXBlb2YgZ2V0U2Nyb2xsYmFyV2lkdGggIT09ICd1bmRlZmluZWQnICYmIGdldFNjcm9sbGJhcldpZHRoICYmIGdldFNjcm9sbGJhcldpZHRoID09PSBPYmplY3QoZ2V0U2Nyb2xsYmFyV2lkdGgpICYmIE9iamVjdC5pc0V4dGVuc2libGUoZ2V0U2Nyb2xsYmFyV2lkdGgpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldFNjcm9sbGJhcldpZHRoLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0U2Nyb2xsYmFyV2lkdGgiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9Cgo7CgooZnVuY3Rpb24gKCkgewogIHZhciByZWFjdEhvdExvYWRlciA9ICh0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwgOiByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykpLmRlZmF1bHQ7CgogIGlmICghcmVhY3RIb3RMb2FkZXIpIHsKICAgIHJldHVybjsKICB9CgogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldE5vZGVEYXRhQXRUcmVlSW5kZXhPck5leHRJbmRleCwgImdldE5vZGVEYXRhQXRUcmVlSW5kZXhPck5leHRJbmRleCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldERlc2NlbmRhbnRDb3VudCwgImdldERlc2NlbmRhbnRDb3VudCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHdhbGtEZXNjZW5kYW50cywgIndhbGtEZXNjZW5kYW50cyIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKG1hcERlc2NlbmRhbnRzLCAibWFwRGVzY2VuZGFudHMiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihnZXRWaXNpYmxlTm9kZUNvdW50LCAiZ2V0VmlzaWJsZU5vZGVDb3VudCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgsICJnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4IiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIod2FsaywgIndhbGsiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihtYXAsICJtYXAiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3Rlcih0b2dnbGVFeHBhbmRlZEZvckFsbCwgInRvZ2dsZUV4cGFuZGVkRm9yQWxsIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoY2hhbmdlTm9kZUF0UGF0aCwgImNoYW5nZU5vZGVBdFBhdGgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihyZW1vdmVOb2RlQXRQYXRoLCAicmVtb3ZlTm9kZUF0UGF0aCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHJlbW92ZU5vZGUsICJyZW1vdmVOb2RlIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0Tm9kZUF0UGF0aCwgImdldE5vZGVBdFBhdGgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihhZGROb2RlVW5kZXJQYXJlbnQsICJhZGROb2RlVW5kZXJQYXJlbnQiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihhZGROb2RlQXREZXB0aEFuZEluZGV4LCAiYWRkTm9kZUF0RGVwdGhBbmRJbmRleCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGluc2VydE5vZGUsICJpbnNlcnROb2RlIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0RmxhdERhdGFGcm9tVHJlZSwgImdldEZsYXREYXRhRnJvbVRyZWUiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihnZXRUcmVlRnJvbUZsYXREYXRhLCAiZ2V0VHJlZUZyb21GbGF0RGF0YSIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGlzRGVzY2VuZGFudCwgImlzRGVzY2VuZGFudCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldERlcHRoLCAiZ2V0RGVwdGgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihmaW5kLCAiZmluZCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHRyZWVUb0xpc3QsICJ0cmVlVG9MaXN0IiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQsICJnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldFNjcm9sbGJhcldpZHRoLCAiZ2V0U2Nyb2xsYmFyV2lkdGgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKfSkoKTsKCjsKCihmdW5jdGlvbiAoKSB7CiAgdmFyIGxlYXZlTW9kdWxlID0gKHR5cGVvZiByZWFjdEhvdExvYWRlckdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyByZWFjdEhvdExvYWRlckdsb2JhbCA6IHJlcXVpcmUoJ3JlYWN0LWhvdC1sb2FkZXInKSkubGVhdmVNb2R1bGU7CiAgbGVhdmVNb2R1bGUgJiYgbGVhdmVNb2R1bGUobW9kdWxlKTsKfSkoKTs="},{"version":3,"sources":["E:\\WebRoot\\tablex\\src\\helper.js"],"names":["getNodeDataAtTreeIndexOrNextIndex","targetIndex","node","currentIndex","getNodeKey","path","lowerSiblingCounts","ignoreCollapsed","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","walkDescendants","callback","parentNode","selfInfo","callbackResult","mapDescendants","nextNode","map","child","mapResult","getVisibleNodeCount","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","index","walk","toggleExpandedForAll","changeNodeAtPath","newNode","RESULT_MISS","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","removeNode","removedNode","removedTreeIndex","nextTreeData","getNodeAtPath","foundNodeInfo","err","addNodeUnderParent","parentKey","expandParent","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","key","addNodeAtDepthAndIndex","targetDepth","minimumTreeIndex","isLastChild","currentDepth","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","depth","insertResult","getFlatDataFromTree","flattened","nodeInfo","push","getTreeFromFlatData","flatData","getKey","id","getParentKey","parentId","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","searchQuery","searchMethod","searchFocusOffset","expandAllMatchPaths","expandFocusMatchPaths","matchCount","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","treeToList","arr","treeList","leafs","roots","list","d","childrens","__depth","getChildren","tempArr","getDataListWithExpanded","expandedKeys","rowKey","indexOf","setChildren","c","cArr","getScrollbarWidth","userAgent","navigator","oP","document","createElement","styles","width","height","overflowY","scrollbarWidth","style","body","appendChild","offsetWidth","clientWidth","remove"],"mappings":"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","sourcesContent":["/**\r\n * Performs a depth-first traversal over all of the node descendants,\r\n * incrementing currentIndex by 1 for each\r\n */\r\nfunction getNodeDataAtTreeIndexOrNextIndex({\r\n  targetIndex,\r\n  node,\r\n  currentIndex,\r\n  getNodeKey,\r\n  path = [],\r\n  lowerSiblingCounts = [],\r\n  ignoreCollapsed = true,\r\n  isPseudoRoot = false\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = !isPseudoRoot\r\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\r\n    : [];\r\n\r\n  // Return target node when found\r\n  if (currentIndex === targetIndex) {\r\n    return {\r\n      node,\r\n      lowerSiblingCounts,\r\n      path: selfPath\r\n    };\r\n  }\r\n\r\n  // Add one and continue for nodes with no children or hidden children\r\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\r\n    return { nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Iterate over each child and their descendants and return the\r\n  // target node if childIndex reaches the targetIndex\r\n  let childIndex = currentIndex + 1;\r\n  const childCount = node.children.length;\r\n  for (let i = 0; i < childCount; i += 1) {\r\n    const result = getNodeDataAtTreeIndexOrNextIndex({\r\n      ignoreCollapsed,\r\n      getNodeKey,\r\n      targetIndex,\r\n      node: node.children[i],\r\n      currentIndex: childIndex,\r\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n      path: selfPath\r\n    });\r\n\r\n    if (result.node) {\r\n      return result;\r\n    }\r\n\r\n    childIndex = result.nextIndex;\r\n  }\r\n\r\n  // If the target node is not found, return the farthest traversed index\r\n  return { nextIndex: childIndex };\r\n}\r\n\r\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\r\n  return (\r\n    getNodeDataAtTreeIndexOrNextIndex({\r\n      getNodeKey: () => {},\r\n      ignoreCollapsed,\r\n      node,\r\n      currentIndex: 0,\r\n      targetIndex: -1\r\n    }).nextIndex - 1\r\n  );\r\n}\r\n\r\n/**\r\n * Walk all descendants of the given node, depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction walkDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n  const selfInfo = isPseudoRoot\r\n    ? null\r\n    : {\r\n        node,\r\n        parentNode,\r\n        path: selfPath,\r\n        lowerSiblingCounts,\r\n        treeIndex: currentIndex\r\n      };\r\n\r\n  if (!isPseudoRoot) {\r\n    const callbackResult = callback(selfInfo);\r\n\r\n    // Cut walk short if the callback returned false\r\n    if (callbackResult === false) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return currentIndex;\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = node.children.length;\r\n  if (typeof node.children !== \"function\") {\r\n    for (let i = 0; i < childCount; i += 1) {\r\n      childIndex = walkDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: node.children[i],\r\n        parentNode: isPseudoRoot ? null : node,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n\r\n      // Cut walk short if the callback returned false\r\n      if (childIndex === false) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return childIndex;\r\n}\r\n\r\n/**\r\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction mapDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  const nextNode = { ...node };\r\n\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\r\n  const selfInfo = {\r\n    node: nextNode,\r\n    parentNode,\r\n    path: selfPath,\r\n    lowerSiblingCounts,\r\n    treeIndex: currentIndex\r\n  };\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !nextNode.children ||\r\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return {\r\n      treeIndex: currentIndex,\r\n      node: callback(selfInfo)\r\n    };\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = nextNode.children.length;\r\n  if (typeof nextNode.children !== \"function\") {\r\n    nextNode.children = nextNode.children.map((child, i) => {\r\n      const mapResult = mapDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: child,\r\n        parentNode: isPseudoRoot ? null : nextNode,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n      childIndex = mapResult.treeIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  return {\r\n    node: callback(selfInfo),\r\n    treeIndex: childIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Count all the visible (expanded) descendants in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n *\r\n * @return {number} count\r\n */\r\nexport function getVisibleNodeCount({ treeData }) {\r\n  const traverse = node => {\r\n    if (\r\n      !node.children ||\r\n      node.expanded !== true ||\r\n      typeof node.children === \"function\"\r\n    ) {\r\n      return 1;\r\n    }\r\n\r\n    return (\r\n      1 +\r\n      node.children.reduce(\r\n        (total, currentNode) => total + traverse(currentNode),\r\n        0\r\n      )\r\n    );\r\n  };\r\n\r\n  return treeData.reduce(\r\n    (total, currentNode) => total + traverse(currentNode),\r\n    0\r\n  );\r\n}\r\n\r\n/**\r\n * Get the <targetIndex>th visible node in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} targetIndex - The index of the node to search for\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }|null} node - The node at targetIndex, or null if not found\r\n */\r\nexport function getVisibleNodeInfoAtIndex({\r\n  treeData,\r\n  index: targetIndex,\r\n  getNodeKey\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return null;\r\n  }\r\n\r\n  // Call the tree traversal with a pseudo-root node\r\n  const result = getNodeDataAtTreeIndexOrNextIndex({\r\n    targetIndex,\r\n    getNodeKey,\r\n    node: {\r\n      children: treeData,\r\n      expanded: true\r\n    },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: [],\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result.node) {\r\n    return result;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Walk descendants depth-first and call a callback on each\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return void\r\n */\r\nexport function walk({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return;\r\n  }\r\n\r\n  walkDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  });\r\n}\r\n\r\n/**\r\n * Perform a depth-first transversal of the descendants and\r\n *  make a change to every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function map({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  return mapDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  }).node.children;\r\n}\r\n\r\n/**\r\n * Expand or close every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?boolean} expanded - Whether the node is expanded or not\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\r\n  return map({\r\n    treeData,\r\n    callback: ({ node }) => ({ ...node, expanded }),\r\n    getNodeKey: ({ treeIndex }) => treeIndex,\r\n    ignoreCollapsed: false\r\n  });\r\n}\r\n\r\n/**\r\n * Replaces node at path with object, or callback-defined object\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function changeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  newNode,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  const RESULT_MISS = \"RESULT_MISS\";\r\n  const traverse = ({\r\n    isPseudoRoot = false,\r\n    node,\r\n    currentTreeIndex,\r\n    pathIndex\r\n  }) => {\r\n    if (\r\n      !isPseudoRoot &&\r\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\r\n    ) {\r\n      return RESULT_MISS;\r\n    }\r\n\r\n    if (pathIndex >= path.length - 1) {\r\n      // If this is the final location in the path, return its changed form\r\n      return typeof newNode === \"function\"\r\n        ? newNode({ node, treeIndex: currentTreeIndex })\r\n        : newNode;\r\n    }\r\n    if (!node.children) {\r\n      // If this node is part of the path, but has no children, return the unchanged node\r\n      throw new Error(\"Path referenced children of node with no children.\");\r\n    }\r\n\r\n    let nextTreeIndex = currentTreeIndex + 1;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      const result = traverse({\r\n        node: node.children[i],\r\n        currentTreeIndex: nextTreeIndex,\r\n        pathIndex: pathIndex + 1\r\n      });\r\n\r\n      // If the result went down the correct path\r\n      if (result !== RESULT_MISS) {\r\n        if (result) {\r\n          // If the result was truthy (in this case, an object),\r\n          //  pass it to the next level of recursion up\r\n          return {\r\n            ...node,\r\n            children: [\r\n              ...node.children.slice(0, i),\r\n              result,\r\n              ...node.children.slice(i + 1)\r\n            ]\r\n          };\r\n        }\r\n        // If the result was falsy (returned from the newNode function), then\r\n        //  delete the node from the array.\r\n        return {\r\n          ...node,\r\n          children: [\r\n            ...node.children.slice(0, i),\r\n            ...node.children.slice(i + 1)\r\n          ]\r\n        };\r\n      }\r\n\r\n      nextTreeIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    return RESULT_MISS;\r\n  };\r\n\r\n  // Use a pseudo-root node in the beginning traversal\r\n  const result = traverse({\r\n    node: { children: treeData },\r\n    currentTreeIndex: -1,\r\n    pathIndex: -1,\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result === RESULT_MISS) {\r\n    throw new Error(\"No node found at the given path.\");\r\n  }\r\n\r\n  return result.children;\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The tree data with the node removed\r\n */\r\nexport function removeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  return changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: null // Delete the node\r\n  });\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node removed\r\n * @return {Object} result.node - The node that was removed\r\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\r\n */\r\nexport function removeNode({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let removedNode = null;\r\n  let removedTreeIndex = null;\r\n  const nextTreeData = changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: ({ node, treeIndex }) => {\r\n      // Store the target node and delete it from the tree\r\n      removedNode = node;\r\n      removedTreeIndex = treeIndex;\r\n\r\n      return null;\r\n    }\r\n  });\r\n\r\n  return {\r\n    treeData: nextTreeData,\r\n    node: removedNode,\r\n    treeIndex: removedTreeIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the node at the specified path\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n */\r\nexport function getNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let foundNodeInfo = null;\r\n\r\n  try {\r\n    changeNodeAtPath({\r\n      treeData,\r\n      path,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      newNode: ({ node, treeIndex }) => {\r\n        foundNodeInfo = { node, treeIndex };\r\n        return node;\r\n      }\r\n    });\r\n  } catch (err) {\r\n    // Ignore the error -- the null return will be explanation enough\r\n  }\r\n\r\n  return foundNodeInfo;\r\n}\r\n\r\n/**\r\n * Adds the node to the specified parent and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {!Object} newNode - The node to insert\r\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The updated tree data\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n */\r\nexport function addNodeUnderParent({\r\n  treeData,\r\n  newNode,\r\n  parentKey = null,\r\n  getNodeKey,\r\n  ignoreCollapsed = true,\r\n  expandParent = false,\r\n  addAsFirstChild = false\r\n}) {\r\n  if (parentKey === null) {\r\n    return {\r\n      treeData: [...(treeData || []), newNode],\r\n      treeIndex: (treeData || []).length\r\n    };\r\n  }\r\n\r\n  let insertedTreeIndex = null;\r\n  let hasBeenAdded = false;\r\n  const changedTreeData = map({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: ({ node, treeIndex, path }) => {\r\n      const key = path ? path[path.length - 1] : null;\r\n      // Return nodes that are not the parent as-is\r\n      if (hasBeenAdded || key !== parentKey) {\r\n        return node;\r\n      }\r\n      hasBeenAdded = true;\r\n\r\n      const parentNode = {\r\n        ...node\r\n      };\r\n\r\n      if (expandParent) {\r\n        parentNode.expanded = true;\r\n      }\r\n\r\n      // If no children exist yet, just add the single newNode\r\n      if (!parentNode.children) {\r\n        insertedTreeIndex = treeIndex + 1;\r\n        return {\r\n          ...parentNode,\r\n          children: [newNode]\r\n        };\r\n      }\r\n\r\n      if (typeof parentNode.children === \"function\") {\r\n        throw new Error(\"Cannot add to children defined by a function\");\r\n      }\r\n\r\n      let nextTreeIndex = treeIndex + 1;\r\n      for (let i = 0; i < parentNode.children.length; i += 1) {\r\n        nextTreeIndex +=\r\n          1 +\r\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\r\n      }\r\n\r\n      insertedTreeIndex = nextTreeIndex;\r\n\r\n      const children = addAsFirstChild\r\n        ? [newNode, ...parentNode.children]\r\n        : [...parentNode.children, newNode];\r\n\r\n      return {\r\n        ...parentNode,\r\n        children\r\n      };\r\n    }\r\n  });\r\n\r\n  if (!hasBeenAdded) {\r\n    throw new Error(\"No node found with the given key.\");\r\n  }\r\n\r\n  return {\r\n    treeData: changedTreeData,\r\n    treeIndex: insertedTreeIndex\r\n  };\r\n}\r\n\r\nfunction addNodeAtDepthAndIndex({\r\n  targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  ignoreCollapsed,\r\n  expandParent,\r\n  isPseudoRoot = false,\r\n  isLastChild,\r\n  node,\r\n  currentIndex,\r\n  currentDepth,\r\n  getNodeKey,\r\n  path = []\r\n}) {\r\n  const selfPath = n =>\r\n    isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\r\n\r\n  // If the current position is the only possible place to add, add it\r\n  if (\r\n    currentIndex >= minimumTreeIndex - 1 ||\r\n    (isLastChild && !(node.children && node.children.length))\r\n  ) {\r\n    if (typeof node.children === \"function\") {\r\n      throw new Error(\"Cannot add to children defined by a function\");\r\n    } else {\r\n      const extraNodeProps = expandParent ? { expanded: true } : {};\r\n      const nextNode = {\r\n        ...node,\r\n\r\n        ...extraNodeProps,\r\n        children: node.children ? [newNode, ...node.children] : [newNode]\r\n      };\r\n\r\n      return {\r\n        node: nextNode,\r\n        nextIndex: currentIndex + 2,\r\n        insertedTreeIndex: currentIndex + 1,\r\n        parentPath: selfPath(nextNode),\r\n        parentNode: isPseudoRoot ? null : nextNode\r\n      };\r\n    }\r\n  }\r\n\r\n  // If this is the target depth for the insertion,\r\n  // i.e., where the newNode can be added to the current node's children\r\n  if (currentDepth >= targetDepth - 1) {\r\n    // Skip over nodes with no children or hidden children\r\n    if (\r\n      !node.children ||\r\n      typeof node.children === \"function\" ||\r\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return { node, nextIndex: currentIndex + 1 };\r\n    }\r\n\r\n    // Scan over the children to see if there's a place among them that fulfills\r\n    // the minimumTreeIndex requirement\r\n    let childIndex = currentIndex + 1;\r\n    let insertedTreeIndex = null;\r\n    let insertIndex = null;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      // If a valid location is found, mark it as the insertion location and\r\n      // break out of the loop\r\n      if (childIndex >= minimumTreeIndex) {\r\n        insertedTreeIndex = childIndex;\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n\r\n      // Increment the index by the child itself plus the number of descendants it has\r\n      childIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    // If no valid indices to add the node were found\r\n    if (insertIndex === null) {\r\n      // If the last position in this node's children is less than the minimum index\r\n      // and there are more children on the level of this node, return without insertion\r\n      if (childIndex < minimumTreeIndex && !isLastChild) {\r\n        return { node, nextIndex: childIndex };\r\n      }\r\n\r\n      // Use the last position in the children array to insert the newNode\r\n      insertedTreeIndex = childIndex;\r\n      insertIndex = node.children.length;\r\n    }\r\n\r\n    // Insert the newNode at the insertIndex\r\n    const nextNode = {\r\n      ...node,\r\n      children: [\r\n        ...node.children.slice(0, insertIndex),\r\n        newNode,\r\n        ...node.children.slice(insertIndex)\r\n      ]\r\n    };\r\n\r\n    // Return node with successful insert result\r\n    return {\r\n      node: nextNode,\r\n      nextIndex: childIndex,\r\n      insertedTreeIndex,\r\n      parentPath: selfPath(nextNode),\r\n      parentNode: isPseudoRoot ? null : nextNode\r\n    };\r\n  }\r\n\r\n  // Skip over nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    typeof node.children === \"function\" ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return { node, nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Get all descendants\r\n  let insertedTreeIndex = null;\r\n  let pathFragment = null;\r\n  let parentNode = null;\r\n  let childIndex = currentIndex + 1;\r\n  let newChildren = node.children;\r\n  if (typeof newChildren !== \"function\") {\r\n    newChildren = newChildren.map((child, i) => {\r\n      if (insertedTreeIndex !== null) {\r\n        return child;\r\n      }\r\n\r\n      const mapResult = addNodeAtDepthAndIndex({\r\n        targetDepth,\r\n        minimumTreeIndex,\r\n        newNode,\r\n        ignoreCollapsed,\r\n        expandParent,\r\n        isLastChild: isLastChild && i === newChildren.length - 1,\r\n        node: child,\r\n        currentIndex: childIndex,\r\n        currentDepth: currentDepth + 1,\r\n        getNodeKey,\r\n        path: [] // Cannot determine the parent path until the children have been processed\r\n      });\r\n\r\n      if (\"insertedTreeIndex\" in mapResult) {\r\n        ({\r\n          insertedTreeIndex,\r\n          parentNode,\r\n          parentPath: pathFragment\r\n        } = mapResult);\r\n      }\r\n\r\n      childIndex = mapResult.nextIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  const nextNode = { ...node, children: newChildren };\r\n  const result = {\r\n    node: nextNode,\r\n    nextIndex: childIndex\r\n  };\r\n\r\n  if (insertedTreeIndex !== null) {\r\n    result.insertedTreeIndex = insertedTreeIndex;\r\n    result.parentPath = [...selfPath(nextNode), ...pathFragment];\r\n    result.parentNode = parentNode;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Insert a node into the tree at the given depth, after the minimum index\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n * @param {!Object} newNode - The node to insert into the tree\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node added\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n * @return {Object} result.parentNode - The parent node of the inserted node\r\n */\r\nexport function insertNode({\r\n  treeData,\r\n  depth: targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  getNodeKey = () => {},\r\n  ignoreCollapsed = true,\r\n  expandParent = false\r\n}) {\r\n  if (!treeData && targetDepth === 0) {\r\n    return {\r\n      treeData: [newNode],\r\n      treeIndex: 0,\r\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\r\n      parentNode: null\r\n    };\r\n  }\r\n\r\n  const insertResult = addNodeAtDepthAndIndex({\r\n    targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    ignoreCollapsed,\r\n    expandParent,\r\n    getNodeKey,\r\n    isPseudoRoot: true,\r\n    isLastChild: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    currentDepth: -1\r\n  });\r\n\r\n  if (!(\"insertedTreeIndex\" in insertResult)) {\r\n    throw new Error(\"No suitable position found to insert.\");\r\n  }\r\n\r\n  const treeIndex = insertResult.insertedTreeIndex;\r\n  return {\r\n    treeData: insertResult.node.children,\r\n    treeIndex,\r\n    path: [\r\n      ...insertResult.parentPath,\r\n      getNodeKey({ node: newNode, treeIndex })\r\n    ],\r\n    parentNode: insertResult.parentNode\r\n  };\r\n}\r\n\r\n/**\r\n * Get tree data flattened.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }}[] nodes - The node array\r\n */\r\nexport function getFlatDataFromTree({\r\n  treeData,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  const flattened = [];\r\n  walk({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: nodeInfo => {\r\n      flattened.push(nodeInfo);\r\n    }\r\n  });\r\n\r\n  return flattened;\r\n}\r\n\r\n/**\r\n * Generate a tree structure from flat data.\r\n *\r\n * @param {!Object[]} flatData\r\n * @param {!function=} getKey - Function to get the key from the nodeData\r\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n *\r\n * @return {Object[]} treeData - The flat data represented as a tree\r\n */\r\nexport function getTreeFromFlatData({\r\n  flatData,\r\n  getKey = node => node.id,\r\n  getParentKey = node => node.parentId,\r\n  rootKey = \"0\"\r\n}) {\r\n  if (!flatData) {\r\n    return [];\r\n  }\r\n\r\n  const childrenToParents = {};\r\n  flatData.forEach(child => {\r\n    const parentKey = getParentKey(child);\r\n\r\n    if (parentKey in childrenToParents) {\r\n      childrenToParents[parentKey].push(child);\r\n    } else {\r\n      childrenToParents[parentKey] = [child];\r\n    }\r\n  });\r\n\r\n  if (!(rootKey in childrenToParents)) {\r\n    return [];\r\n  }\r\n\r\n  const trav = parent => {\r\n    const parentKey = getKey(parent);\r\n    if (parentKey in childrenToParents) {\r\n      return {\r\n        ...parent,\r\n        children: childrenToParents[parentKey].map(child => trav(child))\r\n      };\r\n    }\r\n\r\n    return { ...parent };\r\n  };\r\n\r\n  return childrenToParents[rootKey].map(child => trav(child));\r\n}\r\n\r\n/**\r\n * Check if a node is a descendant of another node.\r\n *\r\n * @param {!Object} older - Potential ancestor of younger node\r\n * @param {!Object} younger - Potential descendant of older node\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isDescendant(older, younger) {\r\n  return (\r\n    !!older.children &&\r\n    typeof older.children !== \"function\" &&\r\n    older.children.some(\r\n      child => child === younger || isDescendant(child, younger)\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Get the maximum depth of the children (the depth of the root node is 0).\r\n *\r\n * @param {!Object} node - Node in the tree\r\n * @param {?number} depth - The current depth\r\n *\r\n * @return {number} maxDepth - The deepest depth in the tree\r\n */\r\nexport function getDepth(node, depth = 0) {\r\n  if (!node.children) {\r\n    return depth;\r\n  }\r\n\r\n  if (typeof node.children === \"function\") {\r\n    return depth + 1;\r\n  }\r\n\r\n  return node.children.reduce(\r\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\r\n    depth\r\n  );\r\n}\r\n\r\n/**\r\n * Find nodes matching a search query in the tree,\r\n *\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n *\r\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n *                               it will be the same as the original tree data.\r\n */\r\nexport function find({\r\n  getNodeKey,\r\n  treeData,\r\n  searchQuery,\r\n  searchMethod,\r\n  searchFocusOffset,\r\n  expandAllMatchPaths = false,\r\n  expandFocusMatchPaths = true\r\n}) {\r\n  let matchCount = 0;\r\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\r\n    let matches = [];\r\n    let isSelfMatch = false;\r\n    let hasFocusMatch = false;\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n    const extraInfo = isPseudoRoot\r\n      ? null\r\n      : {\r\n          path: selfPath,\r\n          treeIndex: currentIndex\r\n        };\r\n\r\n    // Nodes with with children that aren't lazy\r\n    const hasChildren =\r\n      node.children &&\r\n      typeof node.children !== \"function\" &&\r\n      node.children.length > 0;\r\n\r\n    // Examine the current node to see if it is a match\r\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\r\n      if (matchCount === searchFocusOffset) {\r\n        hasFocusMatch = true;\r\n      }\r\n\r\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\r\n      //  is reached\r\n      matchCount += 1;\r\n\r\n      // We cannot add this node to the matches right away, as it may be changed\r\n      //  during the search of the descendants. The entire node is used in\r\n      //  comparisons between nodes inside the `matches` and `treeData` results\r\n      //  of this method (`find`)\r\n      isSelfMatch = true;\r\n    }\r\n\r\n    let childIndex = currentIndex;\r\n    const newNode = { ...node };\r\n    if (hasChildren) {\r\n      // Get all descendants\r\n      newNode.children = newNode.children.map(child => {\r\n        const mapResult = trav({\r\n          node: child,\r\n          currentIndex: childIndex + 1,\r\n          path: selfPath\r\n        });\r\n\r\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\r\n        // if the child is expanded.\r\n        //\r\n        // The child could have been expanded from the start,\r\n        // or expanded due to a matching node being found in its descendants\r\n        if (mapResult.node.expanded) {\r\n          childIndex = mapResult.treeIndex;\r\n        } else {\r\n          childIndex += 1;\r\n        }\r\n\r\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\r\n          matches = [...matches, ...mapResult.matches];\r\n          if (mapResult.hasFocusMatch) {\r\n            hasFocusMatch = true;\r\n          }\r\n\r\n          // Expand the current node if it has descendants matching the search\r\n          // and the settings are set to do so.\r\n          if (\r\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\r\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\r\n              mapResult.hasFocusMatch)\r\n          ) {\r\n            newNode.expanded = true;\r\n          }\r\n        }\r\n\r\n        return mapResult.node;\r\n      });\r\n    }\r\n\r\n    // Cannot assign a treeIndex to hidden nodes\r\n    if (!isPseudoRoot && !newNode.expanded) {\r\n      matches = matches.map(match => ({\r\n        ...match,\r\n        treeIndex: null\r\n      }));\r\n    }\r\n\r\n    // Add this node to the matches if it fits the search criteria.\r\n    // This is performed at the last minute so newNode can be sent in its final form.\r\n    if (isSelfMatch) {\r\n      matches = [{ ...extraInfo, node: newNode }, ...matches];\r\n    }\r\n\r\n    return {\r\n      node: matches.length > 0 ? newNode : node,\r\n      matches,\r\n      hasFocusMatch,\r\n      treeIndex: childIndex\r\n    };\r\n  };\r\n\r\n  const result = trav({\r\n    node: { children: treeData },\r\n    isPseudoRoot: true,\r\n    currentIndex: -1\r\n  });\r\n\r\n  return {\r\n    matches: result.matches,\r\n    treeData: result.node.children\r\n  };\r\n}\r\n\r\nexport function treeToList(arr) {\r\n  let treeList = arr || [];\r\n\r\n  //\r\n  let leafs = [];\r\n\r\n  //\r\n  let roots = [];\r\n\r\n  //\r\n  let list = [];\r\n\r\n  for (let i = 0; i < treeList.length; i++) {\r\n    const d = treeList[i];\r\n\r\n    if (!d) {\r\n      continue;\r\n    }\r\n\r\n    const childrens = d.children || [];\r\n\r\n    d.__depth = 0;\r\n\r\n    list.push(d);\r\n    roots.push(d);\r\n\r\n    if (childrens.length > 0) {\r\n      getChildren(d, 0);\r\n    } else {\r\n      leafs.push(d);\r\n    }\r\n  }\r\n\r\n  function getChildren(d, depth) {\r\n    const tempArr = d.children || [];\r\n\r\n    for (let i = 0; i < tempArr.length; i++) {\r\n      const d = tempArr[i];\r\n      const childrens = d.children || [];\r\n\r\n      d.__depth = depth + 1;\r\n\r\n      list.push(d);\r\n\r\n      if (childrens.length > 0) {\r\n        getChildren(d, depth + 1);\r\n      } else {\r\n        leafs.push(d);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { list, leafs, roots };\r\n}\r\n\r\nexport function getDataListWithExpanded(list, expandedKeys = [], rowKey) {\r\n  let arr = [];\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    let d = list[i];\r\n\r\n    d.__depth = 0;\r\n\r\n    arr.push(d);\r\n\r\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n      if (d.children) {\r\n        setChildren(d, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  function setChildren(c, depth) {\r\n    let cArr = c.children;\r\n    for (let i = 0; i < cArr.length; i++) {\r\n      let d = cArr[i];\r\n      d.__depth = depth + 1;\r\n      arr.push(d);\r\n\r\n      if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n        if (d.children) {\r\n          setChildren(d, depth + 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\nexport function getScrollbarWidth() {\r\n  var userAgent = navigator.userAgent; //userAgent\r\n\r\n  if (userAgent.indexOf(\"Chrome\") > -1) {\r\n    return 6;\r\n  }\r\n\r\n  var oP = document.createElement(\"p\"),\r\n    styles = {\r\n      width: \"100px\",\r\n      height: \"100px\",\r\n      overflowY: \"scroll\"\r\n    },\r\n    i,\r\n    scrollbarWidth;\r\n\r\n  for (i in styles) {\r\n    oP.style[i] = styles[i];\r\n  }\r\n  document.body.appendChild(oP);\r\n  scrollbarWidth = oP.offsetWidth - oP.clientWidth;\r\n  oP.remove();\r\n\r\n  return scrollbarWidth;\r\n}\r\n"]}]}