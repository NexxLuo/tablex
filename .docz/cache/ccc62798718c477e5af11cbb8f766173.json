{"remainingRequest":"E:\\WebRoot\\tablex\\tablex\\node_modules\\thread-loader\\dist\\cjs.js??ref--5-1!E:\\WebRoot\\tablex\\tablex\\node_modules\\babel-loader\\lib\\index.js??ref--5-2!E:\\WebRoot\\tablex\\tablex\\node_modules\\source-map-loader\\index.js!E:\\WebRoot\\tablex\\tablex\\src\\helper.js","dependencies":[{"path":"E:\\WebRoot\\tablex\\tablex\\src\\helper.js","mtime":1556625619493},{"path":"E:\\WebRoot\\tablex\\tablex\\node_modules\\umi-library\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1559355688594},{"path":"E:\\WebRoot\\tablex\\tablex\\node_modules\\thread-loader\\dist\\cjs.js","mtime":1554538856109},{"path":"E:\\WebRoot\\tablex\\tablex\\node_modules\\babel-loader\\lib\\index.js","mtime":1553685910943},{"path":"E:\\WebRoot\\tablex\\tablex\\node_modules\\source-map-loader\\index.js","mtime":1553685912297}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxub2RlX21vZHVsZXNcXHVtaS1saWJyYXJ5XFxub2RlX21vZHVsZXNcXGRvY3pcXG5vZGVfbW9kdWxlc1xcYmFiZWwtcHJlc2V0LXJlYWN0LWFwcFxcbm9kZV9tb2R1bGVzXFxAYmFiZWxcXHJ1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkIjsKaW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXG5vZGVfbW9kdWxlc1xcdW1pLWxpYnJhcnlcXG5vZGVfbW9kdWxlc1xcZG9jelxcbm9kZV9tb2R1bGVzXFxiYWJlbC1wcmVzZXQtcmVhY3QtYXBwXFxub2RlX21vZHVsZXNcXEBiYWJlbFxccnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CgooZnVuY3Rpb24gKCkgewogIHZhciBlbnRlck1vZHVsZSA9ICh0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwgOiByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykpLmVudGVyTW9kdWxlOwogIGVudGVyTW9kdWxlICYmIGVudGVyTW9kdWxlKG1vZHVsZSk7Cn0pKCk7CgovKioNCiAqIFBlcmZvcm1zIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG92ZXIgYWxsIG9mIHRoZSBub2RlIGRlc2NlbmRhbnRzLA0KICogaW5jcmVtZW50aW5nIGN1cnJlbnRJbmRleCBieSAxIGZvciBlYWNoDQogKi8KZnVuY3Rpb24gZ2V0Tm9kZURhdGFBdFRyZWVJbmRleE9yTmV4dEluZGV4KF9yZWYpIHsKICB2YXIgdGFyZ2V0SW5kZXggPSBfcmVmLnRhcmdldEluZGV4LAogICAgICBub2RlID0gX3JlZi5ub2RlLAogICAgICBjdXJyZW50SW5kZXggPSBfcmVmLmN1cnJlbnRJbmRleCwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYuZ2V0Tm9kZUtleSwKICAgICAgX3JlZiRwYXRoID0gX3JlZi5wYXRoLAogICAgICBwYXRoID0gX3JlZiRwYXRoID09PSB2b2lkIDAgPyBbXSA6IF9yZWYkcGF0aCwKICAgICAgX3JlZiRsb3dlclNpYmxpbmdDb3VuID0gX3JlZi5sb3dlclNpYmxpbmdDb3VudHMsCiAgICAgIGxvd2VyU2libGluZ0NvdW50cyA9IF9yZWYkbG93ZXJTaWJsaW5nQ291biA9PT0gdm9pZCAwID8gW10gOiBfcmVmJGxvd2VyU2libGluZ0NvdW4sCiAgICAgIF9yZWYkaWdub3JlQ29sbGFwc2VkID0gX3JlZi5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYkaWdub3JlQ29sbGFwc2VkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRpZ25vcmVDb2xsYXBzZWQsCiAgICAgIF9yZWYkaXNQc2V1ZG9Sb290ID0gX3JlZi5pc1BzZXVkb1Jvb3QsCiAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWYkaXNQc2V1ZG9Sb290ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkaXNQc2V1ZG9Sb290OwogIC8vIFRoZSBwc2V1ZG8tcm9vdCBpcyBub3QgY29uc2lkZXJlZCBpbiB0aGUgcGF0aAogIHZhciBzZWxmUGF0aCA9ICFpc1BzZXVkb1Jvb3QgPyBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpLCBbZ2V0Tm9kZUtleSh7CiAgICBub2RlOiBub2RlLAogICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgKICB9KV0pIDogW107IC8vIFJldHVybiB0YXJnZXQgbm9kZSB3aGVuIGZvdW5kCgogIGlmIChjdXJyZW50SW5kZXggPT09IHRhcmdldEluZGV4KSB7CiAgICByZXR1cm4gewogICAgICBub2RlOiBub2RlLAogICAgICBsb3dlclNpYmxpbmdDb3VudHM6IGxvd2VyU2libGluZ0NvdW50cywKICAgICAgcGF0aDogc2VsZlBhdGgKICAgIH07CiAgfSAvLyBBZGQgb25lIGFuZCBjb250aW51ZSBmb3Igbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KCgogIGlmICghbm9kZS5jaGlsZHJlbiB8fCBpZ25vcmVDb2xsYXBzZWQgJiYgbm9kZS5leHBhbmRlZCAhPT0gdHJ1ZSkgewogICAgcmV0dXJuIHsKICAgICAgbmV4dEluZGV4OiBjdXJyZW50SW5kZXggKyAxCiAgICB9OwogIH0gLy8gSXRlcmF0ZSBvdmVyIGVhY2ggY2hpbGQgYW5kIHRoZWlyIGRlc2NlbmRhbnRzIGFuZCByZXR1cm4gdGhlCiAgLy8gdGFyZ2V0IG5vZGUgaWYgY2hpbGRJbmRleCByZWFjaGVzIHRoZSB0YXJnZXRJbmRleAoKCiAgdmFyIGNoaWxkSW5kZXggPSBjdXJyZW50SW5kZXggKyAxOwogIHZhciBjaGlsZENvdW50ID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7CgogIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSArPSAxKSB7CiAgICB2YXIgcmVzdWx0ID0gZ2V0Tm9kZURhdGFBdFRyZWVJbmRleE9yTmV4dEluZGV4KHsKICAgICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICAgIHRhcmdldEluZGV4OiB0YXJnZXRJbmRleCwKICAgICAgbm9kZTogbm9kZS5jaGlsZHJlbltpXSwKICAgICAgY3VycmVudEluZGV4OiBjaGlsZEluZGV4LAogICAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobG93ZXJTaWJsaW5nQ291bnRzKSwgW2NoaWxkQ291bnQgLSBpIC0gMV0pLAogICAgICBwYXRoOiBzZWxmUGF0aAogICAgfSk7CgogICAgaWYgKHJlc3VsdC5ub2RlKSB7CiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9CgogICAgY2hpbGRJbmRleCA9IHJlc3VsdC5uZXh0SW5kZXg7CiAgfSAvLyBJZiB0aGUgdGFyZ2V0IG5vZGUgaXMgbm90IGZvdW5kLCByZXR1cm4gdGhlIGZhcnRoZXN0IHRyYXZlcnNlZCBpbmRleAoKCiAgcmV0dXJuIHsKICAgIG5leHRJbmRleDogY2hpbGRJbmRleAogIH07Cn0KCmV4cG9ydCBmdW5jdGlvbiBnZXREZXNjZW5kYW50Q291bnQoX3JlZjIpIHsKICB2YXIgbm9kZSA9IF9yZWYyLm5vZGUsCiAgICAgIF9yZWYyJGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYyLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjIkaWdub3JlQ29sbGFwc2VkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIkaWdub3JlQ29sbGFwc2VkOwogIHJldHVybiBnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoewogICAgZ2V0Tm9kZUtleTogZnVuY3Rpb24gZ2V0Tm9kZUtleSgpIHt9LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBub2RlOiBub2RlLAogICAgY3VycmVudEluZGV4OiAwLAogICAgdGFyZ2V0SW5kZXg6IC0xCiAgfSkubmV4dEluZGV4IC0gMTsKfQovKioNCiAqIFdhbGsgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBnaXZlbiBub2RlLCBkZXB0aC1maXJzdA0KICoNCiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gRnVuY3Rpb24gcGFyYW1ldGVycw0KICogQHBhcmFtIHtmdW5jdGlvbn0gYXJncy5jYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBub2RlDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFufSBhcmdzLmlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICogQHBhcmFtIHtib29sZWFuPX0gYXJncy5pc1BzZXVkb1Jvb3QgLSBJZiB0cnVlLCB0aGlzIG5vZGUgaGFzIG5vIHJlYWwgZGF0YSwgYW5kIG9ubHkgc2VydmVzDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB0aGUgcGFyZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHRyZWUNCiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm5vZGUgLSBBIHRyZWUgbm9kZQ0KICogQHBhcmFtIHtPYmplY3Q9fSBhcmdzLnBhcmVudE5vZGUgLSBUaGUgcGFyZW50IG5vZGUgb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcn0gYXJncy5jdXJyZW50SW5kZXggLSBUaGUgdHJlZUluZGV4IG9mIGBub2RlYA0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gYXJncy5wYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgY2hhbmdlZA0KICogQHBhcmFtIHtudW1iZXJbXX0gYXJncy5sb3dlclNpYmxpbmdDb3VudHMgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjb3VudCBvZiBzaWJsaW5ncyBiZW5lYXRoIHRoZQ0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyBub2RlcyBpbiB0aGlzIHBhdGgNCiAqDQogKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IG5leHRJbmRleCAtIEluZGV4IG9mIHRoZSBuZXh0IHNpYmxpbmcgb2YgYG5vZGVgLA0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBmYWxzZSBpZiB0aGUgd2FsayBzaG91bGQgYmUgdGVybWluYXRlZA0KICovCgppZiAodHlwZW9mIGdldERlc2NlbmRhbnRDb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0RGVzY2VuZGFudENvdW50ICYmIGdldERlc2NlbmRhbnRDb3VudCA9PT0gT2JqZWN0KGdldERlc2NlbmRhbnRDb3VudCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXREZXNjZW5kYW50Q291bnQpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldERlc2NlbmRhbnRDb3VudCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImdldERlc2NlbmRhbnRDb3VudCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIHdhbGtEZXNjZW5kYW50cyhfcmVmMykgewogIHZhciBjYWxsYmFjayA9IF9yZWYzLmNhbGxiYWNrLAogICAgICBnZXROb2RlS2V5ID0gX3JlZjMuZ2V0Tm9kZUtleSwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjMuaWdub3JlQ29sbGFwc2VkLAogICAgICBfcmVmMyRpc1BzZXVkb1Jvb3QgPSBfcmVmMy5pc1BzZXVkb1Jvb3QsCiAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWYzJGlzUHNldWRvUm9vdCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRpc1BzZXVkb1Jvb3QsCiAgICAgIG5vZGUgPSBfcmVmMy5ub2RlLAogICAgICBfcmVmMyRwYXJlbnROb2RlID0gX3JlZjMucGFyZW50Tm9kZSwKICAgICAgcGFyZW50Tm9kZSA9IF9yZWYzJHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMyRwYXJlbnROb2RlLAogICAgICBjdXJyZW50SW5kZXggPSBfcmVmMy5jdXJyZW50SW5kZXgsCiAgICAgIF9yZWYzJHBhdGggPSBfcmVmMy5wYXRoLAogICAgICBwYXRoID0gX3JlZjMkcGF0aCA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRwYXRoLAogICAgICBfcmVmMyRsb3dlclNpYmxpbmdDb3UgPSBfcmVmMy5sb3dlclNpYmxpbmdDb3VudHMsCiAgICAgIGxvd2VyU2libGluZ0NvdW50cyA9IF9yZWYzJGxvd2VyU2libGluZ0NvdSA9PT0gdm9pZCAwID8gW10gOiBfcmVmMyRsb3dlclNpYmxpbmdDb3U7CiAgLy8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCiAgdmFyIHNlbGZQYXRoID0gaXNQc2V1ZG9Sb290ID8gW10gOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpLCBbZ2V0Tm9kZUtleSh7CiAgICBub2RlOiBub2RlLAogICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgKICB9KV0pOwogIHZhciBzZWxmSW5mbyA9IGlzUHNldWRvUm9vdCA/IG51bGwgOiB7CiAgICBub2RlOiBub2RlLAogICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSwKICAgIHBhdGg6IHNlbGZQYXRoLAogICAgbG93ZXJTaWJsaW5nQ291bnRzOiBsb3dlclNpYmxpbmdDb3VudHMsCiAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogIH07CgogIGlmICghaXNQc2V1ZG9Sb290KSB7CiAgICB2YXIgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhzZWxmSW5mbyk7IC8vIEN1dCB3YWxrIHNob3J0IGlmIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmYWxzZQoKICAgIGlmIChjYWxsYmFja1Jlc3VsdCA9PT0gZmFsc2UpIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0gLy8gUmV0dXJuIHNlbGYgb24gbm9kZXMgd2l0aCBubyBjaGlsZHJlbiBvciBoaWRkZW4gY2hpbGRyZW4KCgogIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmV4cGFuZGVkICE9PSB0cnVlICYmIGlnbm9yZUNvbGxhcHNlZCAmJiAhaXNQc2V1ZG9Sb290KSB7CiAgICByZXR1cm4gY3VycmVudEluZGV4OwogIH0gLy8gR2V0IGFsbCBkZXNjZW5kYW50cwoKCiAgdmFyIGNoaWxkSW5kZXggPSBjdXJyZW50SW5kZXg7CiAgdmFyIGNoaWxkQ291bnQgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsKCiAgaWYgKHR5cGVvZiBub2RlLmNoaWxkcmVuICE9PSAiZnVuY3Rpb24iKSB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQ291bnQ7IGkgKz0gMSkgewogICAgICBjaGlsZEluZGV4ID0gd2Fsa0Rlc2NlbmRhbnRzKHsKICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssCiAgICAgICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgICAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgICAgICBub2RlOiBub2RlLmNoaWxkcmVuW2ldLAogICAgICAgIHBhcmVudE5vZGU6IGlzUHNldWRvUm9vdCA/IG51bGwgOiBub2RlLAogICAgICAgIGN1cnJlbnRJbmRleDogY2hpbGRJbmRleCArIDEsCiAgICAgICAgbG93ZXJTaWJsaW5nQ291bnRzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvd2VyU2libGluZ0NvdW50cyksIFtjaGlsZENvdW50IC0gaSAtIDFdKSwKICAgICAgICBwYXRoOiBzZWxmUGF0aAogICAgICB9KTsgLy8gQ3V0IHdhbGsgc2hvcnQgaWYgdGhlIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlCgogICAgICBpZiAoY2hpbGRJbmRleCA9PT0gZmFsc2UpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBjaGlsZEluZGV4Owp9Ci8qKg0KICogUGVyZm9ybSBhIGNoYW5nZSBvbiB0aGUgZ2l2ZW4gbm9kZSBhbmQgYWxsIGl0cyBkZXNjZW5kYW50cywgdHJhdmVyc2luZyB0aGUgdHJlZSBkZXB0aC1maXJzdA0KICoNCiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIC0gRnVuY3Rpb24gcGFyYW1ldGVycw0KICogQHBhcmFtIHtmdW5jdGlvbn0gYXJncy5jYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBub2RlDQogKiBAcGFyYW0ge2Z1bmN0aW9ufSBhcmdzLmdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFufSBhcmdzLmlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICogQHBhcmFtIHtib29sZWFuPX0gYXJncy5pc1BzZXVkb1Jvb3QgLSBJZiB0cnVlLCB0aGlzIG5vZGUgaGFzIG5vIHJlYWwgZGF0YSwgYW5kIG9ubHkgc2VydmVzDQogKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB0aGUgcGFyZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHRyZWUNCiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLm5vZGUgLSBBIHRyZWUgbm9kZQ0KICogQHBhcmFtIHtPYmplY3Q9fSBhcmdzLnBhcmVudE5vZGUgLSBUaGUgcGFyZW50IG5vZGUgb2YgYG5vZGVgDQogKiBAcGFyYW0ge251bWJlcn0gYXJncy5jdXJyZW50SW5kZXggLSBUaGUgdHJlZUluZGV4IG9mIGBub2RlYA0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gYXJncy5wYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgY2hhbmdlZA0KICogQHBhcmFtIHtudW1iZXJbXX0gYXJncy5sb3dlclNpYmxpbmdDb3VudHMgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjb3VudCBvZiBzaWJsaW5ncyBiZW5lYXRoIHRoZQ0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyBub2RlcyBpbiB0aGlzIHBhdGgNCiAqDQogKiBAcmV0dXJuIHtudW1iZXJ8ZmFsc2V9IG5leHRJbmRleCAtIEluZGV4IG9mIHRoZSBuZXh0IHNpYmxpbmcgb2YgYG5vZGVgLA0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBmYWxzZSBpZiB0aGUgd2FsayBzaG91bGQgYmUgdGVybWluYXRlZA0KICovCgoKZnVuY3Rpb24gbWFwRGVzY2VuZGFudHMoX3JlZjQpIHsKICB2YXIgY2FsbGJhY2sgPSBfcmVmNC5jYWxsYmFjaywKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWY0LmdldE5vZGVLZXksCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWY0Lmlnbm9yZUNvbGxhcHNlZCwKICAgICAgX3JlZjQkaXNQc2V1ZG9Sb290ID0gX3JlZjQuaXNQc2V1ZG9Sb290LAogICAgICBpc1BzZXVkb1Jvb3QgPSBfcmVmNCRpc1BzZXVkb1Jvb3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjQkaXNQc2V1ZG9Sb290LAogICAgICBub2RlID0gX3JlZjQubm9kZSwKICAgICAgX3JlZjQkcGFyZW50Tm9kZSA9IF9yZWY0LnBhcmVudE5vZGUsCiAgICAgIHBhcmVudE5vZGUgPSBfcmVmNCRwYXJlbnROb2RlID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjQkcGFyZW50Tm9kZSwKICAgICAgY3VycmVudEluZGV4ID0gX3JlZjQuY3VycmVudEluZGV4LAogICAgICBfcmVmNCRwYXRoID0gX3JlZjQucGF0aCwKICAgICAgcGF0aCA9IF9yZWY0JHBhdGggPT09IHZvaWQgMCA/IFtdIDogX3JlZjQkcGF0aCwKICAgICAgX3JlZjQkbG93ZXJTaWJsaW5nQ291ID0gX3JlZjQubG93ZXJTaWJsaW5nQ291bnRzLAogICAgICBsb3dlclNpYmxpbmdDb3VudHMgPSBfcmVmNCRsb3dlclNpYmxpbmdDb3UgPT09IHZvaWQgMCA/IFtdIDogX3JlZjQkbG93ZXJTaWJsaW5nQ291OwoKICB2YXIgbmV4dE5vZGUgPSBfb2JqZWN0U3ByZWFkKHt9LCBub2RlKTsgLy8gVGhlIHBzZXVkby1yb290IGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBwYXRoCgoKICB2YXIgc2VsZlBhdGggPSBpc1BzZXVkb1Jvb3QgPyBbXSA6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGF0aCksIFtnZXROb2RlS2V5KHsKICAgIG5vZGU6IG5leHROb2RlLAogICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgKICB9KV0pOwogIHZhciBzZWxmSW5mbyA9IHsKICAgIG5vZGU6IG5leHROb2RlLAogICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSwKICAgIHBhdGg6IHNlbGZQYXRoLAogICAgbG93ZXJTaWJsaW5nQ291bnRzOiBsb3dlclNpYmxpbmdDb3VudHMsCiAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogIH07IC8vIFJldHVybiBzZWxmIG9uIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gb3IgaGlkZGVuIGNoaWxkcmVuCgogIGlmICghbmV4dE5vZGUuY2hpbGRyZW4gfHwgbmV4dE5vZGUuZXhwYW5kZWQgIT09IHRydWUgJiYgaWdub3JlQ29sbGFwc2VkICYmICFpc1BzZXVkb1Jvb3QpIHsKICAgIHJldHVybiB7CiAgICAgIHRyZWVJbmRleDogY3VycmVudEluZGV4LAogICAgICBub2RlOiBjYWxsYmFjayhzZWxmSW5mbykKICAgIH07CiAgfSAvLyBHZXQgYWxsIGRlc2NlbmRhbnRzCgoKICB2YXIgY2hpbGRJbmRleCA9IGN1cnJlbnRJbmRleDsKICB2YXIgY2hpbGRDb3VudCA9IG5leHROb2RlLmNoaWxkcmVuLmxlbmd0aDsKCiAgaWYgKHR5cGVvZiBuZXh0Tm9kZS5jaGlsZHJlbiAhPT0gImZ1bmN0aW9uIikgewogICAgbmV4dE5vZGUuY2hpbGRyZW4gPSBuZXh0Tm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkLCBpKSB7CiAgICAgIHZhciBtYXBSZXN1bHQgPSBtYXBEZXNjZW5kYW50cyh7CiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLAogICAgICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICAgICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICAgICAgbm9kZTogY2hpbGQsCiAgICAgICAgcGFyZW50Tm9kZTogaXNQc2V1ZG9Sb290ID8gbnVsbCA6IG5leHROb2RlLAogICAgICAgIGN1cnJlbnRJbmRleDogY2hpbGRJbmRleCArIDEsCiAgICAgICAgbG93ZXJTaWJsaW5nQ291bnRzOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxvd2VyU2libGluZ0NvdW50cyksIFtjaGlsZENvdW50IC0gaSAtIDFdKSwKICAgICAgICBwYXRoOiBzZWxmUGF0aAogICAgICB9KTsKICAgICAgY2hpbGRJbmRleCA9IG1hcFJlc3VsdC50cmVlSW5kZXg7CiAgICAgIHJldHVybiBtYXBSZXN1bHQubm9kZTsKICAgIH0pOwogIH0KCiAgcmV0dXJuIHsKICAgIG5vZGU6IGNhbGxiYWNrKHNlbGZJbmZvKSwKICAgIHRyZWVJbmRleDogY2hpbGRJbmRleAogIH07Cn0KLyoqDQogKiBDb3VudCBhbGwgdGhlIHZpc2libGUgKGV4cGFuZGVkKSBkZXNjZW5kYW50cyBpbiB0aGUgdHJlZSBkYXRhLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICoNCiAqIEByZXR1cm4ge251bWJlcn0gY291bnQNCiAqLwoKCmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlTm9kZUNvdW50KF9yZWY1KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjUudHJlZURhdGE7CgogIHZhciB0cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKG5vZGUpIHsKICAgIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmV4cGFuZGVkICE9PSB0cnVlIHx8IHR5cGVvZiBub2RlLmNoaWxkcmVuID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIHJldHVybiAxOwogICAgfQoKICAgIHJldHVybiAxICsgbm9kZS5jaGlsZHJlbi5yZWR1Y2UoZnVuY3Rpb24gKHRvdGFsLCBjdXJyZW50Tm9kZSkgewogICAgICByZXR1cm4gdG90YWwgKyB0cmF2ZXJzZShjdXJyZW50Tm9kZSk7CiAgICB9LCAwKTsKICB9OwoKICByZXR1cm4gdHJlZURhdGEucmVkdWNlKGZ1bmN0aW9uICh0b3RhbCwgY3VycmVudE5vZGUpIHsKICAgIHJldHVybiB0b3RhbCArIHRyYXZlcnNlKGN1cnJlbnROb2RlKTsKICB9LCAwKTsKfQovKioNCiAqIEdldCB0aGUgPHRhcmdldEluZGV4PnRoIHZpc2libGUgbm9kZSBpbiB0aGUgdHJlZSBkYXRhLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshbnVtYmVyfSB0YXJnZXRJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgbm9kZSB0byBzZWFyY2ggZm9yDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKg0KICogQHJldHVybiB7ew0KICogICAgICBub2RlOiBPYmplY3QsDQogKiAgICAgIHBhdGg6IFtdc3RyaW5nfFtdbnVtYmVyLA0KICogICAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdbnVtYmVyDQogKiAgfXxudWxsfSBub2RlIC0gVGhlIG5vZGUgYXQgdGFyZ2V0SW5kZXgsIG9yIG51bGwgaWYgbm90IGZvdW5kDQogKi8KCmlmICh0eXBlb2YgZ2V0VmlzaWJsZU5vZGVDb3VudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0VmlzaWJsZU5vZGVDb3VudCAmJiBnZXRWaXNpYmxlTm9kZUNvdW50ID09PSBPYmplY3QoZ2V0VmlzaWJsZU5vZGVDb3VudCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXRWaXNpYmxlTm9kZUNvdW50KSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRWaXNpYmxlTm9kZUNvdW50LCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0VmlzaWJsZU5vZGVDb3VudCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4KF9yZWY2KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjYudHJlZURhdGEsCiAgICAgIHRhcmdldEluZGV4ID0gX3JlZjYuaW5kZXgsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmNi5nZXROb2RlS2V5OwoKICBpZiAoIXRyZWVEYXRhIHx8IHRyZWVEYXRhLmxlbmd0aCA8IDEpIHsKICAgIHJldHVybiBudWxsOwogIH0gLy8gQ2FsbCB0aGUgdHJlZSB0cmF2ZXJzYWwgd2l0aCBhIHBzZXVkby1yb290IG5vZGUKCgogIHZhciByZXN1bHQgPSBnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgoewogICAgdGFyZ2V0SW5kZXg6IHRhcmdldEluZGV4LAogICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgIG5vZGU6IHsKICAgICAgY2hpbGRyZW46IHRyZWVEYXRhLAogICAgICBleHBhbmRlZDogdHJ1ZQogICAgfSwKICAgIGN1cnJlbnRJbmRleDogLTEsCiAgICBwYXRoOiBbXSwKICAgIGxvd2VyU2libGluZ0NvdW50czogW10sCiAgICBpc1BzZXVkb1Jvb3Q6IHRydWUKICB9KTsKCiAgaWYgKHJlc3VsdC5ub2RlKSB7CiAgICByZXR1cm4gcmVzdWx0OwogIH0KCiAgcmV0dXJuIG51bGw7Cn0KLyoqDQogKiBXYWxrIGRlc2NlbmRhbnRzIGRlcHRoLWZpcnN0IGFuZCBjYWxsIGEgY2FsbGJhY2sgb24gZWFjaA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggbm9kZQ0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB2b2lkDQogKi8KCmlmICh0eXBlb2YgZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCAmJiBnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4ID09PSBPYmplY3QoZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4KSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRWaXNpYmxlTm9kZUluZm9BdEluZGV4LCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiB3YWxrKF9yZWY3KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjcudHJlZURhdGEsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmNy5nZXROb2RlS2V5LAogICAgICBjYWxsYmFjayA9IF9yZWY3LmNhbGxiYWNrLAogICAgICBfcmVmNyRpZ25vcmVDb2xsYXBzZWQgPSBfcmVmNy5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWY3JGlnbm9yZUNvbGxhcHNlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY3JGlnbm9yZUNvbGxhcHNlZDsKCiAgaWYgKCF0cmVlRGF0YSB8fCB0cmVlRGF0YS5sZW5ndGggPCAxKSB7CiAgICByZXR1cm47CiAgfQoKICB3YWxrRGVzY2VuZGFudHMoewogICAgY2FsbGJhY2s6IGNhbGxiYWNrLAogICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgaXNQc2V1ZG9Sb290OiB0cnVlLAogICAgbm9kZTogewogICAgICBjaGlsZHJlbjogdHJlZURhdGEKICAgIH0sCiAgICBjdXJyZW50SW5kZXg6IC0xLAogICAgcGF0aDogW10sCiAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdCiAgfSk7Cn0KLyoqDQogKiBQZXJmb3JtIGEgZGVwdGgtZmlyc3QgdHJhbnN2ZXJzYWwgb2YgdGhlIGRlc2NlbmRhbnRzIGFuZA0KICogIG1ha2UgYSBjaGFuZ2UgdG8gZXZlcnkgbm9kZSBpbiB0aGUgdHJlZQ0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsIG9uIGVhY2ggbm9kZQ0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IGNoYW5nZWRUcmVlRGF0YSAtIFRoZSBjaGFuZ2VkIHRyZWUgZGF0YQ0KICovCgppZiAodHlwZW9mIHdhbGsgIT09ICd1bmRlZmluZWQnICYmIHdhbGsgJiYgd2FsayA9PT0gT2JqZWN0KHdhbGspICYmIE9iamVjdC5pc0V4dGVuc2libGUod2FsaykpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2FsaywgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogIndhbGsiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gbWFwKF9yZWY4KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjgudHJlZURhdGEsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmOC5nZXROb2RlS2V5LAogICAgICBjYWxsYmFjayA9IF9yZWY4LmNhbGxiYWNrLAogICAgICBfcmVmOCRpZ25vcmVDb2xsYXBzZWQgPSBfcmVmOC5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWY4JGlnbm9yZUNvbGxhcHNlZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWY4JGlnbm9yZUNvbGxhcHNlZDsKCiAgaWYgKCF0cmVlRGF0YSB8fCB0cmVlRGF0YS5sZW5ndGggPCAxKSB7CiAgICByZXR1cm4gW107CiAgfQoKICByZXR1cm4gbWFwRGVzY2VuZGFudHMoewogICAgY2FsbGJhY2s6IGNhbGxiYWNrLAogICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgaXNQc2V1ZG9Sb290OiB0cnVlLAogICAgbm9kZTogewogICAgICBjaGlsZHJlbjogdHJlZURhdGEKICAgIH0sCiAgICBjdXJyZW50SW5kZXg6IC0xLAogICAgcGF0aDogW10sCiAgICBsb3dlclNpYmxpbmdDb3VudHM6IFtdCiAgfSkubm9kZS5jaGlsZHJlbjsKfQovKioNCiAqIEV4cGFuZCBvciBjbG9zZSBldmVyeSBub2RlIGluIHRoZSB0cmVlDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0gez9ib29sZWFufSBleHBhbmRlZCAtIFdoZXRoZXIgdGhlIG5vZGUgaXMgZXhwYW5kZWQgb3Igbm90DQogKg0KICogQHJldHVybiB7T2JqZWN0W119IGNoYW5nZWRUcmVlRGF0YSAtIFRoZSBjaGFuZ2VkIHRyZWUgZGF0YQ0KICovCgppZiAodHlwZW9mIG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgbWFwICYmIG1hcCA9PT0gT2JqZWN0KG1hcCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShtYXApKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogIm1hcCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiB0b2dnbGVFeHBhbmRlZEZvckFsbChfcmVmOSkgewogIHZhciB0cmVlRGF0YSA9IF9yZWY5LnRyZWVEYXRhLAogICAgICBfcmVmOSRleHBhbmRlZCA9IF9yZWY5LmV4cGFuZGVkLAogICAgICBleHBhbmRlZCA9IF9yZWY5JGV4cGFuZGVkID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjkkZXhwYW5kZWQ7CiAgcmV0dXJuIG1hcCh7CiAgICB0cmVlRGF0YTogdHJlZURhdGEsCiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soX3JlZjEwKSB7CiAgICAgIHZhciBub2RlID0gX3JlZjEwLm5vZGU7CiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBub2RlLCB7CiAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkCiAgICAgIH0pOwogICAgfSwKICAgIGdldE5vZGVLZXk6IGZ1bmN0aW9uIGdldE5vZGVLZXkoX3JlZjExKSB7CiAgICAgIHZhciB0cmVlSW5kZXggPSBfcmVmMTEudHJlZUluZGV4OwogICAgICByZXR1cm4gdHJlZUluZGV4OwogICAgfSwKICAgIGlnbm9yZUNvbGxhcHNlZDogZmFsc2UKICB9KTsKfQovKioNCiAqIFJlcGxhY2VzIG5vZGUgYXQgcGF0aCB3aXRoIG9iamVjdCwgb3IgY2FsbGJhY2stZGVmaW5lZCBvYmplY3QNCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGENCiAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBjaGFuZ2VkDQogKiBAcGFyYW0ge2Z1bmN0aW9ufGFueX0gbmV3Tm9kZSAtIE5vZGUgdG8gcmVwbGFjZSB0aGUgbm9kZSBhdCB0aGUgcGF0aCB3aXRoLCBvciBhIGZ1bmN0aW9uIHByb2R1Y2luZyB0aGUgbmV3IG5vZGUNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge09iamVjdFtdfSBjaGFuZ2VkVHJlZURhdGEgLSBUaGUgY2hhbmdlZCB0cmVlIGRhdGENCiAqLwoKaWYgKHR5cGVvZiB0b2dnbGVFeHBhbmRlZEZvckFsbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdG9nZ2xlRXhwYW5kZWRGb3JBbGwgJiYgdG9nZ2xlRXhwYW5kZWRGb3JBbGwgPT09IE9iamVjdCh0b2dnbGVFeHBhbmRlZEZvckFsbCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZSh0b2dnbGVFeHBhbmRlZEZvckFsbCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG9nZ2xlRXhwYW5kZWRGb3JBbGwsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJ0b2dnbGVFeHBhbmRlZEZvckFsbCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VOb2RlQXRQYXRoKF9yZWYxMikgewogIHZhciB0cmVlRGF0YSA9IF9yZWYxMi50cmVlRGF0YSwKICAgICAgcGF0aCA9IF9yZWYxMi5wYXRoLAogICAgICBuZXdOb2RlID0gX3JlZjEyLm5ld05vZGUsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMTIuZ2V0Tm9kZUtleSwKICAgICAgX3JlZjEyJGlnbm9yZUNvbGxhcHNlID0gX3JlZjEyLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjEyJGlnbm9yZUNvbGxhcHNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjEyJGlnbm9yZUNvbGxhcHNlOwogIHZhciBSRVNVTFRfTUlTUyA9ICJSRVNVTFRfTUlTUyI7CgogIHZhciB0cmF2ZXJzZSA9IGZ1bmN0aW9uIHRyYXZlcnNlKF9yZWYxMykgewogICAgdmFyIF9yZWYxMyRpc1BzZXVkb1Jvb3QgPSBfcmVmMTMuaXNQc2V1ZG9Sb290LAogICAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWYxMyRpc1BzZXVkb1Jvb3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjEzJGlzUHNldWRvUm9vdCwKICAgICAgICBub2RlID0gX3JlZjEzLm5vZGUsCiAgICAgICAgY3VycmVudFRyZWVJbmRleCA9IF9yZWYxMy5jdXJyZW50VHJlZUluZGV4LAogICAgICAgIHBhdGhJbmRleCA9IF9yZWYxMy5wYXRoSW5kZXg7CgogICAgaWYgKCFpc1BzZXVkb1Jvb3QgJiYgZ2V0Tm9kZUtleSh7CiAgICAgIG5vZGU6IG5vZGUsCiAgICAgIHRyZWVJbmRleDogY3VycmVudFRyZWVJbmRleAogICAgfSkgIT09IHBhdGhbcGF0aEluZGV4XSkgewogICAgICByZXR1cm4gUkVTVUxUX01JU1M7CiAgICB9CgogICAgaWYgKHBhdGhJbmRleCA+PSBwYXRoLmxlbmd0aCAtIDEpIHsKICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmluYWwgbG9jYXRpb24gaW4gdGhlIHBhdGgsIHJldHVybiBpdHMgY2hhbmdlZCBmb3JtCiAgICAgIHJldHVybiB0eXBlb2YgbmV3Tm9kZSA9PT0gImZ1bmN0aW9uIiA/IG5ld05vZGUoewogICAgICAgIG5vZGU6IG5vZGUsCiAgICAgICAgdHJlZUluZGV4OiBjdXJyZW50VHJlZUluZGV4CiAgICAgIH0pIDogbmV3Tm9kZTsKICAgIH0KCiAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHsKICAgICAgLy8gSWYgdGhpcyBub2RlIGlzIHBhcnQgb2YgdGhlIHBhdGgsIGJ1dCBoYXMgbm8gY2hpbGRyZW4sIHJldHVybiB0aGUgdW5jaGFuZ2VkIG5vZGUKICAgICAgdGhyb3cgbmV3IEVycm9yKCJQYXRoIHJlZmVyZW5jZWQgY2hpbGRyZW4gb2Ygbm9kZSB3aXRoIG5vIGNoaWxkcmVuLiIpOwogICAgfQoKICAgIHZhciBuZXh0VHJlZUluZGV4ID0gY3VycmVudFRyZWVJbmRleCArIDE7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgIHZhciBfcmVzdWx0ID0gdHJhdmVyc2UoewogICAgICAgIG5vZGU6IG5vZGUuY2hpbGRyZW5baV0sCiAgICAgICAgY3VycmVudFRyZWVJbmRleDogbmV4dFRyZWVJbmRleCwKICAgICAgICBwYXRoSW5kZXg6IHBhdGhJbmRleCArIDEKICAgICAgfSk7IC8vIElmIHRoZSByZXN1bHQgd2VudCBkb3duIHRoZSBjb3JyZWN0IHBhdGgKCgogICAgICBpZiAoX3Jlc3VsdCAhPT0gUkVTVUxUX01JU1MpIHsKICAgICAgICBpZiAoX3Jlc3VsdCkgewogICAgICAgICAgLy8gSWYgdGhlIHJlc3VsdCB3YXMgdHJ1dGh5IChpbiB0aGlzIGNhc2UsIGFuIG9iamVjdCksCiAgICAgICAgICAvLyAgcGFzcyBpdCB0byB0aGUgbmV4dCBsZXZlbCBvZiByZWN1cnNpb24gdXAKICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBub2RlLCB7CiAgICAgICAgICAgIGNoaWxkcmVuOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG5vZGUuY2hpbGRyZW4uc2xpY2UoMCwgaSkpLCBbX3Jlc3VsdF0sIF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKGkgKyAxKSkpCiAgICAgICAgICB9KTsKICAgICAgICB9IC8vIElmIHRoZSByZXN1bHQgd2FzIGZhbHN5IChyZXR1cm5lZCBmcm9tIHRoZSBuZXdOb2RlIGZ1bmN0aW9uKSwgdGhlbgogICAgICAgIC8vICBkZWxldGUgdGhlIG5vZGUgZnJvbSB0aGUgYXJyYXkuCgoKICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgbm9kZSwgewogICAgICAgICAgY2hpbGRyZW46IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZS5jaGlsZHJlbi5zbGljZSgwLCBpKSksIF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKGkgKyAxKSkpCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIG5leHRUcmVlSW5kZXggKz0gMSArIGdldERlc2NlbmRhbnRDb3VudCh7CiAgICAgICAgbm9kZTogbm9kZS5jaGlsZHJlbltpXSwKICAgICAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZAogICAgICB9KTsKICAgIH0KCiAgICByZXR1cm4gUkVTVUxUX01JU1M7CiAgfTsgLy8gVXNlIGEgcHNldWRvLXJvb3Qgbm9kZSBpbiB0aGUgYmVnaW5uaW5nIHRyYXZlcnNhbAoKCiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlKHsKICAgIG5vZGU6IHsKICAgICAgY2hpbGRyZW46IHRyZWVEYXRhCiAgICB9LAogICAgY3VycmVudFRyZWVJbmRleDogLTEsCiAgICBwYXRoSW5kZXg6IC0xLAogICAgaXNQc2V1ZG9Sb290OiB0cnVlCiAgfSk7CgogIGlmIChyZXN1bHQgPT09IFJFU1VMVF9NSVNTKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIk5vIG5vZGUgZm91bmQgYXQgdGhlIGdpdmVuIHBhdGguIik7CiAgfQoKICByZXR1cm4gcmVzdWx0LmNoaWxkcmVuOwp9Ci8qKg0KICogUmVtb3ZlcyB0aGUgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyB0cmVlRGF0YS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3RbXX0gdHJlZURhdGENCiAqIEBwYXJhbSB7bnVtYmVyW118c3RyaW5nW119IHBhdGggLSBBcnJheSBvZiBrZXlzIGxlYWRpbmcgdXAgdG8gbm9kZSB0byBiZSBkZWxldGVkDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHtPYmplY3RbXX0gY2hhbmdlZFRyZWVEYXRhIC0gVGhlIHRyZWUgZGF0YSB3aXRoIHRoZSBub2RlIHJlbW92ZWQNCiAqLwoKaWYgKHR5cGVvZiBjaGFuZ2VOb2RlQXRQYXRoICE9PSAndW5kZWZpbmVkJyAmJiBjaGFuZ2VOb2RlQXRQYXRoICYmIGNoYW5nZU5vZGVBdFBhdGggPT09IE9iamVjdChjaGFuZ2VOb2RlQXRQYXRoKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGNoYW5nZU5vZGVBdFBhdGgpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoYW5nZU5vZGVBdFBhdGgsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJjaGFuZ2VOb2RlQXRQYXRoIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGVBdFBhdGgoX3JlZjE0KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjE0LnRyZWVEYXRhLAogICAgICBwYXRoID0gX3JlZjE0LnBhdGgsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMTQuZ2V0Tm9kZUtleSwKICAgICAgX3JlZjE0JGlnbm9yZUNvbGxhcHNlID0gX3JlZjE0Lmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjE0JGlnbm9yZUNvbGxhcHNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjE0JGlnbm9yZUNvbGxhcHNlOwogIHJldHVybiBjaGFuZ2VOb2RlQXRQYXRoKHsKICAgIHRyZWVEYXRhOiB0cmVlRGF0YSwKICAgIHBhdGg6IHBhdGgsCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBuZXdOb2RlOiBudWxsIC8vIERlbGV0ZSB0aGUgbm9kZQoKICB9KTsKfQovKioNCiAqIFJlbW92ZXMgdGhlIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJlZURhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0ge251bWJlcltdfHN0cmluZ1tdfSBwYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHVwIHRvIG5vZGUgdG8gYmUgZGVsZXRlZA0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQNCiAqIEByZXR1cm4ge09iamVjdFtdfSByZXN1bHQudHJlZURhdGEgLSBUaGUgdHJlZSBkYXRhIHdpdGggdGhlIG5vZGUgcmVtb3ZlZA0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQubm9kZSAtIFRoZSBub2RlIHRoYXQgd2FzIHJlbW92ZWQNCiAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LnRyZWVJbmRleCAtIFRoZSBwcmV2aW91cyB0cmVlSW5kZXggb2YgdGhlIHJlbW92ZWQgbm9kZQ0KICovCgppZiAodHlwZW9mIHJlbW92ZU5vZGVBdFBhdGggIT09ICd1bmRlZmluZWQnICYmIHJlbW92ZU5vZGVBdFBhdGggJiYgcmVtb3ZlTm9kZUF0UGF0aCA9PT0gT2JqZWN0KHJlbW92ZU5vZGVBdFBhdGgpICYmIE9iamVjdC5pc0V4dGVuc2libGUocmVtb3ZlTm9kZUF0UGF0aCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVtb3ZlTm9kZUF0UGF0aCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogInJlbW92ZU5vZGVBdFBhdGgiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShfcmVmMTUpIHsKICB2YXIgdHJlZURhdGEgPSBfcmVmMTUudHJlZURhdGEsCiAgICAgIHBhdGggPSBfcmVmMTUucGF0aCwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYxNS5nZXROb2RlS2V5LAogICAgICBfcmVmMTUkaWdub3JlQ29sbGFwc2UgPSBfcmVmMTUuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMTUkaWdub3JlQ29sbGFwc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMTUkaWdub3JlQ29sbGFwc2U7CiAgdmFyIHJlbW92ZWROb2RlID0gbnVsbDsKICB2YXIgcmVtb3ZlZFRyZWVJbmRleCA9IG51bGw7CiAgdmFyIG5leHRUcmVlRGF0YSA9IGNoYW5nZU5vZGVBdFBhdGgoewogICAgdHJlZURhdGE6IHRyZWVEYXRhLAogICAgcGF0aDogcGF0aCwKICAgIGdldE5vZGVLZXk6IGdldE5vZGVLZXksCiAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgIG5ld05vZGU6IGZ1bmN0aW9uIG5ld05vZGUoX3JlZjE2KSB7CiAgICAgIHZhciBub2RlID0gX3JlZjE2Lm5vZGUsCiAgICAgICAgICB0cmVlSW5kZXggPSBfcmVmMTYudHJlZUluZGV4OwogICAgICAvLyBTdG9yZSB0aGUgdGFyZ2V0IG5vZGUgYW5kIGRlbGV0ZSBpdCBmcm9tIHRoZSB0cmVlCiAgICAgIHJlbW92ZWROb2RlID0gbm9kZTsKICAgICAgcmVtb3ZlZFRyZWVJbmRleCA9IHRyZWVJbmRleDsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgfSk7CiAgcmV0dXJuIHsKICAgIHRyZWVEYXRhOiBuZXh0VHJlZURhdGEsCiAgICBub2RlOiByZW1vdmVkTm9kZSwKICAgIHRyZWVJbmRleDogcmVtb3ZlZFRyZWVJbmRleAogIH07Cn0KLyoqDQogKiBHZXRzIHRoZSBub2RlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YQ0KICogQHBhcmFtIHtudW1iZXJbXXxzdHJpbmdbXX0gcGF0aCAtIEFycmF5IG9mIGtleXMgbGVhZGluZyB1cCB0byBub2RlIHRvIGJlIGRlbGV0ZWQNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICoNCiAqIEByZXR1cm4ge09iamVjdHxudWxsfSBub2RlSW5mbyAtIFRoZSBub2RlIGluZm8gYXQgdGhlIGdpdmVuIHBhdGgsIG9yIG51bGwgaWYgbm90IGZvdW5kDQogKi8KCmlmICh0eXBlb2YgcmVtb3ZlTm9kZSAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVtb3ZlTm9kZSAmJiByZW1vdmVOb2RlID09PSBPYmplY3QocmVtb3ZlTm9kZSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShyZW1vdmVOb2RlKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW1vdmVOb2RlLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAicmVtb3ZlTm9kZSIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlQXRQYXRoKF9yZWYxNykgewogIHZhciB0cmVlRGF0YSA9IF9yZWYxNy50cmVlRGF0YSwKICAgICAgcGF0aCA9IF9yZWYxNy5wYXRoLAogICAgICBnZXROb2RlS2V5ID0gX3JlZjE3LmdldE5vZGVLZXksCiAgICAgIF9yZWYxNyRpZ25vcmVDb2xsYXBzZSA9IF9yZWYxNy5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYxNyRpZ25vcmVDb2xsYXBzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYxNyRpZ25vcmVDb2xsYXBzZTsKICB2YXIgZm91bmROb2RlSW5mbyA9IG51bGw7CgogIHRyeSB7CiAgICBjaGFuZ2VOb2RlQXRQYXRoKHsKICAgICAgdHJlZURhdGE6IHRyZWVEYXRhLAogICAgICBwYXRoOiBwYXRoLAogICAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgICBpZ25vcmVDb2xsYXBzZWQ6IGlnbm9yZUNvbGxhcHNlZCwKICAgICAgbmV3Tm9kZTogZnVuY3Rpb24gbmV3Tm9kZShfcmVmMTgpIHsKICAgICAgICB2YXIgbm9kZSA9IF9yZWYxOC5ub2RlLAogICAgICAgICAgICB0cmVlSW5kZXggPSBfcmVmMTgudHJlZUluZGV4OwogICAgICAgIGZvdW5kTm9kZUluZm8gPSB7CiAgICAgICAgICBub2RlOiBub2RlLAogICAgICAgICAgdHJlZUluZGV4OiB0cmVlSW5kZXgKICAgICAgICB9OwogICAgICAgIHJldHVybiBub2RlOwogICAgICB9CiAgICB9KTsKICB9IGNhdGNoIChlcnIpIHsvLyBJZ25vcmUgdGhlIGVycm9yIC0tIHRoZSBudWxsIHJldHVybiB3aWxsIGJlIGV4cGxhbmF0aW9uIGVub3VnaAogIH0KCiAgcmV0dXJuIGZvdW5kTm9kZUluZm87Cn0KLyoqDQogKiBBZGRzIHRoZSBub2RlIHRvIHRoZSBzcGVjaWZpZWQgcGFyZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmcgdHJlZURhdGEuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhDQogKiBAcGFyYW0geyFPYmplY3R9IG5ld05vZGUgLSBUaGUgbm9kZSB0byBpbnNlcnQNCiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gcGFyZW50S2V5IC0gVGhlIGtleSBvZiB0aGUgdG8tYmUgcGFyZW50Tm9kZSBvZiB0aGUgbm9kZQ0KICogQHBhcmFtIHshZnVuY3Rpb259IGdldE5vZGVLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YSBhbmQgdHJlZSBpbmRleA0KICogQHBhcmFtIHtib29sZWFuPX0gaWdub3JlQ29sbGFwc2VkIC0gSWdub3JlIGNoaWxkcmVuIG9mIG5vZGVzIHdpdGhvdXQgYGV4cGFuZGVkYCBzZXQgdG8gYHRydWVgDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRQYXJlbnQgLSBJZiB0cnVlLCBleHBhbmRzIHRoZSBwYXJlbnROb2RlIHNwZWNpZmllZCBieSBwYXJlbnRQYXRoDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBhZGRBc0ZpcnN0Q2hpbGQgLSBJZiB0cnVlLCBhZGRzIG5ldyBub2RlIGFzIGZpcnN0IGNoaWxkIG9mIHRyZWUNCiAqDQogKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdA0KICogQHJldHVybiB7T2JqZWN0W119IHJlc3VsdC50cmVlRGF0YSAtIFRoZSB1cGRhdGVkIHRyZWUgZGF0YQ0KICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQudHJlZUluZGV4IC0gVGhlIHRyZWUgaW5kZXggYXQgd2hpY2ggdGhlIG5vZGUgd2FzIGluc2VydGVkDQogKi8KCmlmICh0eXBlb2YgZ2V0Tm9kZUF0UGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0Tm9kZUF0UGF0aCAmJiBnZXROb2RlQXRQYXRoID09PSBPYmplY3QoZ2V0Tm9kZUF0UGF0aCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXROb2RlQXRQYXRoKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXROb2RlQXRQYXRoLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0Tm9kZUF0UGF0aCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBhZGROb2RlVW5kZXJQYXJlbnQoX3JlZjE5KSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjE5LnRyZWVEYXRhLAogICAgICBuZXdOb2RlID0gX3JlZjE5Lm5ld05vZGUsCiAgICAgIF9yZWYxOSRwYXJlbnRLZXkgPSBfcmVmMTkucGFyZW50S2V5LAogICAgICBwYXJlbnRLZXkgPSBfcmVmMTkkcGFyZW50S2V5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjE5JHBhcmVudEtleSwKICAgICAgZ2V0Tm9kZUtleSA9IF9yZWYxOS5nZXROb2RlS2V5LAogICAgICBfcmVmMTkkaWdub3JlQ29sbGFwc2UgPSBfcmVmMTkuaWdub3JlQ29sbGFwc2VkLAogICAgICBpZ25vcmVDb2xsYXBzZWQgPSBfcmVmMTkkaWdub3JlQ29sbGFwc2UgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMTkkaWdub3JlQ29sbGFwc2UsCiAgICAgIF9yZWYxOSRleHBhbmRQYXJlbnQgPSBfcmVmMTkuZXhwYW5kUGFyZW50LAogICAgICBleHBhbmRQYXJlbnQgPSBfcmVmMTkkZXhwYW5kUGFyZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxOSRleHBhbmRQYXJlbnQsCiAgICAgIF9yZWYxOSRhZGRBc0ZpcnN0Q2hpbCA9IF9yZWYxOS5hZGRBc0ZpcnN0Q2hpbGQsCiAgICAgIGFkZEFzRmlyc3RDaGlsZCA9IF9yZWYxOSRhZGRBc0ZpcnN0Q2hpbCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTkkYWRkQXNGaXJzdENoaWw7CgogIGlmIChwYXJlbnRLZXkgPT09IG51bGwpIHsKICAgIHJldHVybiB7CiAgICAgIHRyZWVEYXRhOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRyZWVEYXRhIHx8IFtdKSwgW25ld05vZGVdKSwKICAgICAgdHJlZUluZGV4OiAodHJlZURhdGEgfHwgW10pLmxlbmd0aAogICAgfTsKICB9CgogIHZhciBpbnNlcnRlZFRyZWVJbmRleCA9IG51bGw7CiAgdmFyIGhhc0JlZW5BZGRlZCA9IGZhbHNlOwogIHZhciBjaGFuZ2VkVHJlZURhdGEgPSBtYXAoewogICAgdHJlZURhdGE6IHRyZWVEYXRhLAogICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKF9yZWYyMCkgewogICAgICB2YXIgbm9kZSA9IF9yZWYyMC5ub2RlLAogICAgICAgICAgdHJlZUluZGV4ID0gX3JlZjIwLnRyZWVJbmRleCwKICAgICAgICAgIHBhdGggPSBfcmVmMjAucGF0aDsKICAgICAgdmFyIGtleSA9IHBhdGggPyBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gOiBudWxsOyAvLyBSZXR1cm4gbm9kZXMgdGhhdCBhcmUgbm90IHRoZSBwYXJlbnQgYXMtaXMKCiAgICAgIGlmIChoYXNCZWVuQWRkZWQgfHwga2V5ICE9PSBwYXJlbnRLZXkpIHsKICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgfQoKICAgICAgaGFzQmVlbkFkZGVkID0gdHJ1ZTsKCiAgICAgIHZhciBwYXJlbnROb2RlID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSk7CgogICAgICBpZiAoZXhwYW5kUGFyZW50KSB7CiAgICAgICAgcGFyZW50Tm9kZS5leHBhbmRlZCA9IHRydWU7CiAgICAgIH0gLy8gSWYgbm8gY2hpbGRyZW4gZXhpc3QgeWV0LCBqdXN0IGFkZCB0aGUgc2luZ2xlIG5ld05vZGUKCgogICAgICBpZiAoIXBhcmVudE5vZGUuY2hpbGRyZW4pIHsKICAgICAgICBpbnNlcnRlZFRyZWVJbmRleCA9IHRyZWVJbmRleCArIDE7CiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHBhcmVudE5vZGUsIHsKICAgICAgICAgIGNoaWxkcmVuOiBbbmV3Tm9kZV0KICAgICAgICB9KTsKICAgICAgfQoKICAgICAgaWYgKHR5cGVvZiBwYXJlbnROb2RlLmNoaWxkcmVuID09PSAiZnVuY3Rpb24iKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgYWRkIHRvIGNoaWxkcmVuIGRlZmluZWQgYnkgYSBmdW5jdGlvbiIpOwogICAgICB9CgogICAgICB2YXIgbmV4dFRyZWVJbmRleCA9IHRyZWVJbmRleCArIDE7CgogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICBuZXh0VHJlZUluZGV4ICs9IDEgKyBnZXREZXNjZW5kYW50Q291bnQoewogICAgICAgICAgbm9kZTogcGFyZW50Tm9kZS5jaGlsZHJlbltpXSwKICAgICAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkCiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIGluc2VydGVkVHJlZUluZGV4ID0gbmV4dFRyZWVJbmRleDsKICAgICAgdmFyIGNoaWxkcmVuID0gYWRkQXNGaXJzdENoaWxkID8gW25ld05vZGVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGFyZW50Tm9kZS5jaGlsZHJlbikpIDogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXJlbnROb2RlLmNoaWxkcmVuKSwgW25ld05vZGVdKTsKICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIHBhcmVudE5vZGUsIHsKICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4KICAgICAgfSk7CiAgICB9CiAgfSk7CgogIGlmICghaGFzQmVlbkFkZGVkKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIk5vIG5vZGUgZm91bmQgd2l0aCB0aGUgZ2l2ZW4ga2V5LiIpOwogIH0KCiAgcmV0dXJuIHsKICAgIHRyZWVEYXRhOiBjaGFuZ2VkVHJlZURhdGEsCiAgICB0cmVlSW5kZXg6IGluc2VydGVkVHJlZUluZGV4CiAgfTsKfQoKaWYgKHR5cGVvZiBhZGROb2RlVW5kZXJQYXJlbnQgIT09ICd1bmRlZmluZWQnICYmIGFkZE5vZGVVbmRlclBhcmVudCAmJiBhZGROb2RlVW5kZXJQYXJlbnQgPT09IE9iamVjdChhZGROb2RlVW5kZXJQYXJlbnQpICYmIE9iamVjdC5pc0V4dGVuc2libGUoYWRkTm9kZVVuZGVyUGFyZW50KSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhZGROb2RlVW5kZXJQYXJlbnQsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJhZGROb2RlVW5kZXJQYXJlbnQiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpmdW5jdGlvbiBhZGROb2RlQXREZXB0aEFuZEluZGV4KF9yZWYyMSkgewogIHZhciB0YXJnZXREZXB0aCA9IF9yZWYyMS50YXJnZXREZXB0aCwKICAgICAgbWluaW11bVRyZWVJbmRleCA9IF9yZWYyMS5taW5pbXVtVHJlZUluZGV4LAogICAgICBuZXdOb2RlID0gX3JlZjIxLm5ld05vZGUsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYyMS5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGV4cGFuZFBhcmVudCA9IF9yZWYyMS5leHBhbmRQYXJlbnQsCiAgICAgIF9yZWYyMSRpc1BzZXVkb1Jvb3QgPSBfcmVmMjEuaXNQc2V1ZG9Sb290LAogICAgICBpc1BzZXVkb1Jvb3QgPSBfcmVmMjEkaXNQc2V1ZG9Sb290ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyMSRpc1BzZXVkb1Jvb3QsCiAgICAgIGlzTGFzdENoaWxkID0gX3JlZjIxLmlzTGFzdENoaWxkLAogICAgICBub2RlID0gX3JlZjIxLm5vZGUsCiAgICAgIGN1cnJlbnRJbmRleCA9IF9yZWYyMS5jdXJyZW50SW5kZXgsCiAgICAgIGN1cnJlbnREZXB0aCA9IF9yZWYyMS5jdXJyZW50RGVwdGgsCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMjEuZ2V0Tm9kZUtleSwKICAgICAgX3JlZjIxJHBhdGggPSBfcmVmMjEucGF0aCwKICAgICAgcGF0aCA9IF9yZWYyMSRwYXRoID09PSB2b2lkIDAgPyBbXSA6IF9yZWYyMSRwYXRoOwoKICB2YXIgc2VsZlBhdGggPSBmdW5jdGlvbiBzZWxmUGF0aChuKSB7CiAgICByZXR1cm4gaXNQc2V1ZG9Sb290ID8gW10gOiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHBhdGgpLCBbZ2V0Tm9kZUtleSh7CiAgICAgIG5vZGU6IG4sCiAgICAgIHRyZWVJbmRleDogY3VycmVudEluZGV4CiAgICB9KV0pOwogIH07IC8vIElmIHRoZSBjdXJyZW50IHBvc2l0aW9uIGlzIHRoZSBvbmx5IHBvc3NpYmxlIHBsYWNlIHRvIGFkZCwgYWRkIGl0CgoKICBpZiAoY3VycmVudEluZGV4ID49IG1pbmltdW1UcmVlSW5kZXggLSAxIHx8IGlzTGFzdENoaWxkICYmICEobm9kZS5jaGlsZHJlbiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCkpIHsKICAgIGlmICh0eXBlb2Ygbm9kZS5jaGlsZHJlbiA9PT0gImZ1bmN0aW9uIikgewogICAgICB0aHJvdyBuZXcgRXJyb3IoIkNhbm5vdCBhZGQgdG8gY2hpbGRyZW4gZGVmaW5lZCBieSBhIGZ1bmN0aW9uIik7CiAgICB9IGVsc2UgewogICAgICB2YXIgZXh0cmFOb2RlUHJvcHMgPSBleHBhbmRQYXJlbnQgPyB7CiAgICAgICAgZXhwYW5kZWQ6IHRydWUKICAgICAgfSA6IHt9OwoKICAgICAgdmFyIF9uZXh0Tm9kZSA9IF9vYmplY3RTcHJlYWQoe30sIG5vZGUsIGV4dHJhTm9kZVByb3BzLCB7CiAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4gPyBbbmV3Tm9kZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuKSkgOiBbbmV3Tm9kZV0KICAgICAgfSk7CgogICAgICByZXR1cm4gewogICAgICAgIG5vZGU6IF9uZXh0Tm9kZSwKICAgICAgICBuZXh0SW5kZXg6IGN1cnJlbnRJbmRleCArIDIsCiAgICAgICAgaW5zZXJ0ZWRUcmVlSW5kZXg6IGN1cnJlbnRJbmRleCArIDEsCiAgICAgICAgcGFyZW50UGF0aDogc2VsZlBhdGgoX25leHROb2RlKSwKICAgICAgICBwYXJlbnROb2RlOiBpc1BzZXVkb1Jvb3QgPyBudWxsIDogX25leHROb2RlCiAgICAgIH07CiAgICB9CiAgfSAvLyBJZiB0aGlzIGlzIHRoZSB0YXJnZXQgZGVwdGggZm9yIHRoZSBpbnNlcnRpb24sCiAgLy8gaS5lLiwgd2hlcmUgdGhlIG5ld05vZGUgY2FuIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IG5vZGUncyBjaGlsZHJlbgoKCiAgaWYgKGN1cnJlbnREZXB0aCA+PSB0YXJnZXREZXB0aCAtIDEpIHsKICAgIC8vIFNraXAgb3ZlciBub2RlcyB3aXRoIG5vIGNoaWxkcmVuIG9yIGhpZGRlbiBjaGlsZHJlbgogICAgaWYgKCFub2RlLmNoaWxkcmVuIHx8IHR5cGVvZiBub2RlLmNoaWxkcmVuID09PSAiZnVuY3Rpb24iIHx8IG5vZGUuZXhwYW5kZWQgIT09IHRydWUgJiYgaWdub3JlQ29sbGFwc2VkICYmICFpc1BzZXVkb1Jvb3QpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICBub2RlOiBub2RlLAogICAgICAgIG5leHRJbmRleDogY3VycmVudEluZGV4ICsgMQogICAgICB9OwogICAgfSAvLyBTY2FuIG92ZXIgdGhlIGNoaWxkcmVuIHRvIHNlZSBpZiB0aGVyZSdzIGEgcGxhY2UgYW1vbmcgdGhlbSB0aGF0IGZ1bGZpbGxzCiAgICAvLyB0aGUgbWluaW11bVRyZWVJbmRleCByZXF1aXJlbWVudAoKCiAgICB2YXIgX2NoaWxkSW5kZXggPSBjdXJyZW50SW5kZXggKyAxOwoKICAgIHZhciBfaW5zZXJ0ZWRUcmVlSW5kZXggPSBudWxsOwogICAgdmFyIGluc2VydEluZGV4ID0gbnVsbDsKCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgLy8gSWYgYSB2YWxpZCBsb2NhdGlvbiBpcyBmb3VuZCwgbWFyayBpdCBhcyB0aGUgaW5zZXJ0aW9uIGxvY2F0aW9uIGFuZAogICAgICAvLyBicmVhayBvdXQgb2YgdGhlIGxvb3AKICAgICAgaWYgKF9jaGlsZEluZGV4ID49IG1pbmltdW1UcmVlSW5kZXgpIHsKICAgICAgICBfaW5zZXJ0ZWRUcmVlSW5kZXggPSBfY2hpbGRJbmRleDsKICAgICAgICBpbnNlcnRJbmRleCA9IGk7CiAgICAgICAgYnJlYWs7CiAgICAgIH0gLy8gSW5jcmVtZW50IHRoZSBpbmRleCBieSB0aGUgY2hpbGQgaXRzZWxmIHBsdXMgdGhlIG51bWJlciBvZiBkZXNjZW5kYW50cyBpdCBoYXMKCgogICAgICBfY2hpbGRJbmRleCArPSAxICsgZ2V0RGVzY2VuZGFudENvdW50KHsKICAgICAgICBub2RlOiBub2RlLmNoaWxkcmVuW2ldLAogICAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkCiAgICAgIH0pOwogICAgfSAvLyBJZiBubyB2YWxpZCBpbmRpY2VzIHRvIGFkZCB0aGUgbm9kZSB3ZXJlIGZvdW5kCgoKICAgIGlmIChpbnNlcnRJbmRleCA9PT0gbnVsbCkgewogICAgICAvLyBJZiB0aGUgbGFzdCBwb3NpdGlvbiBpbiB0aGlzIG5vZGUncyBjaGlsZHJlbiBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gaW5kZXgKICAgICAgLy8gYW5kIHRoZXJlIGFyZSBtb3JlIGNoaWxkcmVuIG9uIHRoZSBsZXZlbCBvZiB0aGlzIG5vZGUsIHJldHVybiB3aXRob3V0IGluc2VydGlvbgogICAgICBpZiAoX2NoaWxkSW5kZXggPCBtaW5pbXVtVHJlZUluZGV4ICYmICFpc0xhc3RDaGlsZCkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICBub2RlOiBub2RlLAogICAgICAgICAgbmV4dEluZGV4OiBfY2hpbGRJbmRleAogICAgICAgIH07CiAgICAgIH0gLy8gVXNlIHRoZSBsYXN0IHBvc2l0aW9uIGluIHRoZSBjaGlsZHJlbiBhcnJheSB0byBpbnNlcnQgdGhlIG5ld05vZGUKCgogICAgICBfaW5zZXJ0ZWRUcmVlSW5kZXggPSBfY2hpbGRJbmRleDsKICAgICAgaW5zZXJ0SW5kZXggPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsKICAgIH0gLy8gSW5zZXJ0IHRoZSBuZXdOb2RlIGF0IHRoZSBpbnNlcnRJbmRleAoKCiAgICB2YXIgX25leHROb2RlMiA9IF9vYmplY3RTcHJlYWQoe30sIG5vZGUsIHsKICAgICAgY2hpbGRyZW46IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZS5jaGlsZHJlbi5zbGljZSgwLCBpbnNlcnRJbmRleCkpLCBbbmV3Tm9kZV0sIF90b0NvbnN1bWFibGVBcnJheShub2RlLmNoaWxkcmVuLnNsaWNlKGluc2VydEluZGV4KSkpCiAgICB9KTsgLy8gUmV0dXJuIG5vZGUgd2l0aCBzdWNjZXNzZnVsIGluc2VydCByZXN1bHQKCgogICAgcmV0dXJuIHsKICAgICAgbm9kZTogX25leHROb2RlMiwKICAgICAgbmV4dEluZGV4OiBfY2hpbGRJbmRleCwKICAgICAgaW5zZXJ0ZWRUcmVlSW5kZXg6IF9pbnNlcnRlZFRyZWVJbmRleCwKICAgICAgcGFyZW50UGF0aDogc2VsZlBhdGgoX25leHROb2RlMiksCiAgICAgIHBhcmVudE5vZGU6IGlzUHNldWRvUm9vdCA/IG51bGwgOiBfbmV4dE5vZGUyCiAgICB9OwogIH0gLy8gU2tpcCBvdmVyIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gb3IgaGlkZGVuIGNoaWxkcmVuCgoKICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgdHlwZW9mIG5vZGUuY2hpbGRyZW4gPT09ICJmdW5jdGlvbiIgfHwgbm9kZS5leHBhbmRlZCAhPT0gdHJ1ZSAmJiBpZ25vcmVDb2xsYXBzZWQgJiYgIWlzUHNldWRvUm9vdCkgewogICAgcmV0dXJuIHsKICAgICAgbm9kZTogbm9kZSwKICAgICAgbmV4dEluZGV4OiBjdXJyZW50SW5kZXggKyAxCiAgICB9OwogIH0gLy8gR2V0IGFsbCBkZXNjZW5kYW50cwoKCiAgdmFyIGluc2VydGVkVHJlZUluZGV4ID0gbnVsbDsKICB2YXIgcGF0aEZyYWdtZW50ID0gbnVsbDsKICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7CiAgdmFyIGNoaWxkSW5kZXggPSBjdXJyZW50SW5kZXggKyAxOwogIHZhciBuZXdDaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47CgogIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW4gIT09ICJmdW5jdGlvbiIpIHsKICAgIG5ld0NoaWxkcmVuID0gbmV3Q2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCwgaSkgewogICAgICBpZiAoaW5zZXJ0ZWRUcmVlSW5kZXggIT09IG51bGwpIHsKICAgICAgICByZXR1cm4gY2hpbGQ7CiAgICAgIH0KCiAgICAgIHZhciBtYXBSZXN1bHQgPSBhZGROb2RlQXREZXB0aEFuZEluZGV4KHsKICAgICAgICB0YXJnZXREZXB0aDogdGFyZ2V0RGVwdGgsCiAgICAgICAgbWluaW11bVRyZWVJbmRleDogbWluaW11bVRyZWVJbmRleCwKICAgICAgICBuZXdOb2RlOiBuZXdOb2RlLAogICAgICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgICAgIGV4cGFuZFBhcmVudDogZXhwYW5kUGFyZW50LAogICAgICAgIGlzTGFzdENoaWxkOiBpc0xhc3RDaGlsZCAmJiBpID09PSBuZXdDaGlsZHJlbi5sZW5ndGggLSAxLAogICAgICAgIG5vZGU6IGNoaWxkLAogICAgICAgIGN1cnJlbnRJbmRleDogY2hpbGRJbmRleCwKICAgICAgICBjdXJyZW50RGVwdGg6IGN1cnJlbnREZXB0aCArIDEsCiAgICAgICAgZ2V0Tm9kZUtleTogZ2V0Tm9kZUtleSwKICAgICAgICBwYXRoOiBbXSAvLyBDYW5ub3QgZGV0ZXJtaW5lIHRoZSBwYXJlbnQgcGF0aCB1bnRpbCB0aGUgY2hpbGRyZW4gaGF2ZSBiZWVuIHByb2Nlc3NlZAoKICAgICAgfSk7CgogICAgICBpZiAoImluc2VydGVkVHJlZUluZGV4IiBpbiBtYXBSZXN1bHQpIHsKICAgICAgICBpbnNlcnRlZFRyZWVJbmRleCA9IG1hcFJlc3VsdC5pbnNlcnRlZFRyZWVJbmRleDsKICAgICAgICBwYXJlbnROb2RlID0gbWFwUmVzdWx0LnBhcmVudE5vZGU7CiAgICAgICAgcGF0aEZyYWdtZW50ID0gbWFwUmVzdWx0LnBhcmVudFBhdGg7CiAgICAgIH0KCiAgICAgIGNoaWxkSW5kZXggPSBtYXBSZXN1bHQubmV4dEluZGV4OwogICAgICByZXR1cm4gbWFwUmVzdWx0Lm5vZGU7CiAgICB9KTsKICB9CgogIHZhciBuZXh0Tm9kZSA9IF9vYmplY3RTcHJlYWQoe30sIG5vZGUsIHsKICAgIGNoaWxkcmVuOiBuZXdDaGlsZHJlbgogIH0pOwoKICB2YXIgcmVzdWx0ID0gewogICAgbm9kZTogbmV4dE5vZGUsCiAgICBuZXh0SW5kZXg6IGNoaWxkSW5kZXgKICB9OwoKICBpZiAoaW5zZXJ0ZWRUcmVlSW5kZXggIT09IG51bGwpIHsKICAgIHJlc3VsdC5pbnNlcnRlZFRyZWVJbmRleCA9IGluc2VydGVkVHJlZUluZGV4OwogICAgcmVzdWx0LnBhcmVudFBhdGggPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHNlbGZQYXRoKG5leHROb2RlKSksIF90b0NvbnN1bWFibGVBcnJheShwYXRoRnJhZ21lbnQpKTsKICAgIHJlc3VsdC5wYXJlbnROb2RlID0gcGFyZW50Tm9kZTsKICB9CgogIHJldHVybiByZXN1bHQ7Cn0KLyoqDQogKiBJbnNlcnQgYSBub2RlIGludG8gdGhlIHRyZWUgYXQgdGhlIGdpdmVuIGRlcHRoLCBhZnRlciB0aGUgbWluaW11bSBpbmRleA0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHshbnVtYmVyfSBkZXB0aCAtIFRoZSBkZXB0aCB0byBpbnNlcnQgdGhlIG5vZGUgYXQgKHRoZSBmaXJzdCBsZXZlbCBvZiB0aGUgYXJyYXkgYmVpbmcgZGVwdGggMCkNCiAqIEBwYXJhbSB7IW51bWJlcn0gbWluaW11bVRyZWVJbmRleCAtIFRoZSBsb3dlc3QgcG9zc2libGUgdHJlZUluZGV4IHRvIGluc2VydCB0aGUgbm9kZSBhdA0KICogQHBhcmFtIHshT2JqZWN0fSBuZXdOb2RlIC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGludG8gdGhlIHRyZWUNCiAqIEBwYXJhbSB7Ym9vbGVhbj19IGlnbm9yZUNvbGxhcHNlZCAtIElnbm9yZSBjaGlsZHJlbiBvZiBub2RlcyB3aXRob3V0IGBleHBhbmRlZGAgc2V0IHRvIGB0cnVlYA0KICogQHBhcmFtIHtib29sZWFuPX0gZXhwYW5kUGFyZW50IC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGFyZW50IG9mIHRoZSBpbnNlcnRlZCBub2RlDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQNCiAqIEByZXR1cm4ge09iamVjdFtdfSByZXN1bHQudHJlZURhdGEgLSBUaGUgdHJlZSBkYXRhIHdpdGggdGhlIG5vZGUgYWRkZWQNCiAqIEByZXR1cm4ge251bWJlcn0gcmVzdWx0LnRyZWVJbmRleCAtIFRoZSB0cmVlIGluZGV4IGF0IHdoaWNoIHRoZSBub2RlIHdhcyBpbnNlcnRlZA0KICogQHJldHVybiB7bnVtYmVyW118c3RyaW5nW119IHJlc3VsdC5wYXRoIC0gQXJyYXkgb2Yga2V5cyBsZWFkaW5nIHRvIHRoZSBub2RlIGxvY2F0aW9uIGFmdGVyIGluc2VydGlvbg0KICogQHJldHVybiB7T2JqZWN0fSByZXN1bHQucGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSBvZiB0aGUgaW5zZXJ0ZWQgbm9kZQ0KICovCgoKZXhwb3J0IGZ1bmN0aW9uIGluc2VydE5vZGUoX3JlZjIyKSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjIyLnRyZWVEYXRhLAogICAgICB0YXJnZXREZXB0aCA9IF9yZWYyMi5kZXB0aCwKICAgICAgbWluaW11bVRyZWVJbmRleCA9IF9yZWYyMi5taW5pbXVtVHJlZUluZGV4LAogICAgICBuZXdOb2RlID0gX3JlZjIyLm5ld05vZGUsCiAgICAgIF9yZWYyMiRnZXROb2RlS2V5ID0gX3JlZjIyLmdldE5vZGVLZXksCiAgICAgIGdldE5vZGVLZXkgPSBfcmVmMjIkZ2V0Tm9kZUtleSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfcmVmMjIkZ2V0Tm9kZUtleSwKICAgICAgX3JlZjIyJGlnbm9yZUNvbGxhcHNlID0gX3JlZjIyLmlnbm9yZUNvbGxhcHNlZCwKICAgICAgaWdub3JlQ29sbGFwc2VkID0gX3JlZjIyJGlnbm9yZUNvbGxhcHNlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjIyJGlnbm9yZUNvbGxhcHNlLAogICAgICBfcmVmMjIkZXhwYW5kUGFyZW50ID0gX3JlZjIyLmV4cGFuZFBhcmVudCwKICAgICAgZXhwYW5kUGFyZW50ID0gX3JlZjIyJGV4cGFuZFBhcmVudCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMjIkZXhwYW5kUGFyZW50OwoKICBpZiAoIXRyZWVEYXRhICYmIHRhcmdldERlcHRoID09PSAwKSB7CiAgICByZXR1cm4gewogICAgICB0cmVlRGF0YTogW25ld05vZGVdLAogICAgICB0cmVlSW5kZXg6IDAsCiAgICAgIHBhdGg6IFtnZXROb2RlS2V5KHsKICAgICAgICBub2RlOiBuZXdOb2RlLAogICAgICAgIHRyZWVJbmRleDogMAogICAgICB9KV0sCiAgICAgIHBhcmVudE5vZGU6IG51bGwKICAgIH07CiAgfQoKICB2YXIgaW5zZXJ0UmVzdWx0ID0gYWRkTm9kZUF0RGVwdGhBbmRJbmRleCh7CiAgICB0YXJnZXREZXB0aDogdGFyZ2V0RGVwdGgsCiAgICBtaW5pbXVtVHJlZUluZGV4OiBtaW5pbXVtVHJlZUluZGV4LAogICAgbmV3Tm9kZTogbmV3Tm9kZSwKICAgIGlnbm9yZUNvbGxhcHNlZDogaWdub3JlQ29sbGFwc2VkLAogICAgZXhwYW5kUGFyZW50OiBleHBhbmRQYXJlbnQsCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaXNQc2V1ZG9Sb290OiB0cnVlLAogICAgaXNMYXN0Q2hpbGQ6IHRydWUsCiAgICBub2RlOiB7CiAgICAgIGNoaWxkcmVuOiB0cmVlRGF0YQogICAgfSwKICAgIGN1cnJlbnRJbmRleDogLTEsCiAgICBjdXJyZW50RGVwdGg6IC0xCiAgfSk7CgogIGlmICghKCJpbnNlcnRlZFRyZWVJbmRleCIgaW4gaW5zZXJ0UmVzdWx0KSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJObyBzdWl0YWJsZSBwb3NpdGlvbiBmb3VuZCB0byBpbnNlcnQuIik7CiAgfQoKICB2YXIgdHJlZUluZGV4ID0gaW5zZXJ0UmVzdWx0Lmluc2VydGVkVHJlZUluZGV4OwogIHJldHVybiB7CiAgICB0cmVlRGF0YTogaW5zZXJ0UmVzdWx0Lm5vZGUuY2hpbGRyZW4sCiAgICB0cmVlSW5kZXg6IHRyZWVJbmRleCwKICAgIHBhdGg6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoaW5zZXJ0UmVzdWx0LnBhcmVudFBhdGgpLCBbZ2V0Tm9kZUtleSh7CiAgICAgIG5vZGU6IG5ld05vZGUsCiAgICAgIHRyZWVJbmRleDogdHJlZUluZGV4CiAgICB9KV0pLAogICAgcGFyZW50Tm9kZTogaW5zZXJ0UmVzdWx0LnBhcmVudE5vZGUKICB9Owp9Ci8qKg0KICogR2V0IHRyZWUgZGF0YSBmbGF0dGVuZWQuDQogKg0KICogQHBhcmFtIHshT2JqZWN0W119IHRyZWVEYXRhIC0gVHJlZSBkYXRhDQogKiBAcGFyYW0geyFmdW5jdGlvbn0gZ2V0Tm9kZUtleSAtIEZ1bmN0aW9uIHRvIGdldCB0aGUga2V5IGZyb20gdGhlIG5vZGVEYXRhIGFuZCB0cmVlIGluZGV4DQogKiBAcGFyYW0ge2Jvb2xlYW49fSBpZ25vcmVDb2xsYXBzZWQgLSBJZ25vcmUgY2hpbGRyZW4gb2Ygbm9kZXMgd2l0aG91dCBgZXhwYW5kZWRgIHNldCB0byBgdHJ1ZWANCiAqDQogKiBAcmV0dXJuIHt7DQogKiAgICAgIG5vZGU6IE9iamVjdCwNCiAqICAgICAgcGF0aDogW11zdHJpbmd8W11udW1iZXIsDQogKiAgICAgIGxvd2VyU2libGluZ0NvdW50czogW11udW1iZXINCiAqICB9fVtdIG5vZGVzIC0gVGhlIG5vZGUgYXJyYXkNCiAqLwoKaWYgKHR5cGVvZiBpbnNlcnROb2RlICE9PSAndW5kZWZpbmVkJyAmJiBpbnNlcnROb2RlICYmIGluc2VydE5vZGUgPT09IE9iamVjdChpbnNlcnROb2RlKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGluc2VydE5vZGUpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc2VydE5vZGUsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJpbnNlcnROb2RlIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldEZsYXREYXRhRnJvbVRyZWUoX3JlZjIzKSB7CiAgdmFyIHRyZWVEYXRhID0gX3JlZjIzLnRyZWVEYXRhLAogICAgICBnZXROb2RlS2V5ID0gX3JlZjIzLmdldE5vZGVLZXksCiAgICAgIF9yZWYyMyRpZ25vcmVDb2xsYXBzZSA9IF9yZWYyMy5pZ25vcmVDb2xsYXBzZWQsCiAgICAgIGlnbm9yZUNvbGxhcHNlZCA9IF9yZWYyMyRpZ25vcmVDb2xsYXBzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYyMyRpZ25vcmVDb2xsYXBzZTsKCiAgaWYgKCF0cmVlRGF0YSB8fCB0cmVlRGF0YS5sZW5ndGggPCAxKSB7CiAgICByZXR1cm4gW107CiAgfQoKICB2YXIgZmxhdHRlbmVkID0gW107CiAgd2Fsayh7CiAgICB0cmVlRGF0YTogdHJlZURhdGEsCiAgICBnZXROb2RlS2V5OiBnZXROb2RlS2V5LAogICAgaWdub3JlQ29sbGFwc2VkOiBpZ25vcmVDb2xsYXBzZWQsCiAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2sobm9kZUluZm8pIHsKICAgICAgZmxhdHRlbmVkLnB1c2gobm9kZUluZm8pOwogICAgfQogIH0pOwogIHJldHVybiBmbGF0dGVuZWQ7Cn0KLyoqDQogKiBHZW5lcmF0ZSBhIHRyZWUgc3RydWN0dXJlIGZyb20gZmxhdCBkYXRhLg0KICoNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSBmbGF0RGF0YQ0KICogQHBhcmFtIHshZnVuY3Rpb249fSBnZXRLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIGtleSBmcm9tIHRoZSBub2RlRGF0YQ0KICogQHBhcmFtIHshZnVuY3Rpb249fSBnZXRQYXJlbnRLZXkgLSBGdW5jdGlvbiB0byBnZXQgdGhlIHBhcmVudCBrZXkgZnJvbSB0aGUgbm9kZURhdGENCiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcj19IHJvb3RLZXkgLSBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgYGdldFBhcmVudEtleWAgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgcm9vdCBub2RlLg0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGlmIHlvdXIgbm9kZXMgaGF2ZSBpZCAxLTk5LCB5b3UgbWlnaHQgdXNlIHJvb3RLZXkgPSAwDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IHRyZWVEYXRhIC0gVGhlIGZsYXQgZGF0YSByZXByZXNlbnRlZCBhcyBhIHRyZWUNCiAqLwoKaWYgKHR5cGVvZiBnZXRGbGF0RGF0YUZyb21UcmVlICE9PSAndW5kZWZpbmVkJyAmJiBnZXRGbGF0RGF0YUZyb21UcmVlICYmIGdldEZsYXREYXRhRnJvbVRyZWUgPT09IE9iamVjdChnZXRGbGF0RGF0YUZyb21UcmVlKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldEZsYXREYXRhRnJvbVRyZWUpKSB7CiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdldEZsYXREYXRhRnJvbVRyZWUsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXRGbGF0RGF0YUZyb21UcmVlIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldFRyZWVGcm9tRmxhdERhdGEoX3JlZjI0KSB7CiAgdmFyIGZsYXREYXRhID0gX3JlZjI0LmZsYXREYXRhLAogICAgICBfcmVmMjQkZ2V0S2V5ID0gX3JlZjI0LmdldEtleSwKICAgICAgZ2V0S2V5ID0gX3JlZjI0JGdldEtleSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKG5vZGUpIHsKICAgIHJldHVybiBub2RlLmlkOwogIH0gOiBfcmVmMjQkZ2V0S2V5LAogICAgICBfcmVmMjQkZ2V0UGFyZW50S2V5ID0gX3JlZjI0LmdldFBhcmVudEtleSwKICAgICAgZ2V0UGFyZW50S2V5ID0gX3JlZjI0JGdldFBhcmVudEtleSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKG5vZGUpIHsKICAgIHJldHVybiBub2RlLnBhcmVudElkOwogIH0gOiBfcmVmMjQkZ2V0UGFyZW50S2V5LAogICAgICBfcmVmMjQkcm9vdEtleSA9IF9yZWYyNC5yb290S2V5LAogICAgICByb290S2V5ID0gX3JlZjI0JHJvb3RLZXkgPT09IHZvaWQgMCA/ICIwIiA6IF9yZWYyNCRyb290S2V5OwoKICBpZiAoIWZsYXREYXRhKSB7CiAgICByZXR1cm4gW107CiAgfQoKICB2YXIgY2hpbGRyZW5Ub1BhcmVudHMgPSB7fTsKICBmbGF0RGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkgewogICAgdmFyIHBhcmVudEtleSA9IGdldFBhcmVudEtleShjaGlsZCk7CgogICAgaWYgKHBhcmVudEtleSBpbiBjaGlsZHJlblRvUGFyZW50cykgewogICAgICBjaGlsZHJlblRvUGFyZW50c1twYXJlbnRLZXldLnB1c2goY2hpbGQpOwogICAgfSBlbHNlIHsKICAgICAgY2hpbGRyZW5Ub1BhcmVudHNbcGFyZW50S2V5XSA9IFtjaGlsZF07CiAgICB9CiAgfSk7CgogIGlmICghKHJvb3RLZXkgaW4gY2hpbGRyZW5Ub1BhcmVudHMpKSB7CiAgICByZXR1cm4gW107CiAgfQoKICB2YXIgdHJhdiA9IGZ1bmN0aW9uIHRyYXYocGFyZW50KSB7CiAgICB2YXIgcGFyZW50S2V5ID0gZ2V0S2V5KHBhcmVudCk7CgogICAgaWYgKHBhcmVudEtleSBpbiBjaGlsZHJlblRvUGFyZW50cykgewogICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgcGFyZW50LCB7CiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuVG9QYXJlbnRzW3BhcmVudEtleV0ubWFwKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgICAgcmV0dXJuIHRyYXYoY2hpbGQpOwogICAgICAgIH0pCiAgICAgIH0pOwogICAgfQoKICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBwYXJlbnQpOwogIH07CgogIHJldHVybiBjaGlsZHJlblRvUGFyZW50c1tyb290S2V5XS5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7CiAgICByZXR1cm4gdHJhdihjaGlsZCk7CiAgfSk7Cn0KLyoqDQogKiBDaGVjayBpZiBhIG5vZGUgaXMgYSBkZXNjZW5kYW50IG9mIGFub3RoZXIgbm9kZS4NCiAqDQogKiBAcGFyYW0geyFPYmplY3R9IG9sZGVyIC0gUG90ZW50aWFsIGFuY2VzdG9yIG9mIHlvdW5nZXIgbm9kZQ0KICogQHBhcmFtIHshT2JqZWN0fSB5b3VuZ2VyIC0gUG90ZW50aWFsIGRlc2NlbmRhbnQgb2Ygb2xkZXIgbm9kZQ0KICoNCiAqIEByZXR1cm4ge2Jvb2xlYW59DQogKi8KCmlmICh0eXBlb2YgZ2V0VHJlZUZyb21GbGF0RGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0VHJlZUZyb21GbGF0RGF0YSAmJiBnZXRUcmVlRnJvbUZsYXREYXRhID09PSBPYmplY3QoZ2V0VHJlZUZyb21GbGF0RGF0YSkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXRUcmVlRnJvbUZsYXREYXRhKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRUcmVlRnJvbUZsYXREYXRhLCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiZ2V0VHJlZUZyb21GbGF0RGF0YSIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQob2xkZXIsIHlvdW5nZXIpIHsKICByZXR1cm4gISFvbGRlci5jaGlsZHJlbiAmJiB0eXBlb2Ygb2xkZXIuY2hpbGRyZW4gIT09ICJmdW5jdGlvbiIgJiYgb2xkZXIuY2hpbGRyZW4uc29tZShmdW5jdGlvbiAoY2hpbGQpIHsKICAgIHJldHVybiBjaGlsZCA9PT0geW91bmdlciB8fCBpc0Rlc2NlbmRhbnQoY2hpbGQsIHlvdW5nZXIpOwogIH0pOwp9Ci8qKg0KICogR2V0IHRoZSBtYXhpbXVtIGRlcHRoIG9mIHRoZSBjaGlsZHJlbiAodGhlIGRlcHRoIG9mIHRoZSByb290IG5vZGUgaXMgMCkuDQogKg0KICogQHBhcmFtIHshT2JqZWN0fSBub2RlIC0gTm9kZSBpbiB0aGUgdHJlZQ0KICogQHBhcmFtIHs/bnVtYmVyfSBkZXB0aCAtIFRoZSBjdXJyZW50IGRlcHRoDQogKg0KICogQHJldHVybiB7bnVtYmVyfSBtYXhEZXB0aCAtIFRoZSBkZWVwZXN0IGRlcHRoIGluIHRoZSB0cmVlDQogKi8KCmlmICh0eXBlb2YgaXNEZXNjZW5kYW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0Rlc2NlbmRhbnQgJiYgaXNEZXNjZW5kYW50ID09PSBPYmplY3QoaXNEZXNjZW5kYW50KSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGlzRGVzY2VuZGFudCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaXNEZXNjZW5kYW50LCAnX19maWxlbWV0YScsIHsKICAgIGVudW1lcmFibGU6IHRydWUsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICB2YWx1ZTogewogICAgICBuYW1lOiAiaXNEZXNjZW5kYW50IiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldERlcHRoKG5vZGUpIHsKICB2YXIgZGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7CgogIGlmICghbm9kZS5jaGlsZHJlbikgewogICAgcmV0dXJuIGRlcHRoOwogIH0KCiAgaWYgKHR5cGVvZiBub2RlLmNoaWxkcmVuID09PSAiZnVuY3Rpb24iKSB7CiAgICByZXR1cm4gZGVwdGggKyAxOwogIH0KCiAgcmV0dXJuIG5vZGUuY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChkZWVwZXN0LCBjaGlsZCkgewogICAgcmV0dXJuIE1hdGgubWF4KGRlZXBlc3QsIGdldERlcHRoKGNoaWxkLCBkZXB0aCArIDEpKTsKICB9LCBkZXB0aCk7Cn0KLyoqDQogKiBGaW5kIG5vZGVzIG1hdGNoaW5nIGEgc2VhcmNoIHF1ZXJ5IGluIHRoZSB0cmVlLA0KICoNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBnZXROb2RlS2V5IC0gRnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXkgZnJvbSB0aGUgbm9kZURhdGEgYW5kIHRyZWUgaW5kZXgNCiAqIEBwYXJhbSB7IU9iamVjdFtdfSB0cmVlRGF0YSAtIFRyZWUgZGF0YQ0KICogQHBhcmFtIHs/c3RyaW5nfG51bWJlcn0gc2VhcmNoUXVlcnkgLSBGdW5jdGlvbiByZXR1cm5pbmcgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBtYXRjaCBvciBub3QNCiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBzZWFyY2hNZXRob2QgLSBGdW5jdGlvbiByZXR1cm5pbmcgYSBib29sZWFuIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIG5vZGUgaXMgYSBtYXRjaCBvciBub3QNCiAqIEBwYXJhbSB7P251bWJlcn0gc2VhcmNoRm9jdXNPZmZzZXQgLSBUaGUgb2Zmc2V0IG9mIHRoZSBtYXRjaCB0byBmb2N1cyBvbg0KICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmcuLCAwIGZvY3VzZXMgb24gdGhlIGZpcnN0IG1hdGNoLCAxIG9uIHRoZSBzZWNvbmQpDQogKiBAcGFyYW0ge2Jvb2xlYW49fSBleHBhbmRBbGxNYXRjaFBhdGhzIC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGF0aHMgdG8gYW55IG1hdGNoZWQgbm9kZQ0KICogQHBhcmFtIHtib29sZWFuPX0gZXhwYW5kRm9jdXNNYXRjaFBhdGhzIC0gSWYgdHJ1ZSwgZXhwYW5kcyB0aGUgcGF0aCB0byB0aGUgZm9jdXNlZCBub2RlDQogKg0KICogQHJldHVybiB7T2JqZWN0W119IG1hdGNoZXMgLSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIG1hdGNoaW5nIGBub2RlYHMsIHRoZWlyIGBwYXRoYHMgYW5kIGB0cmVlSW5kZXhgcw0KICogQHJldHVybiB7T2JqZWN0W119IHRyZWVEYXRhIC0gVGhlIG9yaWdpbmFsIHRyZWUgZGF0YSB3aXRoIGFsbCByZWxldmFudCBub2RlcyBleHBhbmRlZC4NCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGV4cGFuZEFsbE1hdGNoUGF0aHMgYW5kIGV4cGFuZEZvY3VzTWF0Y2hQYXRocyBhcmUgYm90aCBmYWxzZSwNCiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0IHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbmFsIHRyZWUgZGF0YS4NCiAqLwoKaWYgKHR5cGVvZiBnZXREZXB0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2V0RGVwdGggJiYgZ2V0RGVwdGggPT09IE9iamVjdChnZXREZXB0aCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShnZXREZXB0aCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2V0RGVwdGgsICdfX2ZpbGVtZXRhJywgewogICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgIHZhbHVlOiB7CiAgICAgIG5hbWU6ICJnZXREZXB0aCIsCiAgICAgIGZpbGVuYW1lOiAic3JjXFxoZWxwZXIuanMiCiAgICB9CiAgfSk7Cn0KCmV4cG9ydCBmdW5jdGlvbiBmaW5kKF9yZWYyNSkgewogIHZhciBnZXROb2RlS2V5ID0gX3JlZjI1LmdldE5vZGVLZXksCiAgICAgIHRyZWVEYXRhID0gX3JlZjI1LnRyZWVEYXRhLAogICAgICBzZWFyY2hRdWVyeSA9IF9yZWYyNS5zZWFyY2hRdWVyeSwKICAgICAgc2VhcmNoTWV0aG9kID0gX3JlZjI1LnNlYXJjaE1ldGhvZCwKICAgICAgc2VhcmNoRm9jdXNPZmZzZXQgPSBfcmVmMjUuc2VhcmNoRm9jdXNPZmZzZXQsCiAgICAgIF9yZWYyNSRleHBhbmRBbGxNYXRjaCA9IF9yZWYyNS5leHBhbmRBbGxNYXRjaFBhdGhzLAogICAgICBleHBhbmRBbGxNYXRjaFBhdGhzID0gX3JlZjI1JGV4cGFuZEFsbE1hdGNoID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyNSRleHBhbmRBbGxNYXRjaCwKICAgICAgX3JlZjI1JGV4cGFuZEZvY3VzTWF0ID0gX3JlZjI1LmV4cGFuZEZvY3VzTWF0Y2hQYXRocywKICAgICAgZXhwYW5kRm9jdXNNYXRjaFBhdGhzID0gX3JlZjI1JGV4cGFuZEZvY3VzTWF0ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjI1JGV4cGFuZEZvY3VzTWF0OwogIHZhciBtYXRjaENvdW50ID0gMDsKCiAgdmFyIHRyYXYgPSBmdW5jdGlvbiB0cmF2KF9yZWYyNikgewogICAgdmFyIF9yZWYyNiRpc1BzZXVkb1Jvb3QgPSBfcmVmMjYuaXNQc2V1ZG9Sb290LAogICAgICAgIGlzUHNldWRvUm9vdCA9IF9yZWYyNiRpc1BzZXVkb1Jvb3QgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjI2JGlzUHNldWRvUm9vdCwKICAgICAgICBub2RlID0gX3JlZjI2Lm5vZGUsCiAgICAgICAgY3VycmVudEluZGV4ID0gX3JlZjI2LmN1cnJlbnRJbmRleCwKICAgICAgICBfcmVmMjYkcGF0aCA9IF9yZWYyNi5wYXRoLAogICAgICAgIHBhdGggPSBfcmVmMjYkcGF0aCA9PT0gdm9pZCAwID8gW10gOiBfcmVmMjYkcGF0aDsKICAgIHZhciBtYXRjaGVzID0gW107CiAgICB2YXIgaXNTZWxmTWF0Y2ggPSBmYWxzZTsKICAgIHZhciBoYXNGb2N1c01hdGNoID0gZmFsc2U7IC8vIFRoZSBwc2V1ZG8tcm9vdCBpcyBub3QgY29uc2lkZXJlZCBpbiB0aGUgcGF0aAoKICAgIHZhciBzZWxmUGF0aCA9IGlzUHNldWRvUm9vdCA/IFtdIDogW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShwYXRoKSwgW2dldE5vZGVLZXkoewogICAgICBub2RlOiBub2RlLAogICAgICB0cmVlSW5kZXg6IGN1cnJlbnRJbmRleAogICAgfSldKTsKICAgIHZhciBleHRyYUluZm8gPSBpc1BzZXVkb1Jvb3QgPyBudWxsIDogewogICAgICBwYXRoOiBzZWxmUGF0aCwKICAgICAgdHJlZUluZGV4OiBjdXJyZW50SW5kZXgKICAgIH07IC8vIE5vZGVzIHdpdGggd2l0aCBjaGlsZHJlbiB0aGF0IGFyZW4ndCBsYXp5CgogICAgdmFyIGhhc0NoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiAmJiB0eXBlb2Ygbm9kZS5jaGlsZHJlbiAhPT0gImZ1bmN0aW9uIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDA7IC8vIEV4YW1pbmUgdGhlIGN1cnJlbnQgbm9kZSB0byBzZWUgaWYgaXQgaXMgYSBtYXRjaAoKICAgIGlmICghaXNQc2V1ZG9Sb290ICYmIHNlYXJjaE1ldGhvZChfb2JqZWN0U3ByZWFkKHt9LCBleHRyYUluZm8sIHsKICAgICAgbm9kZTogbm9kZSwKICAgICAgc2VhcmNoUXVlcnk6IHNlYXJjaFF1ZXJ5CiAgICB9KSkpIHsKICAgICAgaWYgKG1hdGNoQ291bnQgPT09IHNlYXJjaEZvY3VzT2Zmc2V0KSB7CiAgICAgICAgaGFzRm9jdXNNYXRjaCA9IHRydWU7CiAgICAgIH0gLy8gS2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIG5vZGVzLCBzbyB3ZSBrbm93IHdoZW4gdGhlIHNlYXJjaEZvY3VzT2Zmc2V0CiAgICAgIC8vICBpcyByZWFjaGVkCgoKICAgICAgbWF0Y2hDb3VudCArPSAxOyAvLyBXZSBjYW5ub3QgYWRkIHRoaXMgbm9kZSB0byB0aGUgbWF0Y2hlcyByaWdodCBhd2F5LCBhcyBpdCBtYXkgYmUgY2hhbmdlZAogICAgICAvLyAgZHVyaW5nIHRoZSBzZWFyY2ggb2YgdGhlIGRlc2NlbmRhbnRzLiBUaGUgZW50aXJlIG5vZGUgaXMgdXNlZCBpbgogICAgICAvLyAgY29tcGFyaXNvbnMgYmV0d2VlbiBub2RlcyBpbnNpZGUgdGhlIGBtYXRjaGVzYCBhbmQgYHRyZWVEYXRhYCByZXN1bHRzCiAgICAgIC8vICBvZiB0aGlzIG1ldGhvZCAoYGZpbmRgKQoKICAgICAgaXNTZWxmTWF0Y2ggPSB0cnVlOwogICAgfQoKICAgIHZhciBjaGlsZEluZGV4ID0gY3VycmVudEluZGV4OwoKICAgIHZhciBuZXdOb2RlID0gX29iamVjdFNwcmVhZCh7fSwgbm9kZSk7CgogICAgaWYgKGhhc0NoaWxkcmVuKSB7CiAgICAgIC8vIEdldCBhbGwgZGVzY2VuZGFudHMKICAgICAgbmV3Tm9kZS5jaGlsZHJlbiA9IG5ld05vZGUuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjaGlsZCkgewogICAgICAgIHZhciBtYXBSZXN1bHQgPSB0cmF2KHsKICAgICAgICAgIG5vZGU6IGNoaWxkLAogICAgICAgICAgY3VycmVudEluZGV4OiBjaGlsZEluZGV4ICsgMSwKICAgICAgICAgIHBhdGg6IHNlbGZQYXRoCiAgICAgICAgfSk7IC8vIElnbm9yZSBoaWRkZW4gbm9kZXMgYnkgb25seSBhZHZhbmNpbmcgdGhlIGluZGV4IGNvdW50ZXIgdG8gdGhlIHJldHVybmVkIHRyZWVJbmRleAogICAgICAgIC8vIGlmIHRoZSBjaGlsZCBpcyBleHBhbmRlZC4KICAgICAgICAvLwogICAgICAgIC8vIFRoZSBjaGlsZCBjb3VsZCBoYXZlIGJlZW4gZXhwYW5kZWQgZnJvbSB0aGUgc3RhcnQsCiAgICAgICAgLy8gb3IgZXhwYW5kZWQgZHVlIHRvIGEgbWF0Y2hpbmcgbm9kZSBiZWluZyBmb3VuZCBpbiBpdHMgZGVzY2VuZGFudHMKCiAgICAgICAgaWYgKG1hcFJlc3VsdC5ub2RlLmV4cGFuZGVkKSB7CiAgICAgICAgICBjaGlsZEluZGV4ID0gbWFwUmVzdWx0LnRyZWVJbmRleDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY2hpbGRJbmRleCArPSAxOwogICAgICAgIH0KCiAgICAgICAgaWYgKG1hcFJlc3VsdC5tYXRjaGVzLmxlbmd0aCA+IDAgfHwgbWFwUmVzdWx0Lmhhc0ZvY3VzTWF0Y2gpIHsKICAgICAgICAgIG1hdGNoZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KG1hdGNoZXMpLCBfdG9Db25zdW1hYmxlQXJyYXkobWFwUmVzdWx0Lm1hdGNoZXMpKTsKCiAgICAgICAgICBpZiAobWFwUmVzdWx0Lmhhc0ZvY3VzTWF0Y2gpIHsKICAgICAgICAgICAgaGFzRm9jdXNNYXRjaCA9IHRydWU7CiAgICAgICAgICB9IC8vIEV4cGFuZCB0aGUgY3VycmVudCBub2RlIGlmIGl0IGhhcyBkZXNjZW5kYW50cyBtYXRjaGluZyB0aGUgc2VhcmNoCiAgICAgICAgICAvLyBhbmQgdGhlIHNldHRpbmdzIGFyZSBzZXQgdG8gZG8gc28uCgoKICAgICAgICAgIGlmIChleHBhbmRBbGxNYXRjaFBhdGhzICYmIG1hcFJlc3VsdC5tYXRjaGVzLmxlbmd0aCA+IDAgfHwgKGV4cGFuZEFsbE1hdGNoUGF0aHMgfHwgZXhwYW5kRm9jdXNNYXRjaFBhdGhzKSAmJiBtYXBSZXN1bHQuaGFzRm9jdXNNYXRjaCkgewogICAgICAgICAgICBuZXdOb2RlLmV4cGFuZGVkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIHJldHVybiBtYXBSZXN1bHQubm9kZTsKICAgICAgfSk7CiAgICB9IC8vIENhbm5vdCBhc3NpZ24gYSB0cmVlSW5kZXggdG8gaGlkZGVuIG5vZGVzCgoKICAgIGlmICghaXNQc2V1ZG9Sb290ICYmICFuZXdOb2RlLmV4cGFuZGVkKSB7CiAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsKICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCh7fSwgbWF0Y2gsIHsKICAgICAgICAgIHRyZWVJbmRleDogbnVsbAogICAgICAgIH0pOwogICAgICB9KTsKICAgIH0gLy8gQWRkIHRoaXMgbm9kZSB0byB0aGUgbWF0Y2hlcyBpZiBpdCBmaXRzIHRoZSBzZWFyY2ggY3JpdGVyaWEuCiAgICAvLyBUaGlzIGlzIHBlcmZvcm1lZCBhdCB0aGUgbGFzdCBtaW51dGUgc28gbmV3Tm9kZSBjYW4gYmUgc2VudCBpbiBpdHMgZmluYWwgZm9ybS4KCgogICAgaWYgKGlzU2VsZk1hdGNoKSB7CiAgICAgIG1hdGNoZXMgPSBbX29iamVjdFNwcmVhZCh7fSwgZXh0cmFJbmZvLCB7CiAgICAgICAgbm9kZTogbmV3Tm9kZQogICAgICB9KV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShtYXRjaGVzKSk7CiAgICB9CgogICAgcmV0dXJuIHsKICAgICAgbm9kZTogbWF0Y2hlcy5sZW5ndGggPiAwID8gbmV3Tm9kZSA6IG5vZGUsCiAgICAgIG1hdGNoZXM6IG1hdGNoZXMsCiAgICAgIGhhc0ZvY3VzTWF0Y2g6IGhhc0ZvY3VzTWF0Y2gsCiAgICAgIHRyZWVJbmRleDogY2hpbGRJbmRleAogICAgfTsKICB9OwoKICB2YXIgcmVzdWx0ID0gdHJhdih7CiAgICBub2RlOiB7CiAgICAgIGNoaWxkcmVuOiB0cmVlRGF0YQogICAgfSwKICAgIGlzUHNldWRvUm9vdDogdHJ1ZSwKICAgIGN1cnJlbnRJbmRleDogLTEKICB9KTsKICByZXR1cm4gewogICAgbWF0Y2hlczogcmVzdWx0Lm1hdGNoZXMsCiAgICB0cmVlRGF0YTogcmVzdWx0Lm5vZGUuY2hpbGRyZW4KICB9Owp9CgppZiAodHlwZW9mIGZpbmQgIT09ICd1bmRlZmluZWQnICYmIGZpbmQgJiYgZmluZCA9PT0gT2JqZWN0KGZpbmQpICYmIE9iamVjdC5pc0V4dGVuc2libGUoZmluZCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmluZCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImZpbmQiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gdHJlZVRvTGlzdChhcnIpIHsKICB2YXIgdHJlZUxpc3QgPSBhcnIgfHwgW107IC8v5pyr57qn6IqC54K5CgogIHZhciBsZWFmcyA9IFtdOyAvL+aguQoKICB2YXIgcm9vdHMgPSBbXTsgLy/miYDmnInoioLngrkKCiAgdmFyIGxpc3QgPSBbXTsKCiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlTGlzdC5sZW5ndGg7IGkrKykgewogICAgdmFyIGQgPSB0cmVlTGlzdFtpXTsKCiAgICBpZiAoIWQpIHsKICAgICAgY29udGludWU7CiAgICB9CgogICAgdmFyIGNoaWxkcmVucyA9IGQuY2hpbGRyZW4gfHwgW107CiAgICBkLl9fZGVwdGggPSAwOwogICAgbGlzdC5wdXNoKGQpOwogICAgcm9vdHMucHVzaChkKTsKCiAgICBpZiAoY2hpbGRyZW5zLmxlbmd0aCA+IDApIHsKICAgICAgZ2V0Q2hpbGRyZW4oZCwgMCk7CiAgICB9IGVsc2UgewogICAgICBsZWFmcy5wdXNoKGQpOwogICAgfQogIH0KCiAgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oZCwgZGVwdGgpIHsKICAgIHZhciB0ZW1wQXJyID0gZC5jaGlsZHJlbiB8fCBbXTsKCiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGVtcEFyci5sZW5ndGg7IF9pKyspIHsKICAgICAgdmFyIF9kID0gdGVtcEFycltfaV07CgogICAgICB2YXIgX2NoaWxkcmVucyA9IF9kLmNoaWxkcmVuIHx8IFtdOwoKICAgICAgX2QuX19kZXB0aCA9IGRlcHRoICsgMTsKICAgICAgbGlzdC5wdXNoKF9kKTsKCiAgICAgIGlmIChfY2hpbGRyZW5zLmxlbmd0aCA+IDApIHsKICAgICAgICBnZXRDaGlsZHJlbihfZCwgZGVwdGggKyAxKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBsZWFmcy5wdXNoKF9kKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHsKICAgIGxpc3Q6IGxpc3QsCiAgICBsZWFmczogbGVhZnMsCiAgICByb290czogcm9vdHMKICB9Owp9CgppZiAodHlwZW9mIHRyZWVUb0xpc3QgIT09ICd1bmRlZmluZWQnICYmIHRyZWVUb0xpc3QgJiYgdHJlZVRvTGlzdCA9PT0gT2JqZWN0KHRyZWVUb0xpc3QpICYmIE9iamVjdC5pc0V4dGVuc2libGUodHJlZVRvTGlzdCkpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJlZVRvTGlzdCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogInRyZWVUb0xpc3QiLAogICAgICBmaWxlbmFtZTogInNyY1xcaGVscGVyLmpzIgogICAgfQogIH0pOwp9CgpleHBvcnQgZnVuY3Rpb24gZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQobGlzdCkgewogIHZhciBleHBhbmRlZEtleXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdOwogIHZhciByb3dLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDsKICB2YXIgYXJyID0gW107CgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykgewogICAgdmFyIGQgPSBsaXN0W2ldOwogICAgZC5fX2RlcHRoID0gMDsKICAgIGFyci5wdXNoKGQpOwoKICAgIGlmIChleHBhbmRlZEtleXMuaW5kZXhPZihkW3Jvd0tleV0pID4gLTEpIHsKICAgICAgaWYgKGQuY2hpbGRyZW4pIHsKICAgICAgICBzZXRDaGlsZHJlbihkLCAwKTsKICAgICAgfQogICAgfQogIH0KCiAgZnVuY3Rpb24gc2V0Q2hpbGRyZW4oYywgZGVwdGgpIHsKICAgIHZhciBjQXJyID0gYy5jaGlsZHJlbjsKCiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjQXJyLmxlbmd0aDsgX2kyKyspIHsKICAgICAgdmFyIF9kMiA9IGNBcnJbX2kyXTsKICAgICAgX2QyLl9fZGVwdGggPSBkZXB0aCArIDE7CiAgICAgIGFyci5wdXNoKF9kMik7CgogICAgICBpZiAoZXhwYW5kZWRLZXlzLmluZGV4T2YoX2QyW3Jvd0tleV0pID4gLTEpIHsKICAgICAgICBpZiAoX2QyLmNoaWxkcmVuKSB7CiAgICAgICAgICBzZXRDaGlsZHJlbihfZDIsIGRlcHRoICsgMSk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gYXJyOwp9CgppZiAodHlwZW9mIGdldERhdGFMaXN0V2l0aEV4cGFuZGVkICE9PSAndW5kZWZpbmVkJyAmJiBnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCAmJiBnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCA9PT0gT2JqZWN0KGdldERhdGFMaXN0V2l0aEV4cGFuZGVkKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldERhdGFMaXN0V2l0aEV4cGFuZGVkKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImdldERhdGFMaXN0V2l0aEV4cGFuZGVkIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkgewogIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50OyAvL+WPluW+l+a1j+iniOWZqOeahHVzZXJBZ2VudOWtl+espuS4sgoKICBpZiAodXNlckFnZW50LmluZGV4T2YoIkNocm9tZSIpID4gLTEpIHsKICAgIHJldHVybiA2OwogIH0KCiAgdmFyIG9QID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicCIpLAogICAgICBzdHlsZXMgPSB7CiAgICB3aWR0aDogIjEwMHB4IiwKICAgIGhlaWdodDogIjEwMHB4IiwKICAgIG92ZXJmbG93WTogInNjcm9sbCIKICB9LAogICAgICBpLAogICAgICBzY3JvbGxiYXJXaWR0aDsKCiAgZm9yIChpIGluIHN0eWxlcykgewogICAgb1Auc3R5bGVbaV0gPSBzdHlsZXNbaV07CiAgfQoKICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG9QKTsKICBzY3JvbGxiYXJXaWR0aCA9IG9QLm9mZnNldFdpZHRoIC0gb1AuY2xpZW50V2lkdGg7CiAgb1AucmVtb3ZlKCk7CiAgcmV0dXJuIHNjcm9sbGJhcldpZHRoOwp9CgppZiAodHlwZW9mIGdldFNjcm9sbGJhcldpZHRoICE9PSAndW5kZWZpbmVkJyAmJiBnZXRTY3JvbGxiYXJXaWR0aCAmJiBnZXRTY3JvbGxiYXJXaWR0aCA9PT0gT2JqZWN0KGdldFNjcm9sbGJhcldpZHRoKSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGdldFNjcm9sbGJhcldpZHRoKSkgewogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnZXRTY3JvbGxiYXJXaWR0aCwgJ19fZmlsZW1ldGEnLCB7CiAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgdmFsdWU6IHsKICAgICAgbmFtZTogImdldFNjcm9sbGJhcldpZHRoIiwKICAgICAgZmlsZW5hbWU6ICJzcmNcXGhlbHBlci5qcyIKICAgIH0KICB9KTsKfQoKOwoKKGZ1bmN0aW9uICgpIHsKICB2YXIgcmVhY3RIb3RMb2FkZXIgPSAodHlwZW9mIHJlYWN0SG90TG9hZGVyR2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IHJlYWN0SG90TG9hZGVyR2xvYmFsIDogcmVxdWlyZSgncmVhY3QtaG90LWxvYWRlcicpKS5kZWZhdWx0OwoKICBpZiAoIXJlYWN0SG90TG9hZGVyKSB7CiAgICByZXR1cm47CiAgfQoKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgsICJnZXROb2RlRGF0YUF0VHJlZUluZGV4T3JOZXh0SW5kZXgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldERlc2NlbmRhbnRDb3VudCwgImdldERlc2NlbmRhbnRDb3VudCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIod2Fsa0Rlc2NlbmRhbnRzLCAid2Fsa0Rlc2NlbmRhbnRzIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihtYXBEZXNjZW5kYW50cywgIm1hcERlc2NlbmRhbnRzIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihnZXRWaXNpYmxlTm9kZUNvdW50LCAiZ2V0VmlzaWJsZU5vZGVDb3VudCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0VmlzaWJsZU5vZGVJbmZvQXRJbmRleCwgImdldFZpc2libGVOb2RlSW5mb0F0SW5kZXgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHdhbGssICJ3YWxrIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihtYXAsICJtYXAiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKHRvZ2dsZUV4cGFuZGVkRm9yQWxsLCAidG9nZ2xlRXhwYW5kZWRGb3JBbGwiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGNoYW5nZU5vZGVBdFBhdGgsICJjaGFuZ2VOb2RlQXRQYXRoIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihyZW1vdmVOb2RlQXRQYXRoLCAicmVtb3ZlTm9kZUF0UGF0aCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIocmVtb3ZlTm9kZSwgInJlbW92ZU5vZGUiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldE5vZGVBdFBhdGgsICJnZXROb2RlQXRQYXRoIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihhZGROb2RlVW5kZXJQYXJlbnQsICJhZGROb2RlVW5kZXJQYXJlbnQiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGFkZE5vZGVBdERlcHRoQW5kSW5kZXgsICJhZGROb2RlQXREZXB0aEFuZEluZGV4IiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3RlcihpbnNlcnROb2RlLCAiaW5zZXJ0Tm9kZSIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0RmxhdERhdGFGcm9tVHJlZSwgImdldEZsYXREYXRhRnJvbVRyZWUiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldFRyZWVGcm9tRmxhdERhdGEsICJnZXRUcmVlRnJvbUZsYXREYXRhIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3Rlcihpc0Rlc2NlbmRhbnQsICJpc0Rlc2NlbmRhbnQiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGdldERlcHRoLCAiZ2V0RGVwdGgiLCAiRTpcXFdlYlJvb3RcXHRhYmxleFxcdGFibGV4XFxzcmNcXGhlbHBlci5qcyIpOwogIHJlYWN0SG90TG9hZGVyLnJlZ2lzdGVyKGZpbmQsICJmaW5kIiwgIkU6XFxXZWJSb290XFx0YWJsZXhcXHRhYmxleFxcc3JjXFxoZWxwZXIuanMiKTsKICByZWFjdEhvdExvYWRlci5yZWdpc3Rlcih0cmVlVG9MaXN0LCAidHJlZVRvTGlzdCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0RGF0YUxpc3RXaXRoRXhwYW5kZWQsICJnZXREYXRhTGlzdFdpdGhFeHBhbmRlZCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7CiAgcmVhY3RIb3RMb2FkZXIucmVnaXN0ZXIoZ2V0U2Nyb2xsYmFyV2lkdGgsICJnZXRTY3JvbGxiYXJXaWR0aCIsICJFOlxcV2ViUm9vdFxcdGFibGV4XFx0YWJsZXhcXHNyY1xcaGVscGVyLmpzIik7Cn0pKCk7Cgo7CgooZnVuY3Rpb24gKCkgewogIHZhciBsZWF2ZU1vZHVsZSA9ICh0eXBlb2YgcmVhY3RIb3RMb2FkZXJHbG9iYWwgIT09ICd1bmRlZmluZWQnID8gcmVhY3RIb3RMb2FkZXJHbG9iYWwgOiByZXF1aXJlKCdyZWFjdC1ob3QtbG9hZGVyJykpLmxlYXZlTW9kdWxlOwogIGxlYXZlTW9kdWxlICYmIGxlYXZlTW9kdWxlKG1vZHVsZSk7Cn0pKCk7"},{"version":3,"sources":["E:\\WebRoot\\tablex\\tablex\\src\\helper.js"],"names":["getNodeDataAtTreeIndexOrNextIndex","targetIndex","node","currentIndex","getNodeKey","path","lowerSiblingCounts","ignoreCollapsed","isPseudoRoot","selfPath","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","walkDescendants","callback","parentNode","selfInfo","callbackResult","mapDescendants","nextNode","map","child","mapResult","getVisibleNodeCount","treeData","traverse","reduce","total","currentNode","getVisibleNodeInfoAtIndex","index","walk","toggleExpandedForAll","changeNodeAtPath","newNode","RESULT_MISS","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","removeNode","removedNode","removedTreeIndex","nextTreeData","getNodeAtPath","foundNodeInfo","err","addNodeUnderParent","parentKey","expandParent","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","key","addNodeAtDepthAndIndex","targetDepth","minimumTreeIndex","isLastChild","currentDepth","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","insertNode","depth","insertResult","getFlatDataFromTree","flattened","nodeInfo","push","getTreeFromFlatData","flatData","getKey","id","getParentKey","parentId","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","deepest","Math","max","find","searchQuery","searchMethod","searchFocusOffset","expandAllMatchPaths","expandFocusMatchPaths","matchCount","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","treeToList","arr","treeList","leafs","roots","list","d","childrens","__depth","getChildren","tempArr","getDataListWithExpanded","expandedKeys","rowKey","indexOf","setChildren","c","cArr","getScrollbarWidth","userAgent","navigator","oP","document","createElement","styles","width","height","overflowY","scrollbarWidth","style","body","appendChild","offsetWidth","clientWidth","remove"],"mappings":"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","sourcesContent":["/**\r\n * Performs a depth-first traversal over all of the node descendants,\r\n * incrementing currentIndex by 1 for each\r\n */\r\nfunction getNodeDataAtTreeIndexOrNextIndex({\r\n  targetIndex,\r\n  node,\r\n  currentIndex,\r\n  getNodeKey,\r\n  path = [],\r\n  lowerSiblingCounts = [],\r\n  ignoreCollapsed = true,\r\n  isPseudoRoot = false\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = !isPseudoRoot\r\n    ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\r\n    : [];\r\n\r\n  // Return target node when found\r\n  if (currentIndex === targetIndex) {\r\n    return {\r\n      node,\r\n      lowerSiblingCounts,\r\n      path: selfPath\r\n    };\r\n  }\r\n\r\n  // Add one and continue for nodes with no children or hidden children\r\n  if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\r\n    return { nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Iterate over each child and their descendants and return the\r\n  // target node if childIndex reaches the targetIndex\r\n  let childIndex = currentIndex + 1;\r\n  const childCount = node.children.length;\r\n  for (let i = 0; i < childCount; i += 1) {\r\n    const result = getNodeDataAtTreeIndexOrNextIndex({\r\n      ignoreCollapsed,\r\n      getNodeKey,\r\n      targetIndex,\r\n      node: node.children[i],\r\n      currentIndex: childIndex,\r\n      lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n      path: selfPath\r\n    });\r\n\r\n    if (result.node) {\r\n      return result;\r\n    }\r\n\r\n    childIndex = result.nextIndex;\r\n  }\r\n\r\n  // If the target node is not found, return the farthest traversed index\r\n  return { nextIndex: childIndex };\r\n}\r\n\r\nexport function getDescendantCount({ node, ignoreCollapsed = true }) {\r\n  return (\r\n    getNodeDataAtTreeIndexOrNextIndex({\r\n      getNodeKey: () => {},\r\n      ignoreCollapsed,\r\n      node,\r\n      currentIndex: 0,\r\n      targetIndex: -1\r\n    }).nextIndex - 1\r\n  );\r\n}\r\n\r\n/**\r\n * Walk all descendants of the given node, depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction walkDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n  const selfInfo = isPseudoRoot\r\n    ? null\r\n    : {\r\n        node,\r\n        parentNode,\r\n        path: selfPath,\r\n        lowerSiblingCounts,\r\n        treeIndex: currentIndex\r\n      };\r\n\r\n  if (!isPseudoRoot) {\r\n    const callbackResult = callback(selfInfo);\r\n\r\n    // Cut walk short if the callback returned false\r\n    if (callbackResult === false) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return currentIndex;\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = node.children.length;\r\n  if (typeof node.children !== \"function\") {\r\n    for (let i = 0; i < childCount; i += 1) {\r\n      childIndex = walkDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: node.children[i],\r\n        parentNode: isPseudoRoot ? null : node,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n\r\n      // Cut walk short if the callback returned false\r\n      if (childIndex === false) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n\r\n  return childIndex;\r\n}\r\n\r\n/**\r\n * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n *\r\n * @param {Object} args - Function parameters\r\n * @param {function} args.callback - Function to call on each node\r\n * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n *                                        as the parent of all the nodes in the tree\r\n * @param {Object} args.node - A tree node\r\n * @param {Object=} args.parentNode - The parent node of `node`\r\n * @param {number} args.currentIndex - The treeIndex of `node`\r\n * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n *                                             previous nodes in this path\r\n *\r\n * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n *                                    or false if the walk should be terminated\r\n */\r\nfunction mapDescendants({\r\n  callback,\r\n  getNodeKey,\r\n  ignoreCollapsed,\r\n  isPseudoRoot = false,\r\n  node,\r\n  parentNode = null,\r\n  currentIndex,\r\n  path = [],\r\n  lowerSiblingCounts = []\r\n}) {\r\n  const nextNode = { ...node };\r\n\r\n  // The pseudo-root is not considered in the path\r\n  const selfPath = isPseudoRoot\r\n    ? []\r\n    : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\r\n  const selfInfo = {\r\n    node: nextNode,\r\n    parentNode,\r\n    path: selfPath,\r\n    lowerSiblingCounts,\r\n    treeIndex: currentIndex\r\n  };\r\n\r\n  // Return self on nodes with no children or hidden children\r\n  if (\r\n    !nextNode.children ||\r\n    (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return {\r\n      treeIndex: currentIndex,\r\n      node: callback(selfInfo)\r\n    };\r\n  }\r\n\r\n  // Get all descendants\r\n  let childIndex = currentIndex;\r\n  const childCount = nextNode.children.length;\r\n  if (typeof nextNode.children !== \"function\") {\r\n    nextNode.children = nextNode.children.map((child, i) => {\r\n      const mapResult = mapDescendants({\r\n        callback,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        node: child,\r\n        parentNode: isPseudoRoot ? null : nextNode,\r\n        currentIndex: childIndex + 1,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath\r\n      });\r\n      childIndex = mapResult.treeIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  return {\r\n    node: callback(selfInfo),\r\n    treeIndex: childIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Count all the visible (expanded) descendants in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n *\r\n * @return {number} count\r\n */\r\nexport function getVisibleNodeCount({ treeData }) {\r\n  const traverse = node => {\r\n    if (\r\n      !node.children ||\r\n      node.expanded !== true ||\r\n      typeof node.children === \"function\"\r\n    ) {\r\n      return 1;\r\n    }\r\n\r\n    return (\r\n      1 +\r\n      node.children.reduce(\r\n        (total, currentNode) => total + traverse(currentNode),\r\n        0\r\n      )\r\n    );\r\n  };\r\n\r\n  return treeData.reduce(\r\n    (total, currentNode) => total + traverse(currentNode),\r\n    0\r\n  );\r\n}\r\n\r\n/**\r\n * Get the <targetIndex>th visible node in the tree data.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} targetIndex - The index of the node to search for\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }|null} node - The node at targetIndex, or null if not found\r\n */\r\nexport function getVisibleNodeInfoAtIndex({\r\n  treeData,\r\n  index: targetIndex,\r\n  getNodeKey\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return null;\r\n  }\r\n\r\n  // Call the tree traversal with a pseudo-root node\r\n  const result = getNodeDataAtTreeIndexOrNextIndex({\r\n    targetIndex,\r\n    getNodeKey,\r\n    node: {\r\n      children: treeData,\r\n      expanded: true\r\n    },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: [],\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result.node) {\r\n    return result;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Walk descendants depth-first and call a callback on each\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return void\r\n */\r\nexport function walk({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return;\r\n  }\r\n\r\n  walkDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  });\r\n}\r\n\r\n/**\r\n * Perform a depth-first transversal of the descendants and\r\n *  make a change to every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {function} callback - Function to call on each node\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function map({\r\n  treeData,\r\n  getNodeKey,\r\n  callback,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  return mapDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    path: [],\r\n    lowerSiblingCounts: []\r\n  }).node.children;\r\n}\r\n\r\n/**\r\n * Expand or close every node in the tree\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?boolean} expanded - Whether the node is expanded or not\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function toggleExpandedForAll({ treeData, expanded = true }) {\r\n  return map({\r\n    treeData,\r\n    callback: ({ node }) => ({ ...node, expanded }),\r\n    getNodeKey: ({ treeIndex }) => treeIndex,\r\n    ignoreCollapsed: false\r\n  });\r\n}\r\n\r\n/**\r\n * Replaces node at path with object, or callback-defined object\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The changed tree data\r\n */\r\nexport function changeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  newNode,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  const RESULT_MISS = \"RESULT_MISS\";\r\n  const traverse = ({\r\n    isPseudoRoot = false,\r\n    node,\r\n    currentTreeIndex,\r\n    pathIndex\r\n  }) => {\r\n    if (\r\n      !isPseudoRoot &&\r\n      getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\r\n    ) {\r\n      return RESULT_MISS;\r\n    }\r\n\r\n    if (pathIndex >= path.length - 1) {\r\n      // If this is the final location in the path, return its changed form\r\n      return typeof newNode === \"function\"\r\n        ? newNode({ node, treeIndex: currentTreeIndex })\r\n        : newNode;\r\n    }\r\n    if (!node.children) {\r\n      // If this node is part of the path, but has no children, return the unchanged node\r\n      throw new Error(\"Path referenced children of node with no children.\");\r\n    }\r\n\r\n    let nextTreeIndex = currentTreeIndex + 1;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      const result = traverse({\r\n        node: node.children[i],\r\n        currentTreeIndex: nextTreeIndex,\r\n        pathIndex: pathIndex + 1\r\n      });\r\n\r\n      // If the result went down the correct path\r\n      if (result !== RESULT_MISS) {\r\n        if (result) {\r\n          // If the result was truthy (in this case, an object),\r\n          //  pass it to the next level of recursion up\r\n          return {\r\n            ...node,\r\n            children: [\r\n              ...node.children.slice(0, i),\r\n              result,\r\n              ...node.children.slice(i + 1)\r\n            ]\r\n          };\r\n        }\r\n        // If the result was falsy (returned from the newNode function), then\r\n        //  delete the node from the array.\r\n        return {\r\n          ...node,\r\n          children: [\r\n            ...node.children.slice(0, i),\r\n            ...node.children.slice(i + 1)\r\n          ]\r\n        };\r\n      }\r\n\r\n      nextTreeIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    return RESULT_MISS;\r\n  };\r\n\r\n  // Use a pseudo-root node in the beginning traversal\r\n  const result = traverse({\r\n    node: { children: treeData },\r\n    currentTreeIndex: -1,\r\n    pathIndex: -1,\r\n    isPseudoRoot: true\r\n  });\r\n\r\n  if (result === RESULT_MISS) {\r\n    throw new Error(\"No node found at the given path.\");\r\n  }\r\n\r\n  return result.children;\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object[]} changedTreeData - The tree data with the node removed\r\n */\r\nexport function removeNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  return changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: null // Delete the node\r\n  });\r\n}\r\n\r\n/**\r\n * Removes the node at the specified path and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node removed\r\n * @return {Object} result.node - The node that was removed\r\n * @return {number} result.treeIndex - The previous treeIndex of the removed node\r\n */\r\nexport function removeNode({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let removedNode = null;\r\n  let removedTreeIndex = null;\r\n  const nextTreeData = changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    newNode: ({ node, treeIndex }) => {\r\n      // Store the target node and delete it from the tree\r\n      removedNode = node;\r\n      removedTreeIndex = treeIndex;\r\n\r\n      return null;\r\n    }\r\n  });\r\n\r\n  return {\r\n    treeData: nextTreeData,\r\n    node: removedNode,\r\n    treeIndex: removedTreeIndex\r\n  };\r\n}\r\n\r\n/**\r\n * Gets the node at the specified path\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n */\r\nexport function getNodeAtPath({\r\n  treeData,\r\n  path,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  let foundNodeInfo = null;\r\n\r\n  try {\r\n    changeNodeAtPath({\r\n      treeData,\r\n      path,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      newNode: ({ node, treeIndex }) => {\r\n        foundNodeInfo = { node, treeIndex };\r\n        return node;\r\n      }\r\n    });\r\n  } catch (err) {\r\n    // Ignore the error -- the null return will be explanation enough\r\n  }\r\n\r\n  return foundNodeInfo;\r\n}\r\n\r\n/**\r\n * Adds the node to the specified parent and returns the resulting treeData.\r\n *\r\n * @param {!Object[]} treeData\r\n * @param {!Object} newNode - The node to insert\r\n * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The updated tree data\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n */\r\nexport function addNodeUnderParent({\r\n  treeData,\r\n  newNode,\r\n  parentKey = null,\r\n  getNodeKey,\r\n  ignoreCollapsed = true,\r\n  expandParent = false,\r\n  addAsFirstChild = false\r\n}) {\r\n  if (parentKey === null) {\r\n    return {\r\n      treeData: [...(treeData || []), newNode],\r\n      treeIndex: (treeData || []).length\r\n    };\r\n  }\r\n\r\n  let insertedTreeIndex = null;\r\n  let hasBeenAdded = false;\r\n  const changedTreeData = map({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: ({ node, treeIndex, path }) => {\r\n      const key = path ? path[path.length - 1] : null;\r\n      // Return nodes that are not the parent as-is\r\n      if (hasBeenAdded || key !== parentKey) {\r\n        return node;\r\n      }\r\n      hasBeenAdded = true;\r\n\r\n      const parentNode = {\r\n        ...node\r\n      };\r\n\r\n      if (expandParent) {\r\n        parentNode.expanded = true;\r\n      }\r\n\r\n      // If no children exist yet, just add the single newNode\r\n      if (!parentNode.children) {\r\n        insertedTreeIndex = treeIndex + 1;\r\n        return {\r\n          ...parentNode,\r\n          children: [newNode]\r\n        };\r\n      }\r\n\r\n      if (typeof parentNode.children === \"function\") {\r\n        throw new Error(\"Cannot add to children defined by a function\");\r\n      }\r\n\r\n      let nextTreeIndex = treeIndex + 1;\r\n      for (let i = 0; i < parentNode.children.length; i += 1) {\r\n        nextTreeIndex +=\r\n          1 +\r\n          getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\r\n      }\r\n\r\n      insertedTreeIndex = nextTreeIndex;\r\n\r\n      const children = addAsFirstChild\r\n        ? [newNode, ...parentNode.children]\r\n        : [...parentNode.children, newNode];\r\n\r\n      return {\r\n        ...parentNode,\r\n        children\r\n      };\r\n    }\r\n  });\r\n\r\n  if (!hasBeenAdded) {\r\n    throw new Error(\"No node found with the given key.\");\r\n  }\r\n\r\n  return {\r\n    treeData: changedTreeData,\r\n    treeIndex: insertedTreeIndex\r\n  };\r\n}\r\n\r\nfunction addNodeAtDepthAndIndex({\r\n  targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  ignoreCollapsed,\r\n  expandParent,\r\n  isPseudoRoot = false,\r\n  isLastChild,\r\n  node,\r\n  currentIndex,\r\n  currentDepth,\r\n  getNodeKey,\r\n  path = []\r\n}) {\r\n  const selfPath = n =>\r\n    isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\r\n\r\n  // If the current position is the only possible place to add, add it\r\n  if (\r\n    currentIndex >= minimumTreeIndex - 1 ||\r\n    (isLastChild && !(node.children && node.children.length))\r\n  ) {\r\n    if (typeof node.children === \"function\") {\r\n      throw new Error(\"Cannot add to children defined by a function\");\r\n    } else {\r\n      const extraNodeProps = expandParent ? { expanded: true } : {};\r\n      const nextNode = {\r\n        ...node,\r\n\r\n        ...extraNodeProps,\r\n        children: node.children ? [newNode, ...node.children] : [newNode]\r\n      };\r\n\r\n      return {\r\n        node: nextNode,\r\n        nextIndex: currentIndex + 2,\r\n        insertedTreeIndex: currentIndex + 1,\r\n        parentPath: selfPath(nextNode),\r\n        parentNode: isPseudoRoot ? null : nextNode\r\n      };\r\n    }\r\n  }\r\n\r\n  // If this is the target depth for the insertion,\r\n  // i.e., where the newNode can be added to the current node's children\r\n  if (currentDepth >= targetDepth - 1) {\r\n    // Skip over nodes with no children or hidden children\r\n    if (\r\n      !node.children ||\r\n      typeof node.children === \"function\" ||\r\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return { node, nextIndex: currentIndex + 1 };\r\n    }\r\n\r\n    // Scan over the children to see if there's a place among them that fulfills\r\n    // the minimumTreeIndex requirement\r\n    let childIndex = currentIndex + 1;\r\n    let insertedTreeIndex = null;\r\n    let insertIndex = null;\r\n    for (let i = 0; i < node.children.length; i += 1) {\r\n      // If a valid location is found, mark it as the insertion location and\r\n      // break out of the loop\r\n      if (childIndex >= minimumTreeIndex) {\r\n        insertedTreeIndex = childIndex;\r\n        insertIndex = i;\r\n        break;\r\n      }\r\n\r\n      // Increment the index by the child itself plus the number of descendants it has\r\n      childIndex +=\r\n        1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n    }\r\n\r\n    // If no valid indices to add the node were found\r\n    if (insertIndex === null) {\r\n      // If the last position in this node's children is less than the minimum index\r\n      // and there are more children on the level of this node, return without insertion\r\n      if (childIndex < minimumTreeIndex && !isLastChild) {\r\n        return { node, nextIndex: childIndex };\r\n      }\r\n\r\n      // Use the last position in the children array to insert the newNode\r\n      insertedTreeIndex = childIndex;\r\n      insertIndex = node.children.length;\r\n    }\r\n\r\n    // Insert the newNode at the insertIndex\r\n    const nextNode = {\r\n      ...node,\r\n      children: [\r\n        ...node.children.slice(0, insertIndex),\r\n        newNode,\r\n        ...node.children.slice(insertIndex)\r\n      ]\r\n    };\r\n\r\n    // Return node with successful insert result\r\n    return {\r\n      node: nextNode,\r\n      nextIndex: childIndex,\r\n      insertedTreeIndex,\r\n      parentPath: selfPath(nextNode),\r\n      parentNode: isPseudoRoot ? null : nextNode\r\n    };\r\n  }\r\n\r\n  // Skip over nodes with no children or hidden children\r\n  if (\r\n    !node.children ||\r\n    typeof node.children === \"function\" ||\r\n    (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n  ) {\r\n    return { node, nextIndex: currentIndex + 1 };\r\n  }\r\n\r\n  // Get all descendants\r\n  let insertedTreeIndex = null;\r\n  let pathFragment = null;\r\n  let parentNode = null;\r\n  let childIndex = currentIndex + 1;\r\n  let newChildren = node.children;\r\n  if (typeof newChildren !== \"function\") {\r\n    newChildren = newChildren.map((child, i) => {\r\n      if (insertedTreeIndex !== null) {\r\n        return child;\r\n      }\r\n\r\n      const mapResult = addNodeAtDepthAndIndex({\r\n        targetDepth,\r\n        minimumTreeIndex,\r\n        newNode,\r\n        ignoreCollapsed,\r\n        expandParent,\r\n        isLastChild: isLastChild && i === newChildren.length - 1,\r\n        node: child,\r\n        currentIndex: childIndex,\r\n        currentDepth: currentDepth + 1,\r\n        getNodeKey,\r\n        path: [] // Cannot determine the parent path until the children have been processed\r\n      });\r\n\r\n      if (\"insertedTreeIndex\" in mapResult) {\r\n        ({\r\n          insertedTreeIndex,\r\n          parentNode,\r\n          parentPath: pathFragment\r\n        } = mapResult);\r\n      }\r\n\r\n      childIndex = mapResult.nextIndex;\r\n\r\n      return mapResult.node;\r\n    });\r\n  }\r\n\r\n  const nextNode = { ...node, children: newChildren };\r\n  const result = {\r\n    node: nextNode,\r\n    nextIndex: childIndex\r\n  };\r\n\r\n  if (insertedTreeIndex !== null) {\r\n    result.insertedTreeIndex = insertedTreeIndex;\r\n    result.parentPath = [...selfPath(nextNode), ...pathFragment];\r\n    result.parentNode = parentNode;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Insert a node into the tree at the given depth, after the minimum index\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n * @param {!Object} newNode - The node to insert into the tree\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n *\r\n * @return {Object} result\r\n * @return {Object[]} result.treeData - The tree data with the node added\r\n * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n * @return {Object} result.parentNode - The parent node of the inserted node\r\n */\r\nexport function insertNode({\r\n  treeData,\r\n  depth: targetDepth,\r\n  minimumTreeIndex,\r\n  newNode,\r\n  getNodeKey = () => {},\r\n  ignoreCollapsed = true,\r\n  expandParent = false\r\n}) {\r\n  if (!treeData && targetDepth === 0) {\r\n    return {\r\n      treeData: [newNode],\r\n      treeIndex: 0,\r\n      path: [getNodeKey({ node: newNode, treeIndex: 0 })],\r\n      parentNode: null\r\n    };\r\n  }\r\n\r\n  const insertResult = addNodeAtDepthAndIndex({\r\n    targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    ignoreCollapsed,\r\n    expandParent,\r\n    getNodeKey,\r\n    isPseudoRoot: true,\r\n    isLastChild: true,\r\n    node: { children: treeData },\r\n    currentIndex: -1,\r\n    currentDepth: -1\r\n  });\r\n\r\n  if (!(\"insertedTreeIndex\" in insertResult)) {\r\n    throw new Error(\"No suitable position found to insert.\");\r\n  }\r\n\r\n  const treeIndex = insertResult.insertedTreeIndex;\r\n  return {\r\n    treeData: insertResult.node.children,\r\n    treeIndex,\r\n    path: [\r\n      ...insertResult.parentPath,\r\n      getNodeKey({ node: newNode, treeIndex })\r\n    ],\r\n    parentNode: insertResult.parentNode\r\n  };\r\n}\r\n\r\n/**\r\n * Get tree data flattened.\r\n *\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n *\r\n * @return {{\r\n *      node: Object,\r\n *      path: []string|[]number,\r\n *      lowerSiblingCounts: []number\r\n *  }}[] nodes - The node array\r\n */\r\nexport function getFlatDataFromTree({\r\n  treeData,\r\n  getNodeKey,\r\n  ignoreCollapsed = true\r\n}) {\r\n  if (!treeData || treeData.length < 1) {\r\n    return [];\r\n  }\r\n\r\n  const flattened = [];\r\n  walk({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    callback: nodeInfo => {\r\n      flattened.push(nodeInfo);\r\n    }\r\n  });\r\n\r\n  return flattened;\r\n}\r\n\r\n/**\r\n * Generate a tree structure from flat data.\r\n *\r\n * @param {!Object[]} flatData\r\n * @param {!function=} getKey - Function to get the key from the nodeData\r\n * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n *\r\n * @return {Object[]} treeData - The flat data represented as a tree\r\n */\r\nexport function getTreeFromFlatData({\r\n  flatData,\r\n  getKey = node => node.id,\r\n  getParentKey = node => node.parentId,\r\n  rootKey = \"0\"\r\n}) {\r\n  if (!flatData) {\r\n    return [];\r\n  }\r\n\r\n  const childrenToParents = {};\r\n  flatData.forEach(child => {\r\n    const parentKey = getParentKey(child);\r\n\r\n    if (parentKey in childrenToParents) {\r\n      childrenToParents[parentKey].push(child);\r\n    } else {\r\n      childrenToParents[parentKey] = [child];\r\n    }\r\n  });\r\n\r\n  if (!(rootKey in childrenToParents)) {\r\n    return [];\r\n  }\r\n\r\n  const trav = parent => {\r\n    const parentKey = getKey(parent);\r\n    if (parentKey in childrenToParents) {\r\n      return {\r\n        ...parent,\r\n        children: childrenToParents[parentKey].map(child => trav(child))\r\n      };\r\n    }\r\n\r\n    return { ...parent };\r\n  };\r\n\r\n  return childrenToParents[rootKey].map(child => trav(child));\r\n}\r\n\r\n/**\r\n * Check if a node is a descendant of another node.\r\n *\r\n * @param {!Object} older - Potential ancestor of younger node\r\n * @param {!Object} younger - Potential descendant of older node\r\n *\r\n * @return {boolean}\r\n */\r\nexport function isDescendant(older, younger) {\r\n  return (\r\n    !!older.children &&\r\n    typeof older.children !== \"function\" &&\r\n    older.children.some(\r\n      child => child === younger || isDescendant(child, younger)\r\n    )\r\n  );\r\n}\r\n\r\n/**\r\n * Get the maximum depth of the children (the depth of the root node is 0).\r\n *\r\n * @param {!Object} node - Node in the tree\r\n * @param {?number} depth - The current depth\r\n *\r\n * @return {number} maxDepth - The deepest depth in the tree\r\n */\r\nexport function getDepth(node, depth = 0) {\r\n  if (!node.children) {\r\n    return depth;\r\n  }\r\n\r\n  if (typeof node.children === \"function\") {\r\n    return depth + 1;\r\n  }\r\n\r\n  return node.children.reduce(\r\n    (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\r\n    depth\r\n  );\r\n}\r\n\r\n/**\r\n * Find nodes matching a search query in the tree,\r\n *\r\n * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n * @param {!Object[]} treeData - Tree data\r\n * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n *\r\n * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n *                               it will be the same as the original tree data.\r\n */\r\nexport function find({\r\n  getNodeKey,\r\n  treeData,\r\n  searchQuery,\r\n  searchMethod,\r\n  searchFocusOffset,\r\n  expandAllMatchPaths = false,\r\n  expandFocusMatchPaths = true\r\n}) {\r\n  let matchCount = 0;\r\n  const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\r\n    let matches = [];\r\n    let isSelfMatch = false;\r\n    let hasFocusMatch = false;\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n    const extraInfo = isPseudoRoot\r\n      ? null\r\n      : {\r\n          path: selfPath,\r\n          treeIndex: currentIndex\r\n        };\r\n\r\n    // Nodes with with children that aren't lazy\r\n    const hasChildren =\r\n      node.children &&\r\n      typeof node.children !== \"function\" &&\r\n      node.children.length > 0;\r\n\r\n    // Examine the current node to see if it is a match\r\n    if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\r\n      if (matchCount === searchFocusOffset) {\r\n        hasFocusMatch = true;\r\n      }\r\n\r\n      // Keep track of the number of matching nodes, so we know when the searchFocusOffset\r\n      //  is reached\r\n      matchCount += 1;\r\n\r\n      // We cannot add this node to the matches right away, as it may be changed\r\n      //  during the search of the descendants. The entire node is used in\r\n      //  comparisons between nodes inside the `matches` and `treeData` results\r\n      //  of this method (`find`)\r\n      isSelfMatch = true;\r\n    }\r\n\r\n    let childIndex = currentIndex;\r\n    const newNode = { ...node };\r\n    if (hasChildren) {\r\n      // Get all descendants\r\n      newNode.children = newNode.children.map(child => {\r\n        const mapResult = trav({\r\n          node: child,\r\n          currentIndex: childIndex + 1,\r\n          path: selfPath\r\n        });\r\n\r\n        // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\r\n        // if the child is expanded.\r\n        //\r\n        // The child could have been expanded from the start,\r\n        // or expanded due to a matching node being found in its descendants\r\n        if (mapResult.node.expanded) {\r\n          childIndex = mapResult.treeIndex;\r\n        } else {\r\n          childIndex += 1;\r\n        }\r\n\r\n        if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\r\n          matches = [...matches, ...mapResult.matches];\r\n          if (mapResult.hasFocusMatch) {\r\n            hasFocusMatch = true;\r\n          }\r\n\r\n          // Expand the current node if it has descendants matching the search\r\n          // and the settings are set to do so.\r\n          if (\r\n            (expandAllMatchPaths && mapResult.matches.length > 0) ||\r\n            ((expandAllMatchPaths || expandFocusMatchPaths) &&\r\n              mapResult.hasFocusMatch)\r\n          ) {\r\n            newNode.expanded = true;\r\n          }\r\n        }\r\n\r\n        return mapResult.node;\r\n      });\r\n    }\r\n\r\n    // Cannot assign a treeIndex to hidden nodes\r\n    if (!isPseudoRoot && !newNode.expanded) {\r\n      matches = matches.map(match => ({\r\n        ...match,\r\n        treeIndex: null\r\n      }));\r\n    }\r\n\r\n    // Add this node to the matches if it fits the search criteria.\r\n    // This is performed at the last minute so newNode can be sent in its final form.\r\n    if (isSelfMatch) {\r\n      matches = [{ ...extraInfo, node: newNode }, ...matches];\r\n    }\r\n\r\n    return {\r\n      node: matches.length > 0 ? newNode : node,\r\n      matches,\r\n      hasFocusMatch,\r\n      treeIndex: childIndex\r\n    };\r\n  };\r\n\r\n  const result = trav({\r\n    node: { children: treeData },\r\n    isPseudoRoot: true,\r\n    currentIndex: -1\r\n  });\r\n\r\n  return {\r\n    matches: result.matches,\r\n    treeData: result.node.children\r\n  };\r\n}\r\n\r\nexport function treeToList(arr) {\r\n  let treeList = arr || [];\r\n\r\n  //\r\n  let leafs = [];\r\n\r\n  //\r\n  let roots = [];\r\n\r\n  //\r\n  let list = [];\r\n\r\n  for (let i = 0; i < treeList.length; i++) {\r\n    const d = treeList[i];\r\n\r\n    if (!d) {\r\n      continue;\r\n    }\r\n\r\n    const childrens = d.children || [];\r\n\r\n    d.__depth = 0;\r\n\r\n    list.push(d);\r\n    roots.push(d);\r\n\r\n    if (childrens.length > 0) {\r\n      getChildren(d, 0);\r\n    } else {\r\n      leafs.push(d);\r\n    }\r\n  }\r\n\r\n  function getChildren(d, depth) {\r\n    const tempArr = d.children || [];\r\n\r\n    for (let i = 0; i < tempArr.length; i++) {\r\n      const d = tempArr[i];\r\n      const childrens = d.children || [];\r\n\r\n      d.__depth = depth + 1;\r\n\r\n      list.push(d);\r\n\r\n      if (childrens.length > 0) {\r\n        getChildren(d, depth + 1);\r\n      } else {\r\n        leafs.push(d);\r\n      }\r\n    }\r\n  }\r\n\r\n  return { list, leafs, roots };\r\n}\r\n\r\nexport function getDataListWithExpanded(list, expandedKeys = [], rowKey) {\r\n  let arr = [];\r\n\r\n  for (let i = 0; i < list.length; i++) {\r\n    let d = list[i];\r\n\r\n    d.__depth = 0;\r\n\r\n    arr.push(d);\r\n\r\n    if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n      if (d.children) {\r\n        setChildren(d, 0);\r\n      }\r\n    }\r\n  }\r\n\r\n  function setChildren(c, depth) {\r\n    let cArr = c.children;\r\n    for (let i = 0; i < cArr.length; i++) {\r\n      let d = cArr[i];\r\n      d.__depth = depth + 1;\r\n      arr.push(d);\r\n\r\n      if (expandedKeys.indexOf(d[rowKey]) > -1) {\r\n        if (d.children) {\r\n          setChildren(d, depth + 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\nexport function getScrollbarWidth() {\r\n  var userAgent = navigator.userAgent; //userAgent\r\n\r\n  if (userAgent.indexOf(\"Chrome\") > -1) {\r\n    return 6;\r\n  }\r\n\r\n  var oP = document.createElement(\"p\"),\r\n    styles = {\r\n      width: \"100px\",\r\n      height: \"100px\",\r\n      overflowY: \"scroll\"\r\n    },\r\n    i,\r\n    scrollbarWidth;\r\n\r\n  for (i in styles) {\r\n    oP.style[i] = styles[i];\r\n  }\r\n  document.body.appendChild(oP);\r\n  scrollbarWidth = oP.offsetWidth - oP.clientWidth;\r\n  oP.remove();\r\n\r\n  return scrollbarWidth;\r\n}\r\n"]}]}