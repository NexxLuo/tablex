{"version":3,"sources":["e:/WebRoot/tablex/packages/site/examples/Editable/complex/tree-data-utils.js","e:/WebRoot/tablex/packages/site/examples/Editable/complex/index.js","e:/WebRoot/tablex/packages/site/examples/Editable/index.mdx"],"names":["getNodeDataAtTreeIndexOrNextIndex","_ref","targetIndex","node","currentIndex","getNodeKey","_ref$path","path","_ref$lowerSiblingCoun","lowerSiblingCounts","_ref$ignoreCollapsed","ignoreCollapsed","_ref$isPseudoRoot","isPseudoRoot","selfPath","concat","Object","toConsumableArray","treeIndex","children","expanded","nextIndex","childIndex","childCount","length","i","result","getDescendantCount","_ref2","_ref2$ignoreCollapsed","getVisibleNodeCount","_ref5","treeData","reduce","total","currentNode","traverse","getVisibleNodeInfoAtIndex","_ref6","index","walk","_ref7","callback","_ref7$ignoreCollapsed","walkDescendants","_ref3","_ref3$isPseudoRoot","_ref3$parentNode","parentNode","_ref3$path","_ref3$lowerSiblingCou","map","_ref8","_ref8$ignoreCollapsed","mapDescendants","_ref4","_ref4$isPseudoRoot","_ref4$parentNode","_ref4$path","_ref4$lowerSiblingCou","nextNode","objectSpread","selfInfo","child","mapResult","toggleExpandedForAll","_ref9","_ref9$expanded","_ref10","_ref11","changeNodeAtPath","_ref12","newNode","_ref12$ignoreCollapse","_ref13","_ref13$isPseudoRoot","currentTreeIndex","pathIndex","Error","nextTreeIndex","slice","removeNodeAtPath","_ref14","_ref14$ignoreCollapse","removeNode","_ref15","_ref15$ignoreCollapse","removedNode","removedTreeIndex","_ref16","getNodeAtPath","_ref17","_ref17$ignoreCollapse","foundNodeInfo","_ref18","err","addNodeUnderParent","_ref19","_ref19$parentKey","parentKey","_ref19$ignoreCollapse","_ref19$expandParent","expandParent","_ref19$addAsFirstChil","addAsFirstChild","insertedTreeIndex","hasBeenAdded","changedTreeData","_ref20","key","insertNode","_ref22","targetDepth","depth","minimumTreeIndex","_ref22$getNodeKey","_ref22$ignoreCollapse","_ref22$expandParent","insertResult","addNodeAtDepthAndIndex","_ref21","_ref21$isPseudoRoot","isLastChild","currentDepth","_ref21$path","n","extraNodeProps","parentPath","insertIndex","pathFragment","newChildren","getFlatDataFromTree","_ref23","_ref23$ignoreCollapse","flattened","nodeInfo","push","getTreeFromFlatData","_ref24","flatData","_ref24$getKey","getKey","id","_ref24$getParentKey","getParentKey","parentId","_ref24$rootKey","rootKey","childrenToParents","forEach","trav","parent","isDescendant","older","younger","some","getDepth","arguments","undefined","deepest","Math","max","find","_ref25","searchQuery","searchMethod","searchFocusOffset","_ref25$expandAllMatch","expandAllMatchPaths","_ref25$expandFocusMat","expandFocusMatchPaths","matchCount","_ref26","_ref26$isPseudoRoot","_ref26$path","matches","isSelfMatch","hasFocusMatch","extraInfo","hasChildren","match","Search","Input","Demo","columns","dataIndex","title","width","editor","value","record","onchange","ref","validate","react_default","a","createElement","input","defaultValue","onChange","v","quantities","target","input_number","onKeyDown","e","stopPropagation","unitPrice","render","row","isNaN","state","loading","rawTreeData","rawFlatData","expandedRowKeys","selectedRowKeys","getData","_this","setState","url","options","xhr","onSuccess","data","_","uniqBy","d","code","bl","pid","len","pl","substring","unflatten","XMLHttpRequest","open","onreadystatechange","onload","status","res","responseText","JSON","parse","onerror","onError","send","scrollToItem","refs","tb","expandTo","keys","expandAll","collapseAll","contentMenuRow","showContextMenu","left","top","el","document","getElementById","style","display","focus","hideContextMenu","onRow","onContextMenu","preventDefault","pageX","pageY","setTreeData","bd","Date","console","log","getTime","rowKey","deleteRow","findIndex","splice","copiedRow","copy","rowData","k","hasOwnProperty","str","stringify","body","appendChild","setAttribute","select","execCommand","removeChild","pasteChildren","targetRow","sourceRow","_flatten","flatten","list","sourceRowList","roots","assign","isCut","cut","toggleSelectOrExpand","type","stateName","nextKeys","keysMap","_flatten2","isExist","defineProperty","selectAll","expandToggle","onMenuClick","fn","del","export","searchIndex","searchedKey","onChangeSearch","onSearch","forceUpdate","searchedIndex","name","indexOf","onFilter","_this$state","flatDataMap","paths","j","p","rowClassName","_this2","this","menuItemStyle","height","lineHeight","lib","editable","onExpandedRowsChange","onSelectChange","selectMode","checkStrictly","orderNumber","resizable","validateTrigger","header","padding","es_button","onClick","margin","float","placeholder","menu","position","border","boxShadow","tabIndex","onBlur","selectable","Item","Component","layoutProps","MDXLayout","MDXContent","components","props","objectWithoutProperties","index_es","mdxType","parentName","className","index_esm","__position","__code","__scope","Playground","Props","Table","Checkbox","Complex","_React$Component","classCallCheck","align","validator","valid","message","possibleConstructorReturn","getPrototypeOf","call","generateData","inherits","createClass","count","prefix","Array","fill","rowIndex","column","columnIndex","floor","random","changedRows","newData","lib_default","editTools","onEditSave","bind","React","Editable_complex","isMDXComponent"],"mappings":"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","file":"static/js/examples-editable-index.8ec49706.js","sourcesContent":["/**\r\n * Performs a depth-first traversal over all of the node descendants,\r\n * incrementing currentIndex by 1 for each\r\n */\r\nfunction getNodeDataAtTreeIndexOrNextIndex({\r\n    targetIndex,\r\n    node,\r\n    currentIndex,\r\n    getNodeKey,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n    ignoreCollapsed = true,\r\n    isPseudoRoot = false,\r\n  }) {\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = !isPseudoRoot\r\n      ? [...path, getNodeKey({ node, treeIndex: currentIndex })]\r\n      : [];\r\n  \r\n    // Return target node when found\r\n    if (currentIndex === targetIndex) {\r\n      return {\r\n        node,\r\n        lowerSiblingCounts,\r\n        path: selfPath,\r\n      };\r\n    }\r\n  \r\n    // Add one and continue for nodes with no children or hidden children\r\n    if (!node.children || (ignoreCollapsed && node.expanded !== true)) {\r\n      return { nextIndex: currentIndex + 1 };\r\n    }\r\n  \r\n    // Iterate over each child and their descendants and return the\r\n    // target node if childIndex reaches the targetIndex\r\n    let childIndex = currentIndex + 1;\r\n    const childCount = node.children.length;\r\n    for (let i = 0; i < childCount; i += 1) {\r\n      const result = getNodeDataAtTreeIndexOrNextIndex({\r\n        ignoreCollapsed,\r\n        getNodeKey,\r\n        targetIndex,\r\n        node: node.children[i],\r\n        currentIndex: childIndex,\r\n        lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n        path: selfPath,\r\n      });\r\n  \r\n      if (result.node) {\r\n        return result;\r\n      }\r\n  \r\n      childIndex = result.nextIndex;\r\n    }\r\n  \r\n    // If the target node is not found, return the farthest traversed index\r\n    return { nextIndex: childIndex };\r\n  }\r\n  \r\n  export function getDescendantCount({ node, ignoreCollapsed = true }) {\r\n    return (\r\n      getNodeDataAtTreeIndexOrNextIndex({\r\n        getNodeKey: () => {},\r\n        ignoreCollapsed,\r\n        node,\r\n        currentIndex: 0,\r\n        targetIndex: -1,\r\n      }).nextIndex - 1\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Walk all descendants of the given node, depth-first\r\n   *\r\n   * @param {Object} args - Function parameters\r\n   * @param {function} args.callback - Function to call on each node\r\n   * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n   *                                        as the parent of all the nodes in the tree\r\n   * @param {Object} args.node - A tree node\r\n   * @param {Object=} args.parentNode - The parent node of `node`\r\n   * @param {number} args.currentIndex - The treeIndex of `node`\r\n   * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n   * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n   *                                             previous nodes in this path\r\n   *\r\n   * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n   *                                    or false if the walk should be terminated\r\n   */\r\n  function walkDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot = false,\r\n    node,\r\n    parentNode = null,\r\n    currentIndex,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n  }) {\r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n    const selfInfo = isPseudoRoot\r\n      ? null\r\n      : {\r\n          node,\r\n          parentNode,\r\n          path: selfPath,\r\n          lowerSiblingCounts,\r\n          treeIndex: currentIndex,\r\n        };\r\n  \r\n    if (!isPseudoRoot) {\r\n      const callbackResult = callback(selfInfo);\r\n  \r\n      // Cut walk short if the callback returned false\r\n      if (callbackResult === false) {\r\n        return false;\r\n      }\r\n    }\r\n  \r\n    // Return self on nodes with no children or hidden children\r\n    if (\r\n      !node.children ||\r\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return currentIndex;\r\n    }\r\n  \r\n    // Get all descendants\r\n    let childIndex = currentIndex;\r\n    const childCount = node.children.length;\r\n    if (typeof node.children !== 'function') {\r\n      for (let i = 0; i < childCount; i += 1) {\r\n        childIndex = walkDescendants({\r\n          callback,\r\n          getNodeKey,\r\n          ignoreCollapsed,\r\n          node: node.children[i],\r\n          parentNode: isPseudoRoot ? null : node,\r\n          currentIndex: childIndex + 1,\r\n          lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n          path: selfPath,\r\n        });\r\n  \r\n        // Cut walk short if the callback returned false\r\n        if (childIndex === false) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n  \r\n    return childIndex;\r\n  }\r\n  \r\n  /**\r\n   * Perform a change on the given node and all its descendants, traversing the tree depth-first\r\n   *\r\n   * @param {Object} args - Function parameters\r\n   * @param {function} args.callback - Function to call on each node\r\n   * @param {function} args.getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean} args.ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   * @param {boolean=} args.isPseudoRoot - If true, this node has no real data, and only serves\r\n   *                                        as the parent of all the nodes in the tree\r\n   * @param {Object} args.node - A tree node\r\n   * @param {Object=} args.parentNode - The parent node of `node`\r\n   * @param {number} args.currentIndex - The treeIndex of `node`\r\n   * @param {number[]|string[]} args.path - Array of keys leading up to node to be changed\r\n   * @param {number[]} args.lowerSiblingCounts - An array containing the count of siblings beneath the\r\n   *                                             previous nodes in this path\r\n   *\r\n   * @return {number|false} nextIndex - Index of the next sibling of `node`,\r\n   *                                    or false if the walk should be terminated\r\n   */\r\n  function mapDescendants({\r\n    callback,\r\n    getNodeKey,\r\n    ignoreCollapsed,\r\n    isPseudoRoot = false,\r\n    node,\r\n    parentNode = null,\r\n    currentIndex,\r\n    path = [],\r\n    lowerSiblingCounts = [],\r\n  }) {\r\n    const nextNode = { ...node };\r\n  \r\n    // The pseudo-root is not considered in the path\r\n    const selfPath = isPseudoRoot\r\n      ? []\r\n      : [...path, getNodeKey({ node: nextNode, treeIndex: currentIndex })];\r\n    const selfInfo = {\r\n      node: nextNode,\r\n      parentNode,\r\n      path: selfPath,\r\n      lowerSiblingCounts,\r\n      treeIndex: currentIndex,\r\n    };\r\n  \r\n    // Return self on nodes with no children or hidden children\r\n    if (\r\n      !nextNode.children ||\r\n      (nextNode.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return {\r\n        treeIndex: currentIndex,\r\n        node: callback(selfInfo),\r\n      };\r\n    }\r\n  \r\n    // Get all descendants\r\n    let childIndex = currentIndex;\r\n    const childCount = nextNode.children.length;\r\n    if (typeof nextNode.children !== 'function') {\r\n      nextNode.children = nextNode.children.map((child, i) => {\r\n        const mapResult = mapDescendants({\r\n          callback,\r\n          getNodeKey,\r\n          ignoreCollapsed,\r\n          node: child,\r\n          parentNode: isPseudoRoot ? null : nextNode,\r\n          currentIndex: childIndex + 1,\r\n          lowerSiblingCounts: [...lowerSiblingCounts, childCount - i - 1],\r\n          path: selfPath,\r\n        });\r\n        childIndex = mapResult.treeIndex;\r\n  \r\n        return mapResult.node;\r\n      });\r\n    }\r\n  \r\n    return {\r\n      node: callback(selfInfo),\r\n      treeIndex: childIndex,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Count all the visible (expanded) descendants in the tree data.\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   *\r\n   * @return {number} count\r\n   */\r\n  export function getVisibleNodeCount({ treeData }) {\r\n    const traverse = node => {\r\n      if (\r\n        !node.children ||\r\n        node.expanded !== true ||\r\n        typeof node.children === 'function'\r\n      ) {\r\n        return 1;\r\n      }\r\n  \r\n      return (\r\n        1 +\r\n        node.children.reduce(\r\n          (total, currentNode) => total + traverse(currentNode),\r\n          0\r\n        )\r\n      );\r\n    };\r\n  \r\n    return treeData.reduce(\r\n      (total, currentNode) => total + traverse(currentNode),\r\n      0\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Get the <targetIndex>th visible node in the tree data.\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {!number} targetIndex - The index of the node to search for\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   *\r\n   * @return {{\r\n   *      node: Object,\r\n   *      path: []string|[]number,\r\n   *      lowerSiblingCounts: []number\r\n   *  }|null} node - The node at targetIndex, or null if not found\r\n   */\r\n  export function getVisibleNodeInfoAtIndex({\r\n    treeData,\r\n    index: targetIndex,\r\n    getNodeKey,\r\n  }) {\r\n    if (!treeData || treeData.length < 1) {\r\n      return null;\r\n    }\r\n  \r\n    // Call the tree traversal with a pseudo-root node\r\n    const result = getNodeDataAtTreeIndexOrNextIndex({\r\n      targetIndex,\r\n      getNodeKey,\r\n      node: {\r\n        children: treeData,\r\n        expanded: true,\r\n      },\r\n      currentIndex: -1,\r\n      path: [],\r\n      lowerSiblingCounts: [],\r\n      isPseudoRoot: true,\r\n    });\r\n  \r\n    if (result.node) {\r\n      return result;\r\n    }\r\n  \r\n    return null;\r\n  }\r\n  \r\n  /**\r\n   * Walk descendants depth-first and call a callback on each\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {function} callback - Function to call on each node\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return void\r\n   */\r\n  export function walk({\r\n    treeData,\r\n    getNodeKey,\r\n    callback,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    if (!treeData || treeData.length < 1) {\r\n      return;\r\n    }\r\n  \r\n    walkDescendants({\r\n      callback,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      isPseudoRoot: true,\r\n      node: { children: treeData },\r\n      currentIndex: -1,\r\n      path: [],\r\n      lowerSiblingCounts: [],\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Perform a depth-first transversal of the descendants and\r\n   *  make a change to every node in the tree\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {function} callback - Function to call on each node\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {Object[]} changedTreeData - The changed tree data\r\n   */\r\n  export function map({\r\n    treeData,\r\n    getNodeKey,\r\n    callback,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    if (!treeData || treeData.length < 1) {\r\n      return [];\r\n    }\r\n  \r\n    return mapDescendants({\r\n      callback,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      isPseudoRoot: true,\r\n      node: { children: treeData },\r\n      currentIndex: -1,\r\n      path: [],\r\n      lowerSiblingCounts: [],\r\n    }).node.children;\r\n  }\r\n  \r\n  /**\r\n   * Expand or close every node in the tree\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {?boolean} expanded - Whether the node is expanded or not\r\n   *\r\n   * @return {Object[]} changedTreeData - The changed tree data\r\n   */\r\n  export function toggleExpandedForAll({ treeData, expanded = true }) {\r\n    return map({\r\n      treeData,\r\n      callback: ({ node }) => ({ ...node, expanded }),\r\n      getNodeKey: ({ treeIndex }) => treeIndex,\r\n      ignoreCollapsed: false,\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Replaces node at path with object, or callback-defined object\r\n   *\r\n   * @param {!Object[]} treeData\r\n   * @param {number[]|string[]} path - Array of keys leading up to node to be changed\r\n   * @param {function|any} newNode - Node to replace the node at the path with, or a function producing the new node\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {Object[]} changedTreeData - The changed tree data\r\n   */\r\n  export function changeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    newNode,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    const RESULT_MISS = 'RESULT_MISS';\r\n    const traverse = ({\r\n      isPseudoRoot = false,\r\n      node,\r\n      currentTreeIndex,\r\n      pathIndex,\r\n    }) => {\r\n      if (\r\n        !isPseudoRoot &&\r\n        getNodeKey({ node, treeIndex: currentTreeIndex }) !== path[pathIndex]\r\n      ) {\r\n        return RESULT_MISS;\r\n      }\r\n  \r\n      if (pathIndex >= path.length - 1) {\r\n        // If this is the final location in the path, return its changed form\r\n        return typeof newNode === 'function'\r\n          ? newNode({ node, treeIndex: currentTreeIndex })\r\n          : newNode;\r\n      }\r\n      if (!node.children) {\r\n        // If this node is part of the path, but has no children, return the unchanged node\r\n        throw new Error('Path referenced children of node with no children.');\r\n      }\r\n  \r\n      let nextTreeIndex = currentTreeIndex + 1;\r\n      for (let i = 0; i < node.children.length; i += 1) {\r\n        const result = traverse({\r\n          node: node.children[i],\r\n          currentTreeIndex: nextTreeIndex,\r\n          pathIndex: pathIndex + 1,\r\n        });\r\n  \r\n        // If the result went down the correct path\r\n        if (result !== RESULT_MISS) {\r\n          if (result) {\r\n            // If the result was truthy (in this case, an object),\r\n            //  pass it to the next level of recursion up\r\n            return {\r\n              ...node,\r\n              children: [\r\n                ...node.children.slice(0, i),\r\n                result,\r\n                ...node.children.slice(i + 1),\r\n              ],\r\n            };\r\n          }\r\n          // If the result was falsy (returned from the newNode function), then\r\n          //  delete the node from the array.\r\n          return {\r\n            ...node,\r\n            children: [\r\n              ...node.children.slice(0, i),\r\n              ...node.children.slice(i + 1),\r\n            ],\r\n          };\r\n        }\r\n  \r\n        nextTreeIndex +=\r\n          1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n      }\r\n  \r\n      return RESULT_MISS;\r\n    };\r\n  \r\n    // Use a pseudo-root node in the beginning traversal\r\n    const result = traverse({\r\n      node: { children: treeData },\r\n      currentTreeIndex: -1,\r\n      pathIndex: -1,\r\n      isPseudoRoot: true,\r\n    });\r\n  \r\n    if (result === RESULT_MISS) {\r\n      throw new Error('No node found at the given path.');\r\n    }\r\n  \r\n    return result.children;\r\n  }\r\n  \r\n  /**\r\n   * Removes the node at the specified path and returns the resulting treeData.\r\n   *\r\n   * @param {!Object[]} treeData\r\n   * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {Object[]} changedTreeData - The tree data with the node removed\r\n   */\r\n  export function removeNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    return changeNodeAtPath({\r\n      treeData,\r\n      path,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      newNode: null, // Delete the node\r\n    });\r\n  }\r\n  \r\n  /**\r\n   * Removes the node at the specified path and returns the resulting treeData.\r\n   *\r\n   * @param {!Object[]} treeData\r\n   * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {Object} result\r\n   * @return {Object[]} result.treeData - The tree data with the node removed\r\n   * @return {Object} result.node - The node that was removed\r\n   * @return {number} result.treeIndex - The previous treeIndex of the removed node\r\n   */\r\n  export function removeNode({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    let removedNode = null;\r\n    let removedTreeIndex = null;\r\n    const nextTreeData = changeNodeAtPath({\r\n      treeData,\r\n      path,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      newNode: ({ node, treeIndex }) => {\r\n        // Store the target node and delete it from the tree\r\n        removedNode = node;\r\n        removedTreeIndex = treeIndex;\r\n  \r\n        return null;\r\n      },\r\n    });\r\n  \r\n    return {\r\n      treeData: nextTreeData,\r\n      node: removedNode,\r\n      treeIndex: removedTreeIndex,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Gets the node at the specified path\r\n   *\r\n   * @param {!Object[]} treeData\r\n   * @param {number[]|string[]} path - Array of keys leading up to node to be deleted\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {Object|null} nodeInfo - The node info at the given path, or null if not found\r\n   */\r\n  export function getNodeAtPath({\r\n    treeData,\r\n    path,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    let foundNodeInfo = null;\r\n  \r\n    try {\r\n      changeNodeAtPath({\r\n        treeData,\r\n        path,\r\n        getNodeKey,\r\n        ignoreCollapsed,\r\n        newNode: ({ node, treeIndex }) => {\r\n          foundNodeInfo = { node, treeIndex };\r\n          return node;\r\n        },\r\n      });\r\n    } catch (err) {\r\n      // Ignore the error -- the null return will be explanation enough\r\n    }\r\n  \r\n    return foundNodeInfo;\r\n  }\r\n  \r\n  /**\r\n   * Adds the node to the specified parent and returns the resulting treeData.\r\n   *\r\n   * @param {!Object[]} treeData\r\n   * @param {!Object} newNode - The node to insert\r\n   * @param {number|string} parentKey - The key of the to-be parentNode of the node\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   * @param {boolean=} expandParent - If true, expands the parentNode specified by parentPath\r\n   * @param {boolean=} addAsFirstChild - If true, adds new node as first child of tree\r\n   *\r\n   * @return {Object} result\r\n   * @return {Object[]} result.treeData - The updated tree data\r\n   * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n   */\r\n  export function addNodeUnderParent({\r\n    treeData,\r\n    newNode,\r\n    parentKey = null,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n    expandParent = false,\r\n    addAsFirstChild = false,\r\n  }) {\r\n    if (parentKey === null) {\r\n      return {\r\n        treeData: [...(treeData || []), newNode],\r\n        treeIndex: (treeData || []).length,\r\n      };\r\n    }\r\n  \r\n    let insertedTreeIndex = null;\r\n    let hasBeenAdded = false;\r\n    const changedTreeData = map({\r\n      treeData,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      callback: ({ node, treeIndex, path }) => {\r\n        const key = path ? path[path.length - 1] : null;\r\n        // Return nodes that are not the parent as-is\r\n        if (hasBeenAdded || key !== parentKey) {\r\n          return node;\r\n        }\r\n        hasBeenAdded = true;\r\n  \r\n        const parentNode = {\r\n          ...node,\r\n        };\r\n  \r\n        if (expandParent) {\r\n          parentNode.expanded = true;\r\n        }\r\n  \r\n        // If no children exist yet, just add the single newNode\r\n        if (!parentNode.children) {\r\n          insertedTreeIndex = treeIndex + 1;\r\n          return {\r\n            ...parentNode,\r\n            children: [newNode],\r\n          };\r\n        }\r\n  \r\n        if (typeof parentNode.children === 'function') {\r\n          throw new Error('Cannot add to children defined by a function');\r\n        }\r\n  \r\n        let nextTreeIndex = treeIndex + 1;\r\n        for (let i = 0; i < parentNode.children.length; i += 1) {\r\n          nextTreeIndex +=\r\n            1 +\r\n            getDescendantCount({ node: parentNode.children[i], ignoreCollapsed });\r\n        }\r\n  \r\n        insertedTreeIndex = nextTreeIndex;\r\n  \r\n        const children = addAsFirstChild\r\n          ? [newNode, ...parentNode.children]\r\n          : [...parentNode.children, newNode];\r\n  \r\n        return {\r\n          ...parentNode,\r\n          children,\r\n        };\r\n      },\r\n    });\r\n  \r\n    if (!hasBeenAdded) {\r\n      throw new Error('No node found with the given key.');\r\n    }\r\n  \r\n    return {\r\n      treeData: changedTreeData,\r\n      treeIndex: insertedTreeIndex,\r\n    };\r\n  }\r\n  \r\n  function addNodeAtDepthAndIndex({\r\n    targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    ignoreCollapsed,\r\n    expandParent,\r\n    isPseudoRoot = false,\r\n    isLastChild,\r\n    node,\r\n    currentIndex,\r\n    currentDepth,\r\n    getNodeKey,\r\n    path = [],\r\n  }) {\r\n    const selfPath = n =>\r\n      isPseudoRoot\r\n        ? []\r\n        : [...path, getNodeKey({ node: n, treeIndex: currentIndex })];\r\n  \r\n    // If the current position is the only possible place to add, add it\r\n    if (\r\n      currentIndex >= minimumTreeIndex - 1 ||\r\n      (isLastChild && !(node.children && node.children.length))\r\n    ) {\r\n      if (typeof node.children === 'function') {\r\n        throw new Error('Cannot add to children defined by a function');\r\n      } else {\r\n        const extraNodeProps = expandParent ? { expanded: true } : {};\r\n        const nextNode = {\r\n          ...node,\r\n  \r\n          ...extraNodeProps,\r\n          children: node.children ? [newNode, ...node.children] : [newNode],\r\n        };\r\n  \r\n        return {\r\n          node: nextNode,\r\n          nextIndex: currentIndex + 2,\r\n          insertedTreeIndex: currentIndex + 1,\r\n          parentPath: selfPath(nextNode),\r\n          parentNode: isPseudoRoot ? null : nextNode,\r\n        };\r\n      }\r\n    }\r\n  \r\n    // If this is the target depth for the insertion,\r\n    // i.e., where the newNode can be added to the current node's children\r\n    if (currentDepth >= targetDepth - 1) {\r\n      // Skip over nodes with no children or hidden children\r\n      if (\r\n        !node.children ||\r\n        typeof node.children === 'function' ||\r\n        (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n      ) {\r\n        return { node, nextIndex: currentIndex + 1 };\r\n      }\r\n  \r\n      // Scan over the children to see if there's a place among them that fulfills\r\n      // the minimumTreeIndex requirement\r\n      let childIndex = currentIndex + 1;\r\n      let insertedTreeIndex = null;\r\n      let insertIndex = null;\r\n      for (let i = 0; i < node.children.length; i += 1) {\r\n        // If a valid location is found, mark it as the insertion location and\r\n        // break out of the loop\r\n        if (childIndex >= minimumTreeIndex) {\r\n          insertedTreeIndex = childIndex;\r\n          insertIndex = i;\r\n          break;\r\n        }\r\n  \r\n        // Increment the index by the child itself plus the number of descendants it has\r\n        childIndex +=\r\n          1 + getDescendantCount({ node: node.children[i], ignoreCollapsed });\r\n      }\r\n  \r\n      // If no valid indices to add the node were found\r\n      if (insertIndex === null) {\r\n        // If the last position in this node's children is less than the minimum index\r\n        // and there are more children on the level of this node, return without insertion\r\n        if (childIndex < minimumTreeIndex && !isLastChild) {\r\n          return { node, nextIndex: childIndex };\r\n        }\r\n  \r\n        // Use the last position in the children array to insert the newNode\r\n        insertedTreeIndex = childIndex;\r\n        insertIndex = node.children.length;\r\n      }\r\n  \r\n      // Insert the newNode at the insertIndex\r\n      const nextNode = {\r\n        ...node,\r\n        children: [\r\n          ...node.children.slice(0, insertIndex),\r\n          newNode,\r\n          ...node.children.slice(insertIndex),\r\n        ],\r\n      };\r\n  \r\n      // Return node with successful insert result\r\n      return {\r\n        node: nextNode,\r\n        nextIndex: childIndex,\r\n        insertedTreeIndex,\r\n        parentPath: selfPath(nextNode),\r\n        parentNode: isPseudoRoot ? null : nextNode,\r\n      };\r\n    }\r\n  \r\n    // Skip over nodes with no children or hidden children\r\n    if (\r\n      !node.children ||\r\n      typeof node.children === 'function' ||\r\n      (node.expanded !== true && ignoreCollapsed && !isPseudoRoot)\r\n    ) {\r\n      return { node, nextIndex: currentIndex + 1 };\r\n    }\r\n  \r\n    // Get all descendants\r\n    let insertedTreeIndex = null;\r\n    let pathFragment = null;\r\n    let parentNode = null;\r\n    let childIndex = currentIndex + 1;\r\n    let newChildren = node.children;\r\n    if (typeof newChildren !== 'function') {\r\n      newChildren = newChildren.map((child, i) => {\r\n        if (insertedTreeIndex !== null) {\r\n          return child;\r\n        }\r\n  \r\n        const mapResult = addNodeAtDepthAndIndex({\r\n          targetDepth,\r\n          minimumTreeIndex,\r\n          newNode,\r\n          ignoreCollapsed,\r\n          expandParent,\r\n          isLastChild: isLastChild && i === newChildren.length - 1,\r\n          node: child,\r\n          currentIndex: childIndex,\r\n          currentDepth: currentDepth + 1,\r\n          getNodeKey,\r\n          path: [], // Cannot determine the parent path until the children have been processed\r\n        });\r\n  \r\n        if ('insertedTreeIndex' in mapResult) {\r\n          ({\r\n            insertedTreeIndex,\r\n            parentNode,\r\n            parentPath: pathFragment,\r\n          } = mapResult);\r\n        }\r\n  \r\n        childIndex = mapResult.nextIndex;\r\n  \r\n        return mapResult.node;\r\n      });\r\n    }\r\n  \r\n    const nextNode = { ...node, children: newChildren };\r\n    const result = {\r\n      node: nextNode,\r\n      nextIndex: childIndex,\r\n    };\r\n  \r\n    if (insertedTreeIndex !== null) {\r\n      result.insertedTreeIndex = insertedTreeIndex;\r\n      result.parentPath = [...selfPath(nextNode), ...pathFragment];\r\n      result.parentNode = parentNode;\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Insert a node into the tree at the given depth, after the minimum index\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {!number} depth - The depth to insert the node at (the first level of the array being depth 0)\r\n   * @param {!number} minimumTreeIndex - The lowest possible treeIndex to insert the node at\r\n   * @param {!Object} newNode - The node to insert into the tree\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   * @param {boolean=} expandParent - If true, expands the parent of the inserted node\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   *\r\n   * @return {Object} result\r\n   * @return {Object[]} result.treeData - The tree data with the node added\r\n   * @return {number} result.treeIndex - The tree index at which the node was inserted\r\n   * @return {number[]|string[]} result.path - Array of keys leading to the node location after insertion\r\n   * @return {Object} result.parentNode - The parent node of the inserted node\r\n   */\r\n  export function insertNode({\r\n    treeData,\r\n    depth: targetDepth,\r\n    minimumTreeIndex,\r\n    newNode,\r\n    getNodeKey = () => {},\r\n    ignoreCollapsed = true,\r\n    expandParent = false,\r\n  }) {\r\n    if (!treeData && targetDepth === 0) {\r\n      return {\r\n        treeData: [newNode],\r\n        treeIndex: 0,\r\n        path: [getNodeKey({ node: newNode, treeIndex: 0 })],\r\n        parentNode: null,\r\n      };\r\n    }\r\n  \r\n    const insertResult = addNodeAtDepthAndIndex({\r\n      targetDepth,\r\n      minimumTreeIndex,\r\n      newNode,\r\n      ignoreCollapsed,\r\n      expandParent,\r\n      getNodeKey,\r\n      isPseudoRoot: true,\r\n      isLastChild: true,\r\n      node: { children: treeData },\r\n      currentIndex: -1,\r\n      currentDepth: -1,\r\n    });\r\n  \r\n    if (!('insertedTreeIndex' in insertResult)) {\r\n      throw new Error('No suitable position found to insert.');\r\n    }\r\n  \r\n    const treeIndex = insertResult.insertedTreeIndex;\r\n    return {\r\n      treeData: insertResult.node.children,\r\n      treeIndex,\r\n      path: [\r\n        ...insertResult.parentPath,\r\n        getNodeKey({ node: newNode, treeIndex }),\r\n      ],\r\n      parentNode: insertResult.parentNode,\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * Get tree data flattened.\r\n   *\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {boolean=} ignoreCollapsed - Ignore children of nodes without `expanded` set to `true`\r\n   *\r\n   * @return {{\r\n   *      node: Object,\r\n   *      path: []string|[]number,\r\n   *      lowerSiblingCounts: []number\r\n   *  }}[] nodes - The node array\r\n   */\r\n  export function getFlatDataFromTree({\r\n    treeData,\r\n    getNodeKey,\r\n    ignoreCollapsed = true,\r\n  }) {\r\n    if (!treeData || treeData.length < 1) {\r\n      return [];\r\n    }\r\n  \r\n    const flattened = [];\r\n    walk({\r\n      treeData,\r\n      getNodeKey,\r\n      ignoreCollapsed,\r\n      callback: nodeInfo => {\r\n        flattened.push(nodeInfo);\r\n      },\r\n    });\r\n  \r\n    return flattened;\r\n  }\r\n  \r\n  /**\r\n   * Generate a tree structure from flat data.\r\n   *\r\n   * @param {!Object[]} flatData\r\n   * @param {!function=} getKey - Function to get the key from the nodeData\r\n   * @param {!function=} getParentKey - Function to get the parent key from the nodeData\r\n   * @param {string|number=} rootKey - The value returned by `getParentKey` that corresponds to the root node.\r\n   *                                  For example, if your nodes have id 1-99, you might use rootKey = 0\r\n   *\r\n   * @return {Object[]} treeData - The flat data represented as a tree\r\n   */\r\n  export function getTreeFromFlatData({\r\n    flatData,\r\n    getKey = node => node.id,\r\n    getParentKey = node => node.parentId,\r\n    rootKey = '0',\r\n  }) {\r\n    if (!flatData) {\r\n      return [];\r\n    }\r\n  \r\n    const childrenToParents = {};\r\n    flatData.forEach(child => {\r\n      const parentKey = getParentKey(child);\r\n  \r\n      if (parentKey in childrenToParents) {\r\n        childrenToParents[parentKey].push(child);\r\n      } else {\r\n        childrenToParents[parentKey] = [child];\r\n      }\r\n    });\r\n  \r\n    if (!(rootKey in childrenToParents)) {\r\n      return [];\r\n    }\r\n  \r\n    const trav = parent => {\r\n      const parentKey = getKey(parent);\r\n      if (parentKey in childrenToParents) {\r\n        return {\r\n          ...parent,\r\n          children: childrenToParents[parentKey].map(child => trav(child)),\r\n        };\r\n      }\r\n  \r\n      return { ...parent };\r\n    };\r\n  \r\n    return childrenToParents[rootKey].map(child => trav(child));\r\n  }\r\n  \r\n  /**\r\n   * Check if a node is a descendant of another node.\r\n   *\r\n   * @param {!Object} older - Potential ancestor of younger node\r\n   * @param {!Object} younger - Potential descendant of older node\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  export function isDescendant(older, younger) {\r\n    return (\r\n      !!older.children &&\r\n      typeof older.children !== 'function' &&\r\n      older.children.some(\r\n        child => child === younger || isDescendant(child, younger)\r\n      )\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Get the maximum depth of the children (the depth of the root node is 0).\r\n   *\r\n   * @param {!Object} node - Node in the tree\r\n   * @param {?number} depth - The current depth\r\n   *\r\n   * @return {number} maxDepth - The deepest depth in the tree\r\n   */\r\n  export function getDepth(node, depth = 0) {\r\n    if (!node.children) {\r\n      return depth;\r\n    }\r\n  \r\n    if (typeof node.children === 'function') {\r\n      return depth + 1;\r\n    }\r\n  \r\n    return node.children.reduce(\r\n      (deepest, child) => Math.max(deepest, getDepth(child, depth + 1)),\r\n      depth\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Find nodes matching a search query in the tree,\r\n   *\r\n   * @param {!function} getNodeKey - Function to get the key from the nodeData and tree index\r\n   * @param {!Object[]} treeData - Tree data\r\n   * @param {?string|number} searchQuery - Function returning a boolean to indicate whether the node is a match or not\r\n   * @param {!function} searchMethod - Function returning a boolean to indicate whether the node is a match or not\r\n   * @param {?number} searchFocusOffset - The offset of the match to focus on\r\n   *                                      (e.g., 0 focuses on the first match, 1 on the second)\r\n   * @param {boolean=} expandAllMatchPaths - If true, expands the paths to any matched node\r\n   * @param {boolean=} expandFocusMatchPaths - If true, expands the path to the focused node\r\n   *\r\n   * @return {Object[]} matches - An array of objects containing the matching `node`s, their `path`s and `treeIndex`s\r\n   * @return {Object[]} treeData - The original tree data with all relevant nodes expanded.\r\n   *                               If expandAllMatchPaths and expandFocusMatchPaths are both false,\r\n   *                               it will be the same as the original tree data.\r\n   */\r\n  export function find({\r\n    getNodeKey,\r\n    treeData,\r\n    searchQuery,\r\n    searchMethod,\r\n    searchFocusOffset,\r\n    expandAllMatchPaths = false,\r\n    expandFocusMatchPaths = true,\r\n  }) {\r\n    let matchCount = 0;\r\n    const trav = ({ isPseudoRoot = false, node, currentIndex, path = [] }) => {\r\n      let matches = [];\r\n      let isSelfMatch = false;\r\n      let hasFocusMatch = false;\r\n      // The pseudo-root is not considered in the path\r\n      const selfPath = isPseudoRoot\r\n        ? []\r\n        : [...path, getNodeKey({ node, treeIndex: currentIndex })];\r\n      const extraInfo = isPseudoRoot\r\n        ? null\r\n        : {\r\n            path: selfPath,\r\n            treeIndex: currentIndex,\r\n          };\r\n  \r\n      // Nodes with with children that aren't lazy\r\n      const hasChildren =\r\n        node.children &&\r\n        typeof node.children !== 'function' &&\r\n        node.children.length > 0;\r\n  \r\n      // Examine the current node to see if it is a match\r\n      if (!isPseudoRoot && searchMethod({ ...extraInfo, node, searchQuery })) {\r\n        if (matchCount === searchFocusOffset) {\r\n          hasFocusMatch = true;\r\n        }\r\n  \r\n        // Keep track of the number of matching nodes, so we know when the searchFocusOffset\r\n        //  is reached\r\n        matchCount += 1;\r\n  \r\n        // We cannot add this node to the matches right away, as it may be changed\r\n        //  during the search of the descendants. The entire node is used in\r\n        //  comparisons between nodes inside the `matches` and `treeData` results\r\n        //  of this method (`find`)\r\n        isSelfMatch = true;\r\n      }\r\n  \r\n      let childIndex = currentIndex;\r\n      const newNode = { ...node };\r\n      if (hasChildren) {\r\n        // Get all descendants\r\n        newNode.children = newNode.children.map(child => {\r\n          const mapResult = trav({\r\n            node: child,\r\n            currentIndex: childIndex + 1,\r\n            path: selfPath,\r\n          });\r\n  \r\n          // Ignore hidden nodes by only advancing the index counter to the returned treeIndex\r\n          // if the child is expanded.\r\n          //\r\n          // The child could have been expanded from the start,\r\n          // or expanded due to a matching node being found in its descendants\r\n          if (mapResult.node.expanded) {\r\n            childIndex = mapResult.treeIndex;\r\n          } else {\r\n            childIndex += 1;\r\n          }\r\n  \r\n          if (mapResult.matches.length > 0 || mapResult.hasFocusMatch) {\r\n            matches = [...matches, ...mapResult.matches];\r\n            if (mapResult.hasFocusMatch) {\r\n              hasFocusMatch = true;\r\n            }\r\n  \r\n            // Expand the current node if it has descendants matching the search\r\n            // and the settings are set to do so.\r\n            if (\r\n              (expandAllMatchPaths && mapResult.matches.length > 0) ||\r\n              ((expandAllMatchPaths || expandFocusMatchPaths) &&\r\n                mapResult.hasFocusMatch)\r\n            ) {\r\n              newNode.expanded = true;\r\n            }\r\n          }\r\n  \r\n          return mapResult.node;\r\n        });\r\n      }\r\n  \r\n      // Cannot assign a treeIndex to hidden nodes\r\n      if (!isPseudoRoot && !newNode.expanded) {\r\n        matches = matches.map(match => ({\r\n          ...match,\r\n          treeIndex: null,\r\n        }));\r\n      }\r\n  \r\n      // Add this node to the matches if it fits the search criteria.\r\n      // This is performed at the last minute so newNode can be sent in its final form.\r\n      if (isSelfMatch) {\r\n        matches = [{ ...extraInfo, node: newNode }, ...matches];\r\n      }\r\n  \r\n      return {\r\n        node: matches.length > 0 ? newNode : node,\r\n        matches,\r\n        hasFocusMatch,\r\n        treeIndex: childIndex,\r\n      };\r\n    };\r\n  \r\n    const result = trav({\r\n      node: { children: treeData },\r\n      isPseudoRoot: true,\r\n      currentIndex: -1,\r\n    });\r\n  \r\n    return {\r\n      matches: result.matches,\r\n      treeData: result.node.children,\r\n    };\r\n  }","import React, { Component } from \"react\";\nimport { Table, unflatten, flatten } from \"tablex\";\nimport { Button, Input, Menu, InputNumber } from \"antd\";\nimport { find } from \"./tree-data-utils\";\nimport _ from \"lodash\";\nimport \"./index.css\";\n\nconst { Search } = Input;\n\nfunction requestGet(url, options) {\n  let xhr = new XMLHttpRequest();\n  xhr.open(\"GET\", url, true);\n\n  xhr.onreadystatechange = function() {};\n\n  xhr.onload = function() {\n    if (xhr.status == 200) {\n      if (typeof options.onSuccess === \"function\") {\n        var res = {};\n        if (xhr.responseText) {\n          res = JSON.parse(xhr.responseText);\n        }\n        options.onSuccess(res);\n      }\n    }\n  };\n\n  xhr.onerror = options.onError;\n\n  xhr.send();\n}\n\nfunction createData(level, parentKey, maxLevel, index) {\n  if (level > maxLevel) {\n    return;\n  }\n\n  let l = level;\n  let data = [];\n  for (let i = 0; i < 5; i++) {\n    let k = parentKey + \"-\" + level + \"-\" + i;\n    let d = {\n      id: k,\n      name: \"Edward King \" + k,\n      age: 32,\n      address: \"London, Park Lane no. \" + i\n    };\n\n    if (i % 2 === 0) {\n      d.children = createData(l + 1, k, maxLevel, i);\n    }\n\n    data.push(d);\n  }\n  return data;\n}\n\nfunction createTreeData() {\n  let data = [];\n  for (let i = 0; i < 100; i++) {\n    data.push({\n      id: \"\" + i,\n      level: 0,\n      name: \"Edward King \" + i,\n      age: 32,\n      address: \"London, Park Lane no. \" + i,\n      children: createData(0, i, 4)\n    });\n  }\n\n  return data;\n}\n\nclass Demo extends Component {\n  columns = [\n    {\n      dataIndex: \"code\",\n      key: \"code\",\n      title: \"\",\n      width: 200\n    },\n    {\n      title: \"\",\n      width: 150,\n      key: \"name\",\n      dataIndex: \"name\"\n    },\n    {\n      dataIndex: \"description\",\n      key: \"description\",\n      title: \"\",\n      width: 150\n    },\n    {\n      dataIndex: \"unit\",\n      key: \"unit\",\n      title: \"\",\n      width: 150\n    },\n    {\n      dataIndex: \"quantities\",\n      key: \"quantities\",\n      title: \"\",\n      width: 150,\n      editor: (value, record, index, onchange, ref, validate) => {\n        return (\n          <Input\n            defaultValue={value}\n            ref={ref}\n            onChange={v => {\n              onchange({ quantities: v.target.value });\n            }}\n          />\n        );\n      }\n    },\n    {\n      dataIndex: \"unitPrice\",\n      key: \"unitPrice\",\n      title: \"\",\n      width: 150,\n      editor: (value, record, index, onchange, ref, validate) => {\n        return (\n          <InputNumber\n            defaultValue={value}\n            ref={ref}\n            onKeyDown={e => {\n              e.stopPropagation();\n            }}\n            onChange={e => {\n              onchange({ unitPrice: e });\n            }}\n          />\n        );\n      }\n    },\n    {\n      dataIndex: \"totalPrice\",\n      key: \"totalPrice\",\n      title: \"\",\n      width: 150,\n      render: (value, row) => {\n        let v = row.unitPrice * row.quantities;\n        if (isNaN(v)) {\n          return \"\";\n        }\n        return v;\n      }\n    },\n    {\n      dataIndex: \"evaluation\",\n      key: \"evaluation\",\n      title: \"\",\n      width: 150\n    }\n  ];\n\n  state = {\n    loading: false,\n    treeData: [],\n    rawTreeData: [],\n    flatData: [],\n    rawFlatData: [],\n    expandedRowKeys: [],\n    selectedRowKeys: []\n  };\n\n  getData = () => {\n    this.setState({ loading: true });\n\n    let c = 0;\n    requestGet(\"/public/data.json\", {\n      onSuccess: data => {\n        data = _.uniqBy(data, d => {\n          return d.code;\n        });\n\n        let bl = false;\n\n        data.forEach(d => {\n          let id = d.code || \"\";\n          let pid = \"\";\n          let len = id.length;\n          d.id = id;\n\n          if (len >= 2) {\n            let pl = 2;\n\n            if (len % 2 !== 0) {\n              pl = 3;\n            }\n\n            if (id === \"040704\") {\n              bl = true;\n            }\n\n            if (bl === true) {\n              pid = \"0407\";\n            } else {\n              pid = id.substring(0, len - pl);\n            }\n          }\n\n          d.pid = pid;\n        });\n\n        let treeData = unflatten(data, \"id\", \"pid\");\n\n        this.setState({\n          loading: false,\n          treeData: treeData,\n          rawTreeData: treeData.slice(),\n          flatData: data,\n          rawFlatData: data.slice()\n        });\n      }\n    });\n  };\n\n  componentDidMount() {}\n\n  scrollToItem = index => {\n    if (this.refs.tb) {\n      this.refs.tb.scrollToItem(index, \"center\");\n    }\n  };\n\n  expandTo = (depth = 2) => {\n    let keys = [];\n\n    let pl = 2;\n\n    this.state.flatData.forEach(d => {\n      let len = d.id.length;\n      if (len <= depth * pl) {\n        keys.push(d.id);\n      }\n    });\n\n    this.setState({ expandedRowKeys: keys });\n  };\n\n  expandAll = () => {\n    let keys = this.state.flatData.map(d => {\n      return d.id;\n    });\n\n    this.setState({ expandedRowKeys: keys });\n  };\n  collapseAll = () => {\n    this.setState({ expandedRowKeys: [] });\n  };\n\n  contentMenuRow = null;\n  showContextMenu = ({ left, top, data }) => {\n    this.contentMenuRow = data;\n    let el = document.getElementById(\"contextMenu\");\n    if (el) {\n      el.style.top = top + \"px\";\n      el.style.left = left + \"px\";\n      el.style.display = \"block\";\n      el.focus();\n    }\n  };\n\n  hideContextMenu = () => {\n    this.contentMenuRow = null;\n    let el = document.getElementById(\"contextMenu\");\n    if (el) {\n      el.style.display = \"none\";\n    }\n  };\n\n  onRow = row => {\n    return {\n      onContextMenu: e => {\n        e.preventDefault();\n        e.stopPropagation();\n        this.showContextMenu({ left: e.pageX, top: e.pageY, data: row });\n      }\n    };\n  };\n\n  setTreeData = (data, callback) => {\n    let bd = new Date();\n    console.log(\"tree data flattening :\", data.length);\n    let treeData = unflatten(data, \"id\", \"pid\");\n    console.log(\n      \"tree data flatten finished :\",\n      (new Date().getTime() - bd.getTime()) / 1000\n    );\n\n    this.setState(\n      { treeData: treeData, flatData: data, loading: false },\n      callback\n    );\n  };\n\n  rowKey = \"id\";\n  deleteRow = row => {\n    let rowKey = this.rowKey;\n    let key = row[rowKey];\n    let { flatData } = this.state;\n\n    let i = flatData.findIndex(d => d[rowKey] === key);\n    if (i > -1) {\n      flatData.splice(i, 1);\n    }\n    this.setTreeData(flatData);\n  };\n\n  copiedRow = null;\n  copy = row => {\n    let rowData = {};\n\n    for (const k in row) {\n      if (row.hasOwnProperty(k) && k !== \"children\") {\n        rowData[k] = row[k];\n      }\n    }\n    let str = JSON.stringify(rowData);\n    this.copiedRow = JSON.stringify(rowData);\n\n    const input = document.createElement(\"input\");\n    document.body.appendChild(input);\n    input.setAttribute(\"value\", str);\n    input.select();\n    if (document.execCommand(\"copy\")) {\n      document.execCommand(\"copy\");\n    }\n    document.body.removeChild(input);\n  };\n\n  pasteChildren = targetRow => {\n    let rowKey = this.rowKey;\n\n    let copiedRow = this.copiedRow;\n\n    if (copiedRow) {\n      let sourceRow = JSON.parse(copiedRow);\n\n      let { list, roots } = flatten([sourceRow]);\n\n      let sourceRowList = [];\n\n      for (let i = 0; i < list.length; i++) {\n        let d = Object.assign({}, list[i]);\n        if (this.isCut !== true) {\n          d[rowKey] = d[rowKey] + \"_copiedRow\";\n          d[\"pid\"] = targetRow[rowKey];\n        }\n        sourceRowList.push(d);\n      }\n\n      let { flatData } = this.state;\n\n      if (this.isCut === true) {\n        let i = flatData.findIndex(d => d[rowKey] === sourceRow[rowKey]);\n        if (i > -1) {\n          flatData.splice(i, 1);\n        }\n      }\n\n      flatData = flatData.concat(sourceRowList);\n\n      this.isCut = false;\n      this.copiedRow = null;\n      this.setTreeData(flatData);\n    }\n  };\n\n  isCut = false;\n  cut = row => {\n    this.copy(row);\n    this.isCut = true;\n  };\n\n  toggleSelectOrExpand = (rowData, type = 0) => {\n    let stateName = [\"expandedRowKeys\", \"selectedRowKeys\"][type];\n\n    let bd = new Date();\n    console.log(\"toggleSelectOrExpand \" + stateName + \" :\");\n\n    let rowKey = this.rowKey;\n    let key = rowData[rowKey];\n    let keys = this.state[stateName];\n\n    let nextKeys = [];\n\n    let keysMap = {};\n\n    for (let i = 0; i < keys.length; i++) {\n      keysMap[keys[i]] = true;\n    }\n\n    let { list } = flatten([rowData]);\n\n    let isExist = keysMap[key] === true;\n\n    for (let i = 0; i < list.length; i++) {\n      const k = list[i][rowKey];\n\n      if (isExist) {\n        keysMap[k] = false;\n      } else {\n        if (keysMap[k] !== true) {\n          keysMap[k] = true;\n        }\n      }\n    }\n\n    for (const d in keysMap) {\n      if (keysMap[d] === true) {\n        nextKeys.push(d);\n      }\n    }\n\n    console.log(\n      \"toggleSelectOrExpand \" + stateName + \":\",\n      (new Date().getTime() - bd.getTime()) / 1000\n    );\n\n    this.setState({ [stateName]: nextKeys });\n  };\n\n  selectAll = rowData => {\n    this.toggleSelectOrExpand(rowData, 1);\n  };\n\n  expandToggle = rowData => {\n    this.toggleSelectOrExpand(rowData, 0);\n  };\n\n  onMenuClick = ({ key }) => {\n    let actions = {\n      del: this.deleteRow,\n      copy: this.copy,\n      cut: this.cut,\n      pasteChildren: this.pasteChildren,\n      selectAll: this.selectAll,\n      expandToggle: this.expandToggle,\n      export: this.export\n    };\n\n    let fn = actions[key];\n    if (typeof fn === \"function\") {\n      fn(this.contentMenuRow);\n    }\n  };\n\n  searchIndex = -1;\n  searchedKey = \"\";\n  onChangeSearch = () => {\n    this.searchIndex = 0;\n    this.searchedKey = \"\";\n  };\n\n  onSearch = v => {\n    let { flatData } = this.state;\n\n    if (!v) {\n      this.searchIndex = 0;\n      this.searchedKey = \"\";\n      this.forceUpdate();\n      return;\n    }\n\n    //\n    this.expandAll();\n\n    let searchedIndex = -1;\n    let searchedKey = \"\";\n\n    for (let i = this.searchIndex + 1, len = flatData.length; i < len; i++) {\n      let name = flatData[i].name;\n\n      if (name.indexOf(v) > -1) {\n        searchedIndex = i;\n        searchedKey = flatData[i].id;\n        break;\n      }\n    }\n\n    if (searchedIndex > -1) {\n      this.scrollToItem(searchedIndex);\n      this.searchIndex = searchedIndex + 1;\n      this.searchedKey = searchedKey;\n    } else {\n      this.searchIndex = -1;\n      this.searchedKey = \"\";\n    }\n  };\n\n  onFilter = v => {\n    let rowKey = this.rowKey;\n    let { rawTreeData, rawFlatData } = this.state;\n\n    if (!v) {\n      this.setTreeData(rawFlatData.slice(), this.collapseAll);\n      return;\n    }\n\n    let { matches } = find({\n      getNodeKey: ({ node }) => {\n        return node[rowKey];\n      },\n      treeData: rawTreeData.slice(),\n      searchQuery: v,\n      searchMethod: ({ node }) => {\n        return node.name.indexOf(v) > -1;\n      },\n      searchFocusOffset: 0\n    });\n\n    let flatDataMap = {};\n\n    for (let i = 0; i < rawFlatData.length; i++) {\n      const d = rawFlatData[i];\n      flatDataMap[d[rowKey]] = d;\n    }\n\n    let list = [];\n\n    for (let i = 0; i < matches.length; i++) {\n      const d = matches[i];\n      let paths = d.path || [];\n\n      for (let j = 0; j < paths.length; j++) {\n        let p = flatDataMap[paths[j]];\n        if (p) {\n          list.push(p);\n        }\n      }\n    }\n\n    list = _.uniqBy(list, d => {\n      return d[rowKey];\n    });\n\n    this.setTreeData(list, this.expandAll);\n  };\n\n  rowClassName = (row, index) => {\n    if (row.id === this.searchedKey) {\n      return \"row-searched\";\n    }\n\n    return \"\";\n  };\n\n  render() {\n    let menuItemStyle = { height: \"auto\", lineHeight: \"normal\" };\n\n    return (\n      <div style={{ height: \"100%\" }}>\n        <Table\n          rowKey=\"id\"\n          editable={true}\n          ref=\"tb\"\n          loading={this.state.loading}\n          rowClassName={this.rowClassName}\n          expandedRowKeys={this.state.expandedRowKeys}\n          onExpandedRowsChange={keys => {\n            this.setState({ expandedRowKeys: keys });\n          }}\n          selectedRowKeys={this.state.selectedRowKeys}\n          onSelectChange={keys => {\n            this.setState({ selectedRowKeys: keys });\n          }}\n          columns={this.columns}\n          selectMode=\"multiple\"\n          checkStrictly={false}\n          data={this.state.treeData}\n          orderNumber={{resizable:true}}\n          onRow={this.onRow}\n          validateTrigger=\"onChange\"\n          header={() => (\n            <div style={{ padding: \"10px 0\" }}>\n              <Button onClick={this.getData}></Button>\n              <Button onClick={this.expandAll} style={{ margin: \"0 5px\" }}>\n                \n              </Button>\n              <Button\n                onClick={() => this.expandTo(2)}\n                style={{ margin: \"0 5px\" }}\n              >\n                \n              </Button>\n\n              <Button onClick={this.collapseAll}></Button>\n              <Search\n                style={{ float: \"right\", margin: \"0 5px\", width: \"150px\" }}\n                placeholder=\"\"\n                onSearch={this.onFilter}\n              />\n              <Search\n                style={{ float: \"right\", margin: \"0 5px\", width: \"150px\" }}\n                placeholder=\"\"\n                onSearch={this.onSearch}\n                onChange={this.onChangeSearch}\n              />\n            </div>\n          )}\n        />\n        <Menu\n          style={{\n            display: \"none\",\n            position: \"fixed\",\n            border: \"1px solid #ccc\",\n            boxShadow: \"2px 2px 5px 2px rgba(0, 0, 0, 0.15)\"\n          }}\n          tabIndex=\"1\"\n          id=\"contextMenu\"\n          onBlur={this.hideContextMenu}\n          onClick={this.onMenuClick}\n          selectable={false}\n        >\n          <Menu.Item key=\"del\" style={menuItemStyle}>\n            \n          </Menu.Item>\n          <Menu.Item key=\"copy\" style={menuItemStyle}>\n            \n          </Menu.Item>\n          <Menu.Item key=\"cut\" style={menuItemStyle}>\n            \n          </Menu.Item>\n          <Menu.Item key=\"pasteChildren\" style={menuItemStyle}>\n            ()\n          </Menu.Item>\n          <Menu.Item key=\"selectAll\" style={menuItemStyle}>\n            /\n          </Menu.Item>\n          <Menu.Item key=\"expandToggle\" style={menuItemStyle}>\n            /\n          </Menu.Item>\n          <Menu.Item key=\"export\" style={menuItemStyle}>\n            \n          </Menu.Item>\n          <Menu.Item key=\"print\" style={menuItemStyle}>\n            \n          </Menu.Item>\n        </Menu>\n      </div>\n    );\n  }\n}\n\nexport default Demo;\n","/* @jsx mdx */\n  import React from 'react'\n  import { mdx } from '@mdx-js/react'\n  /* @jsx mdx */\nimport { Playground, Props } from \"docz\";\nimport Table, { flatten } from \"tablex\";\nimport { Input, Checkbox } from \"antd\";\nimport Complex from \"./complex\";\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"usage\"\n    }}>{`Usage`}</h1>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`import Table, { flatten, unflatten } from \"tablex\";\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"edit-and-validate\"\n    }}>{`edit and validate`}</h2>\n    <Playground __position={0} __code={'class Demo extends React.Component {\\n    generateData(columns, count = 20, prefix = \\'Row\\') {\\n      return new Array(count).fill(0).map((row, rowIndex) => {\\n        return columns.reduce(\\n          (rowData, column, columnIndex) => {\\n            if (column.dataIndex !== \\'id\\') {\\n              rowData[column.dataIndex] = Math.floor(Math.random() * 100 + 1)\\n            } else {\\n              rowData[column.dataIndex] =\\n                prefix + \\' \\' + rowIndex + \\' - Col \\' + columnIndex\\n            }\\n            return rowData\\n          },\\n          {\\n            id: prefix + rowIndex,\\n            parentId: null,\\n          },\\n        )\\n      })\\n    }\\n    constructor(props) {\\n      super(props)\\n      const columns = [\\n        {\\n          dataIndex: \\'id\\',\\n          title: \\'id\\',\\n          key: \\'id\\',\\n          width: 150,\\n          align: \\'center\\',\\n        },\\n        {\\n          dataIndex: \\'column-1\\',\\n          title: \\'column-1\\',\\n          width: 100,\\n          validator: function(value, row) {\\n            if (!value) {\\n              return { valid: false, message: \\'\\' }\\n            }\\n\\n            return { valid: true, message: \\'false\\' }\\n          },\\n          editor: function(value, row, index, onchange, ref) {\\n            return (\\n              <Input\\n                defaultValue={value}\\n                ref={ref}\\n                onChange={e => onchange({ [\\'column-1\\']: e.target.value })}\\n              />\\n            )\\n          },\\n        },\\n\\n        {\\n          dataIndex: \\'column-2\\',\\n          title: \\'column-2\\',\\n          width: 150,\\n          align: \\'center\\',\\n        },\\n\\n        {\\n          dataIndex: \\'column-3\\',\\n          title: \\'column-3\\',\\n          align: \\'right\\',\\n        },\\n        {\\n          dataIndex: \\'column-4\\',\\n          title: \\'column-4\\',\\n          width: 100,\\n          align: \\'center\\',\\n        },\\n      ]\\n\\n      let data = this.generateData(columns, 10)\\n\\n      this.state = {\\n        data: data,\\n        columns: columns,\\n      }\\n    }\\n    onEditSave(changedRows, newData, type) {\\n      console.log(\\'onEditSave:\\', newData)\\n      this.setState({\\n        data: newData,\\n      })\\n    }\\n    render() {\\n      let { columns, data } = this.state\\n      return (\\n        <Table\\n          rowKey=\\\"id\\\"\\n          columns={columns}\\n          validateTrigger=\\\"onChange\\\"\\n          data={data}\\n          editable={true}\\n          editTools={[\\'edit\\', \\'add\\', \\'delete\\']}\\n          onEditSave={this.onEditSave.bind(this)}\\n        />\\n      )\\n    }\\n  }'} __scope={{\n      props: this ? this.props : props,\n      Playground,\n      Props,\n      Table,\n      flatten,\n      Input,\n      Checkbox,\n      Complex\n    }} style={{\n      height: 400\n    }} mdxType=\"Playground\">\n {class Demo extends React.Component {\n        generateData(columns, count = 20, prefix = \"Row\") {\n          return new Array(count).fill(0).map((row, rowIndex) => {\n            return columns.reduce((rowData, column, columnIndex) => {\n              if (column.dataIndex !== \"id\") {\n                rowData[column.dataIndex] = Math.floor(Math.random() * 100 + 1);\n              } else {\n                rowData[column.dataIndex] = prefix + \" \" + rowIndex + \" - Col \" + columnIndex;\n              }\n\n              return rowData;\n            }, {\n              id: prefix + rowIndex,\n              parentId: null\n            });\n          });\n        }\n\n        constructor(props) {\n          super(props);\n          const columns = [{\n            dataIndex: \"id\",\n            title: \"id\",\n            key: \"id\",\n            width: 150,\n            align: \"center\"\n          }, {\n            dataIndex: \"column-1\",\n            title: \"column-1\",\n            width: 100,\n            validator: function (value, row) {\n              if (!value) {\n                return {\n                  valid: false,\n                  message: \"\"\n                };\n              }\n\n              return {\n                valid: true,\n                message: \"false\"\n              };\n            },\n            editor: function (value, row, index, onchange, ref) {\n              return <Input defaultValue={value} ref={ref} onChange={e => onchange({\n                [\"column-1\"]: e.target.value\n              })} mdxType=\"Input\" />;\n            }\n          }, {\n            dataIndex: \"column-2\",\n            title: \"column-2\",\n            width: 150,\n            align: \"center\"\n          }, {\n            dataIndex: \"column-3\",\n            title: \"column-3\",\n            align: \"right\"\n          }, {\n            dataIndex: \"column-4\",\n            title: \"column-4\",\n            width: 100,\n            align: \"center\"\n          }];\n          let data = this.generateData(columns, 10);\n          this.state = {\n            data: data,\n            columns: columns\n          };\n        }\n\n        onEditSave(changedRows, newData, type) {\n          console.log(\"onEditSave:\", newData);\n          this.setState({\n            data: newData\n          });\n        }\n\n        render() {\n          let {\n            columns,\n            data\n          } = this.state;\n          return <Table rowKey=\"id\" columns={columns} validateTrigger=\"onChange\" data={data} editable={true} editTools={['edit', 'add', 'delete']} onEditSave={this.onEditSave.bind(this)} mdxType=\"Table\" />;\n        }\n\n      }}\n    </Playground>\n    <h2 {...{\n      \"id\": \"edit-with-50k-nested-rows\"\n    }}>{`edit with 50K nested rows`}</h2>\n    <Playground __position={1} __code={'<Complex />'} __scope={{\n      props: this ? this.props : props,\n      Playground,\n      Props,\n      Table,\n      flatten,\n      Input,\n      Checkbox,\n      Complex\n    }} style={{\n      height: 600\n    }} mdxType=\"Playground\">\n  <Complex mdxType=\"Complex\" />\n    </Playground>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\n  "],"sourceRoot":""}